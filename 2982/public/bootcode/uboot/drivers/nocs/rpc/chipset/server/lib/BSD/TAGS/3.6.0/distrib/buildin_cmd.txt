BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:login_shell:progcomp:promptvars:sourcepath
BASH_ALIASES=()
BASH_ARGC=()
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION=/etc/bash_completion
BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
BASH_COMPLETION_DIR=/etc/bash_completion.d
BASH_LINENO=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="4" [1]="1" [2]="5" [3]="1" [4]="release" [5]="x86_64-pc-linux-gnu")
BASH_VERSION='4.1.5(1)-release'
COLUMNS=100
COMP_WORDBREAKS=$' \t\n"\'><=;|&(:'
DERBY_HOME=/usr/lib/jvm/java-6-oracle/db
DIRSTACK=()
DISPLAY=localhost:13.0
EUID=1007
GROUPS=()
HISTCONTROL=ignoredups:ignorespace
HISTFILE=/home/alexkh/.bash_history
HISTFILESIZE=2000
HISTSIZE=1000
HOME=/home/alexkh
HOSTNAME=OS-server01
HOSTTYPE=x86_64
IFS=$' \t\n'
J2REDIR=/usr/lib/jvm/java-6-oracle/jre
J2SDKDIR=/usr/lib/jvm/java-6-oracle
JAVA_HOME=/usr/lib/jvm/java-6-oracle
LANG=en_US.UTF-8
LESSCLOSE='/usr/bin/lesspipe %s %s'
LESSOPEN='| /usr/bin/lesspipe %s'
LINES=34
LOGNAME=alexkh
LS_COLORS='rs=0:di=01;34:ln=01;36:hl=44;37:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.lzma=01;31:*.zip=01;31:*.z=01;31:*.Z=01;31:*.dz=01;31:*.gz=01;31:*.bz2=01;31:*.bz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.rar=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.jpg=01;35:*.jpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.axv=01;35:*.anx=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.axa=00;36:*.oga=00;36:*.spx=00;36:*.xspf=00;36:'
MACHTYPE=x86_64-pc-linux-gnu
MAIL=/var/mail/alexkh
MAILCHECK=60
OLDPWD=/home/alexkh/nfs/kernel/sirius/bootcode_NOCS/uboot/drivers/nocs/rpc/chipset
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/lib/jvm/java-6-oracle/bin:/usr/lib/jvm/java-6-oracle/db/bin:/usr/lib/jvm/java-6-oracle/jre/bin
PIPESTATUS=([0]="0")
PPID=17075
PS1='\[\e]0;\u@\h: \w\a\]${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
PS2='> '
PS4='+ '
PWD=/home/alexkh/nfs/kernel/sirius/bootcode_NOCS/uboot/drivers/nocs/rpc/chipset/server/lib/BSD/TAGS/3.3.1/distrib
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=1
SPEECHD_PORT=7567
SSH_CLIENT='172.21.98.172 3944 22'
SSH_CONNECTION='172.21.98.172 3944 172.21.15.153 22'
SSH_TTY=/dev/pts/18
SVN_EDITOR=vim
TERM=xterm
UID=1007
USER=alexkh
USE_CCACHE=1
XDG_SESSION_COOKIE=7e3b416f808fbfa7bbe8419651bb3db1-1401102841.882099-1231269612
_=set
__git_all_commands=
__git_diff_algorithms='myers minimal patience histogram'
__git_diff_common_options=$'--stat --numstat --shortstat --summary\n\t\t\t--patch-with-stat --name-only --name-status --color\n\t\t\t--no-color --color-words --no-renames --check\n\t\t\t--full-index --binary --abbrev --diff-filter=\n\t\t\t--find-copies-harder\n\t\t\t--text --ignore-space-at-eol --ignore-space-change\n\t\t\t--ignore-all-space --exit-code --quiet --ext-diff\n\t\t\t--no-ext-diff\n\t\t\t--no-prefix --src-prefix= --dst-prefix=\n\t\t\t--inter-hunk-context=\n\t\t\t--patience --histogram --minimal\n\t\t\t--raw --word-diff\n\t\t\t--dirstat --dirstat= --dirstat-by-file\n\t\t\t--dirstat-by-file= --cumulative\n\t\t\t--diff-algorithm=\n'
__git_fetch_options=$'\n\t--quiet --verbose --append --upload-pack --force --keep --depth=\n\t--tags --no-tags --all --prune --dry-run\n'
__git_format_patch_options=$'\n\t--stdout --attach --no-attach --thread --thread= --no-thread\n\t--numbered --start-number --numbered-files --keep-subject --signoff\n\t--signature --no-signature --in-reply-to= --cc= --full-index --binary\n\t--not --all --cover-letter --no-prefix --src-prefix= --dst-prefix=\n\t--inline --suffix= --ignore-if-in-upstream --subject-prefix=\n\t--output-directory --reroll-count --to= --quiet --notes\n'
__git_log_common_options=$'\n\t--not --all\n\t--branches --tags --remotes\n\t--first-parent --merges --no-merges\n\t--max-count=\n\t--max-age= --since= --after=\n\t--min-age= --until= --before=\n\t--min-parents= --max-parents=\n\t--no-min-parents --no-max-parents\n'
__git_log_date_formats='relative iso8601 rfc2822 short local default raw'
__git_log_gitk_options=$'\n\t--dense --sparse --full-history\n\t--simplify-merges --simplify-by-decoration\n\t--left-right --notes --no-notes\n'
__git_log_pretty_formats='oneline short medium full fuller email raw format:'
__git_log_shortlog_options=$'\n\t--author= --committer= --grep=\n\t--all-match\n'
__git_merge_options=$'\n\t--no-commit --no-stat --log --no-log --squash --strategy\n\t--commit --stat --no-squash --ff --no-ff --ff-only --edit --no-edit\n'
__git_merge_strategies=
__git_mergetools_common=$'diffuse ecmerge emerge kdiff3 meld opendiff\n\t\t\ttkdiff vimdiff gvimdiff xxdiff araxis p4merge bc3 codecompare\n'
__git_porcelain_commands=
__git_printf_supports_v=yes
__git_send_email_confirm_options='always never auto cc compose'
__git_send_email_suppresscc_options='author self cc bodycc sob cccmd body all'
__git_whitespacelist='nowarn warn error error-all fix'
bash205='4.1.5(1)-release'
bash205b='4.1.5(1)-release'
bash3='4.1.5(1)-release'
bash4='4.1.5(1)-release'
_ImageMagick () 
{ 
    local prev;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -channel)
            COMPREPLY=($( compgen -W 'Red Green Blue Opacity \
                Matte Cyan Magenta Yellow Black' -- "$cur" ));
            return 0
        ;;
        -colormap)
            COMPREPLY=($( compgen -W 'shared private' -- "$cur" ));
            return 0
        ;;
        -colorspace)
            COMPREPLY=($( compgen -W 'GRAY OHTA RGB Transparent \
                XYZ YCbCr YIQ YPbPr YUV CMYK' -- "$cur" ));
            return 0
        ;;
        -compose)
            COMPREPLY=($( compgen -W 'Over In Out Atop Xor Plus \
                Minus Add Subtract Difference Multiply Bumpmap\
                Copy CopyRed CopyGreen CopyBlue CopyOpacity' -- "$cur" ));
            return 0
        ;;
        -compress)
            COMPREPLY=($( compgen -W 'None BZip Fax Group4 JPEG \
                Lossless LZW RLE Zip' -- "$cur" ));
            return 0
        ;;
        -dispose)
            COMPREPLY=($( compgen -W 'Undefined None Background Previous'                 -- "$cur" ));
            return 0
        ;;
        -encoding)
            COMPREPLY=($( compgen -W 'AdobeCustom AdobeExpert \
                AdobeStandard AppleRoman BIG5 GB2312 Latin2 \
                None SJIScode Symbol Unicode Wansung' -- "$cur"));
            return 0
        ;;
        -endian)
            COMPREPLY=($( compgen -W 'MSB LSB' -- "$cur" ));
            return 0
        ;;
        -filter)
            COMPREPLY=($( compgen -W 'Point Box Triangle Hermite \
                Hanning Hamming Blackman Gaussian Quadratic \
                Cubic Catrom Mitchell Lanczos Bessel Sinc' -- "$cur" ));
            return 0
        ;;
        -format)
            COMPREPLY=($( compgen -W "$( convert -list format |                 awk '/ [r-][w-][+-] / {print $1}' |                 tr -d '*' | tr [:upper:] [:lower:] )" -- "$cur" ));
            return 0
        ;;
        -gravity)
            COMPREPLY=($( compgen -W 'Northwest North NorthEast \
                West Center East SouthWest South SouthEast' -- "$cur" ));
            return 0
        ;;
        -intent)
            COMPREPLY=($( compgen -W 'Absolute Perceptual \
                Relative Saturation' -- "$cur" ));
            return 0
        ;;
        -interlace)
            COMPREPLY=($( compgen -W 'None Line Plane Partition' -- "$cur" ));
            return 0
        ;;
        -limit)
            COMPREPLY=($( compgen -W 'Disk File Map Memory' -- "$cur" ));
            return 0
        ;;
        -list)
            COMPREPLY=($( compgen -W 'Delegate Format Magic Module Resource \
                Type' -- "$cur" ));
            return 0
        ;;
        -map)
            COMPREPLY=($( compgen -W 'best default gray red green blue'                 -- "$cur" ));
            _filedir;
            return 0
        ;;
        -noise)
            COMPREPLY=($( compgen -W 'Uniform Gaussian Multiplicative \
                Impulse Laplacian Poisson' -- "$cur" ));
            return 0
        ;;
        -preview)
            COMPREPLY=($( compgen -W 'Rotate Shear Roll Hue \
                Saturation Brightness Gamma Spiff \
                Dull Grayscale Quantize Despeckle \
                ReduceNoise AddNoise Sharpen Blur \
                Treshold EdgeDetect Spread Shade \
                Raise Segment Solarize Swirl Implode \
                Wave OilPaint CharcoalDrawing JPEG' -- "$cur" ));
            return 0
        ;;
        -@(mask|profile|texture|tile|write))
            _filedir;
            return 0
        ;;
        -type)
            COMPREPLY=($( compgen -W 'Bilevel Grayscale Palette PaletteMatte \
                TrueColor TrueColorMatte ColorSeparation ColorSeparationlMatte \
                Optimize' -- "$cur" ));
            return 0
        ;;
        -units)
            COMPREPLY=($( compgen -W 'Undefined PixelsPerInch \
                PixelsPerCentimeter' -- "$cur" ));
            return 0
        ;;
        -virtual-pixel)
            COMPREPLY=($( compgen -W 'Constant Edge mirror tile' -- "$cur" ));
            return 0
        ;;
        -visual)
            COMPREPLY=($( compgen -W 'StaticGray GrayScale StaticColor \
                PseudoColor TrueColor DirectColor defaut visualid' -- "$cur" ));
            return 0
        ;;
    esac
}
__get_cword3 () 
{ 
    if [[ "${#COMP_WORDS[COMP_CWORD]}" -eq 0 ]] || [[ "$COMP_POINT" == "${#COMP_LINE}" ]]; then
        printf "%s" "${COMP_WORDS[COMP_CWORD]}";
    else
        local i;
        local cur="$COMP_LINE";
        local index="$COMP_POINT";
        for ((i = 0; i <= COMP_CWORD; ++i ))
        do
            while [[ "${#cur}" -ge ${#COMP_WORDS[i]} && "${cur:0:${#COMP_WORDS[i]}}" != "${COMP_WORDS[i]}" ]]; do
                cur="${cur:1}";
                index="$(( index - 1 ))";
            done;
            if [[ "$i" -lt "$COMP_CWORD" ]]; then
                local old_size="${#cur}";
                cur="${cur#${COMP_WORDS[i]}}";
                local new_size="${#cur}";
                index="$(( index - old_size + new_size ))";
            fi;
        done;
        if [[ "${COMP_WORDS[COMP_CWORD]:0:${#cur}}" != "$cur" ]]; then
            printf "%s" "${COMP_WORDS[COMP_CWORD]}";
        else
            printf "%s" "${cur:0:$index}";
        fi;
    fi
}
__get_cword4 () 
{ 
    local i;
    local LC_CTYPE=C;
    local WORDBREAKS=$COMP_WORDBREAKS;
    WORDBREAKS=${WORDBREAKS//\"/};
    WORDBREAKS=${WORDBREAKS//\'/};
    if [ -n "$1" ]; then
        for ((i=0; i<${#1}; ++i ))
        do
            local char=${1:$i:1};
            WORDBREAKS=${WORDBREAKS//$char/};
        done;
    fi;
    local cur=${COMP_LINE:0:$COMP_POINT};
    local tmp=$cur;
    local word_start=`expr "$tmp" : '.*['"$WORDBREAKS"']'`;
    while [ "$word_start" -ge 2 ]; do
        local char=${cur:$(( $word_start - 2 )):1};
        if [ "$char" != "\\" ]; then
            break;
        fi;
        tmp=${COMP_LINE:0:$(( $word_start - 2 ))};
        word_start=`expr "$tmp" : '.*['"$WORDBREAKS"']'`;
    done;
    cur=${cur:$word_start};
    printf "%s" "$cur"
}
__git_aliased_command () 
{ 
    local word cmdline=$(git --git-dir="$(__gitdir)" 		config --get "alias.$1");
    for word in $cmdline;
    do
        case "$word" in 
            \!gitk | gitk)
                echo "gitk";
                return
            ;;
            \!*)
                : shell command alias
            ;;
            -*)
                : option
            ;;
            *=*)
                : setting env
            ;;
            git)
                : git itself
            ;;
            *)
                echo "$word";
                return
            ;;
        esac;
    done
}
__git_aliases () 
{ 
    local i IFS='
';
    for i in $(git --git-dir="$(__gitdir)" config --get-regexp "alias\..*" 2>/dev/null);
    do
        case "$i" in 
            alias.*)
                i="${i#alias.}";
                echo "${i/ */}"
            ;;
        esac;
    done
}
__git_commands () 
{ 
    if test -n "${GIT_TESTING_COMMAND_COMPLETION:-}"; then
        printf "%s" "${GIT_TESTING_COMMAND_COMPLETION}";
    else
        git help -a | egrep --color=auto '^  [a-zA-Z0-9]';
    fi
}
__git_complete () 
{ 
    local wrapper="__git_wrap${2}";
    eval "$wrapper () { __git_func_wrap $2 ; }";
    complete -o bashdefault -o default -o nospace -F $wrapper $1 2> /dev/null || complete -o default -o nospace -F $wrapper $1
}
__git_complete_file () 
{ 
    __git_complete_revlist_file
}
__git_complete_index_file () 
{ 
    local pfx="" cur_="$cur";
    case "$cur_" in 
        ?*/*)
            pfx="${cur_%/*}";
            cur_="${cur_##*/}";
            pfx="${pfx}/"
        ;;
    esac;
    __gitcomp_file "$(__git_index_files "$1" "$pfx")" "$pfx" "$cur_"
}
__git_complete_remote_or_refspec () 
{ 
    local cur_="$cur" cmd="${words[1]}";
    local i c=2 remote="" pfx="" lhs=1 no_complete_refspec=0;
    if [ "$cmd" = "remote" ]; then
        ((c++));
    fi;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in 
            --mirror)
                [ "$cmd" = "push" ] && no_complete_refspec=1
            ;;
            --all)
                case "$cmd" in 
                    push)
                        no_complete_refspec=1
                    ;;
                    fetch)
                        return
                    ;;
                    *)

                    ;;
                esac
            ;;
            -*)

            ;;
            *)
                remote="$i";
                break
            ;;
        esac;
        ((c++));
    done;
    if [ -z "$remote" ]; then
        __gitcomp_nl "$(__git_remotes)";
        return;
    fi;
    if [ $no_complete_refspec = 1 ]; then
        return;
    fi;
    [ "$remote" = "." ] && remote=;
    case "$cur_" in 
        *:*)
            case "$COMP_WORDBREAKS" in 
                *:*)
                    : great
                ;;
                *)
                    pfx="${cur_%%:*}:"
                ;;
            esac;
            cur_="${cur_#*:}";
            lhs=0
        ;;
        +*)
            pfx="+";
            cur_="${cur_#+}"
        ;;
    esac;
    case "$cmd" in 
        fetch)
            if [ $lhs = 1 ]; then
                __gitcomp_nl "$(__git_refs2 "$remote")" "$pfx" "$cur_";
            else
                __gitcomp_nl "$(__git_refs)" "$pfx" "$cur_";
            fi
        ;;
        pull | remote)
            if [ $lhs = 1 ]; then
                __gitcomp_nl "$(__git_refs "$remote")" "$pfx" "$cur_";
            else
                __gitcomp_nl "$(__git_refs)" "$pfx" "$cur_";
            fi
        ;;
        push)
            if [ $lhs = 1 ]; then
                __gitcomp_nl "$(__git_refs)" "$pfx" "$cur_";
            else
                __gitcomp_nl "$(__git_refs "$remote")" "$pfx" "$cur_";
            fi
        ;;
    esac
}
__git_complete_revlist () 
{ 
    __git_complete_revlist_file
}
__git_complete_revlist_file () 
{ 
    local pfx ls ref cur_="$cur";
    case "$cur_" in 
        *..?*:*)
            return
        ;;
        ?*:*)
            ref="${cur_%%:*}";
            cur_="${cur_#*:}";
            case "$cur_" in 
                ?*/*)
                    pfx="${cur_%/*}";
                    cur_="${cur_##*/}";
                    ls="$ref:$pfx";
                    pfx="$pfx/"
                ;;
                *)
                    ls="$ref"
                ;;
            esac;
            case "$COMP_WORDBREAKS" in 
                *:*)
                    : great
                ;;
                *)
                    pfx="$ref:$pfx"
                ;;
            esac;
            __gitcomp_nl "$(git --git-dir="$(__gitdir)" ls-tree "$ls" 2>/dev/null 				| sed '/^100... blob /{
				           s,^.*	,,
				           s,$, ,
				       }
				       /^120000 blob /{
				           s,^.*	,,
				           s,$, ,
				       }
				       /^040000 tree /{
				           s,^.*	,,
				           s,$,/,
				       }
				       s/^.*	//')" "$pfx" "$cur_" ""
        ;;
        *...*)
            pfx="${cur_%...*}...";
            cur_="${cur_#*...}";
            __gitcomp_nl "$(__git_refs)" "$pfx" "$cur_"
        ;;
        *..*)
            pfx="${cur_%..*}..";
            cur_="${cur_#*..}";
            __gitcomp_nl "$(__git_refs)" "$pfx" "$cur_"
        ;;
        *)
            __gitcomp_nl "$(__git_refs)"
        ;;
    esac
}
__git_complete_strategy () 
{ 
    __git_compute_merge_strategies;
    case "$prev" in 
        -s | --strategy)
            __gitcomp "$__git_merge_strategies";
            return 0
        ;;
    esac;
    case "$cur" in 
        --strategy=*)
            __gitcomp "$__git_merge_strategies" "" "${cur##--strategy=}";
            return 0
        ;;
    esac;
    return 1
}
__git_compute_all_commands () 
{ 
    test -n "$__git_all_commands" || __git_all_commands=$(__git_list_all_commands)
}
__git_compute_merge_strategies () 
{ 
    test -n "$__git_merge_strategies" || __git_merge_strategies=$(__git_list_merge_strategies)
}
__git_compute_porcelain_commands () 
{ 
    __git_compute_all_commands;
    test -n "$__git_porcelain_commands" || __git_porcelain_commands=$(__git_list_porcelain_commands)
}
__git_config_get_set_variables () 
{ 
    local prevword word config_file= c=$cword;
    while [ $c -gt 1 ]; do
        word="${words[c]}";
        case "$word" in 
            --system | --global | --local | --file=*)
                config_file="$word";
                break
            ;;
            -f | --file)
                config_file="$word $prevword";
                break
            ;;
        esac;
        prevword=$word;
        c=$((--c));
    done;
    git --git-dir="$(__gitdir)" config $config_file --list 2> /dev/null | while read -r line; do
        case "$line" in 
            *.*=*)
                echo "${line/=*/}"
            ;;
        esac;
    done
}
__git_count_arguments () 
{ 
    local word i c=0;
    for ((i=1; i < ${#words[@]}; i++))
    do
        word="${words[i]}";
        case "$word" in 
            --)
                ((c = 0))
            ;;
            "$1")
                ((c = 0))
            ;;
            ?*)
                ((c++))
            ;;
        esac;
    done;
    printf "%d" $c
}
__git_find_on_cmdline () 
{ 
    local word subcommand c=1;
    while [ $c -lt $cword ]; do
        word="${words[c]}";
        for subcommand in $1;
        do
            if [ "$subcommand" = "$word" ]; then
                echo "$subcommand";
                return;
            fi;
        done;
        ((c++));
    done
}
__git_func_wrap () 
{ 
    local cur words cword prev;
    _get_comp_words_by_ref -n =: cur words cword prev;
    $1
}
__git_has_doubledash () 
{ 
    local c=1;
    while [ $c -lt $cword ]; do
        if [ "--" = "${words[c]}" ]; then
            return 0;
        fi;
        ((c++));
    done;
    return 1
}
__git_heads () 
{ 
    local dir="$(__gitdir)";
    if [ -d "$dir" ]; then
        git --git-dir="$dir" for-each-ref --format='%(refname:short)' refs/heads;
        return;
    fi
}
__git_index_files () 
{ 
    local dir="$(__gitdir)" root="${2-.}" file;
    if [ -d "$dir" ]; then
        __git_ls_files_helper "$root" "$1" | while read -r file; do
            case "$file" in 
                ?*/*)
                    echo "${file%%/*}"
                ;;
                *)
                    echo "$file"
                ;;
            esac;
        done | sort | uniq;
    fi
}
__git_list_all_commands () 
{ 
    local i IFS=" "'
';
    for i in $(__git_commands);
    do
        case $i in 
            *--*)
                : helper pattern
            ;;
            *)
                echo $i
            ;;
        esac;
    done
}
__git_list_merge_strategies () 
{ 
    git merge -s help 2>&1 | sed -n -e '/[Aa]vailable strategies are: /,/^$/{
		s/\.$//
		s/.*://
		s/^[ 	]*//
		s/[ 	]*$//
		p
	}'
}
__git_list_porcelain_commands () 
{ 
    local i IFS=" "'
';
    __git_compute_all_commands;
    for i in $__git_all_commands;
    do
        case $i in 
            *--*)
                : helper pattern
            ;;
            applymbox)
                : ask gittus
            ;;
            applypatch)
                : ask gittus
            ;;
            archimport)
                : import
            ;;
            cat-file)
                : plumbing
            ;;
            check-attr)
                : plumbing
            ;;
            check-ignore)
                : plumbing
            ;;
            check-mailmap)
                : plumbing
            ;;
            check-ref-format)
                : plumbing
            ;;
            checkout-index)
                : plumbing
            ;;
            commit-tree)
                : plumbing
            ;;
            count-objects)
                : infrequent
            ;;
            credential-cache)
                : credentials helper
            ;;
            credential-store)
                : credentials helper
            ;;
            cvsexportcommit)
                : export
            ;;
            cvsimport)
                : import
            ;;
            cvsserver)
                : daemon
            ;;
            daemon)
                : daemon
            ;;
            diff-files)
                : plumbing
            ;;
            diff-index)
                : plumbing
            ;;
            diff-tree)
                : plumbing
            ;;
            fast-import)
                : import
            ;;
            fast-export)
                : export
            ;;
            fsck-objects)
                : plumbing
            ;;
            fetch-pack)
                : plumbing
            ;;
            fmt-merge-msg)
                : plumbing
            ;;
            for-each-ref)
                : plumbing
            ;;
            hash-object)
                : plumbing
            ;;
            http-*)
                : transport
            ;;
            index-pack)
                : plumbing
            ;;
            init-db)
                : deprecated
            ;;
            local-fetch)
                : plumbing
            ;;
            lost-found)
                : infrequent
            ;;
            ls-files)
                : plumbing
            ;;
            ls-remote)
                : plumbing
            ;;
            ls-tree)
                : plumbing
            ;;
            mailinfo)
                : plumbing
            ;;
            mailsplit)
                : plumbing
            ;;
            merge-*)
                : plumbing
            ;;
            mktree)
                : plumbing
            ;;
            mktag)
                : plumbing
            ;;
            pack-objects)
                : plumbing
            ;;
            pack-redundant)
                : plumbing
            ;;
            pack-refs)
                : plumbing
            ;;
            parse-remote)
                : plumbing
            ;;
            patch-id)
                : plumbing
            ;;
            peek-remote)
                : plumbing
            ;;
            prune)
                : plumbing
            ;;
            prune-packed)
                : plumbing
            ;;
            quiltimport)
                : import
            ;;
            read-tree)
                : plumbing
            ;;
            receive-pack)
                : plumbing
            ;;
            remote-*)
                : transport
            ;;
            repo-config)
                : deprecated
            ;;
            rerere)
                : plumbing
            ;;
            rev-list)
                : plumbing
            ;;
            rev-parse)
                : plumbing
            ;;
            runstatus)
                : plumbing
            ;;
            sh-setup)
                : internal
            ;;
            shell)
                : daemon
            ;;
            show-ref)
                : plumbing
            ;;
            send-pack)
                : plumbing
            ;;
            show-index)
                : plumbing
            ;;
            ssh-*)
                : transport
            ;;
            stripspace)
                : plumbing
            ;;
            symbolic-ref)
                : plumbing
            ;;
            tar-tree)
                : deprecated
            ;;
            unpack-file)
                : plumbing
            ;;
            unpack-objects)
                : plumbing
            ;;
            update-index)
                : plumbing
            ;;
            update-ref)
                : plumbing
            ;;
            update-server-info)
                : daemon
            ;;
            upload-archive)
                : plumbing
            ;;
            upload-pack)
                : plumbing
            ;;
            write-tree)
                : plumbing
            ;;
            var)
                : infrequent
            ;;
            verify-pack)
                : infrequent
            ;;
            verify-tag)
                : plumbing
            ;;
            *)
                echo $i
            ;;
        esac;
    done
}
__git_ls_files_helper () 
{ 
    ( test -n "${CDPATH+set}" && unset CDPATH;
    cd "$1";
    if [ "$2" == "--committable" ]; then
        git diff-index --name-only --relative HEAD;
    else
        git ls-files --exclude-standard $2;
    fi ) 2> /dev/null
}
__git_main () 
{ 
    local i c=1 command __git_dir;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in 
            --git-dir=*)
                __git_dir="${i#--git-dir=}"
            ;;
            --git-dir)
                ((c++));
                __git_dir="${words[c]}"
            ;;
            --bare)
                __git_dir="."
            ;;
            --help)
                command="help";
                break
            ;;
            -c | --work-tree | --namespace)
                ((c++))
            ;;
            -*)

            ;;
            *)
                command="$i";
                break
            ;;
        esac;
        ((c++));
    done;
    if [ -z "$command" ]; then
        case "$cur" in 
            --*)
                __gitcomp "
			--paginate
			--no-pager
			--git-dir=
			--bare
			--version
			--exec-path
			--exec-path=
			--html-path
			--man-path
			--info-path
			--work-tree=
			--namespace=
			--no-replace-objects
			--help
			"
            ;;
            *)
                __git_compute_porcelain_commands;
                __gitcomp "$__git_porcelain_commands $(__git_aliases)"
            ;;
        esac;
        return;
    fi;
    local completion_func="_git_${command//-/_}";
    declare -f $completion_func > /dev/null && $completion_func && return;
    local expansion=$(__git_aliased_command "$command");
    if [ -n "$expansion" ]; then
        completion_func="_git_${expansion//-/_}";
        declare -f $completion_func > /dev/null && $completion_func;
    fi
}
__git_match_ctag () 
{ 
    awk "/^${1////\\/}/ { print \$1 }" "$2"
}
__git_pretty_aliases () 
{ 
    local i IFS='
';
    for i in $(git --git-dir="$(__gitdir)" config --get-regexp "pretty\..*" 2>/dev/null);
    do
        case "$i" in 
            pretty.*)
                i="${i#pretty.}";
                echo "${i/ */}"
            ;;
        esac;
    done
}
__git_ps1 () 
{ 
    local pcmode=no;
    local detached=no;
    local ps1pc_start='\u@\h:\w ';
    local ps1pc_end='\$ ';
    local printf_format=' (%s)';
    case "$#" in 
        2 | 3)
            pcmode=yes;
            ps1pc_start="$1";
            ps1pc_end="$2";
            printf_format="${3:-$printf_format}"
        ;;
        0 | 1)
            printf_format="${1:-$printf_format}"
        ;;
        *)
            return
        ;;
    esac;
    local repo_info rev_parse_exit_code;
    repo_info="$(git rev-parse --git-dir --is-inside-git-dir 		--is-bare-repository --is-inside-work-tree 		--short HEAD 2>/dev/null)";
    rev_parse_exit_code="$?";
    if [ -z "$repo_info" ]; then
        if [ $pcmode = yes ]; then
            PS1="$ps1pc_start$ps1pc_end";
        fi;
        return;
    fi;
    local short_sha;
    if [ "$rev_parse_exit_code" = "0" ]; then
        short_sha="${repo_info##*
}";
        repo_info="${repo_info%
*}";
    fi;
    local inside_worktree="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local bare_repo="${repo_info##*
}";
    repo_info="${repo_info%
*}";
    local inside_gitdir="${repo_info##*
}";
    local g="${repo_info%
*}";
    local r="";
    local b="";
    local step="";
    local total="";
    if [ -d "$g/rebase-merge" ]; then
        read b 2> /dev/null < "$g/rebase-merge/head-name";
        read step 2> /dev/null < "$g/rebase-merge/msgnum";
        read total 2> /dev/null < "$g/rebase-merge/end";
        if [ -f "$g/rebase-merge/interactive" ]; then
            r="|REBASE-i";
        else
            r="|REBASE-m";
        fi;
    else
        if [ -d "$g/rebase-apply" ]; then
            read step 2> /dev/null < "$g/rebase-apply/next";
            read total 2> /dev/null < "$g/rebase-apply/last";
            if [ -f "$g/rebase-apply/rebasing" ]; then
                read b 2> /dev/null < "$g/rebase-apply/head-name";
                r="|REBASE";
            else
                if [ -f "$g/rebase-apply/applying" ]; then
                    r="|AM";
                else
                    r="|AM/REBASE";
                fi;
            fi;
        else
            if [ -f "$g/MERGE_HEAD" ]; then
                r="|MERGING";
            else
                if [ -f "$g/CHERRY_PICK_HEAD" ]; then
                    r="|CHERRY-PICKING";
                else
                    if [ -f "$g/REVERT_HEAD" ]; then
                        r="|REVERTING";
                    else
                        if [ -f "$g/BISECT_LOG" ]; then
                            r="|BISECTING";
                        fi;
                    fi;
                fi;
            fi;
        fi;
        if [ -n "$b" ]; then
            :;
        else
            if [ -h "$g/HEAD" ]; then
                b="$(git symbolic-ref HEAD 2>/dev/null)";
            else
                local head="";
                if ! read head 2> /dev/null < "$g/HEAD"; then
                    if [ $pcmode = yes ]; then
                        PS1="$ps1pc_start$ps1pc_end";
                    fi;
                    return;
                fi;
                b="${head#ref: }";
                if [ "$head" = "$b" ]; then
                    detached=yes;
                    b="$(
				case "${GIT_PS1_DESCRIBE_STYLE-}" in
				(contains)
					git describe --contains HEAD ;;
				(branch)
					git describe --contains --all HEAD ;;
				(describe)
					git describe HEAD ;;
				(* | default)
					git describe --tags --exact-match HEAD ;;
				esac 2>/dev/null)" || b="$short_sha...";
                    b="($b)";
                fi;
            fi;
        fi;
    fi;
    if [ -n "$step" ] && [ -n "$total" ]; then
        r="$r $step/$total";
    fi;
    local w="";
    local i="";
    local s="";
    local u="";
    local c="";
    local p="";
    if [ "true" = "$inside_gitdir" ]; then
        if [ "true" = "$bare_repo" ]; then
            c="BARE:";
        else
            b="GIT_DIR!";
        fi;
    else
        if [ "true" = "$inside_worktree" ]; then
            if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && [ "$(git config --bool bash.showDirtyState)" != "false" ]; then
                git diff --no-ext-diff --quiet --exit-code || w="*";
                if [ -n "$short_sha" ]; then
                    git diff-index --cached --quiet HEAD -- || i="+";
                else
                    i="#";
                fi;
            fi;
            if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && [ -r "$g/refs/stash" ]; then
                s="$";
            fi;
            if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && git ls-files --others --exclude-standard --error-unmatch -- '*' > /dev/null 2> /dev/null; then
                u="%${ZSH_VERSION+%}";
            fi;
            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream;
            fi;
        fi;
    fi;
    local z="${GIT_PS1_STATESEPARATOR-" "}";
    if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then
        __git_ps1_colorize_gitstring;
    fi;
    local f="$w$i$s$u";
    local gitstring="$c${b##refs/heads/}${f:+$z$f}$r$p";
    if [ $pcmode = yes ]; then
        if [ "${__git_printf_supports_v-}" != yes ]; then
            gitstring=$(printf -- "$printf_format" "$gitstring");
        else
            printf -v gitstring -- "$printf_format" "$gitstring";
        fi;
        PS1="$ps1pc_start$gitstring$ps1pc_end";
    else
        printf -- "$printf_format" "$gitstring";
    fi
}
__git_ps1_colorize_gitstring () 
{ 
    if [[ -n ${ZSH_VERSION-} ]]; then
        local c_red='%F{red}';
        local c_green='%F{green}';
        local c_lblue='%F{blue}';
        local c_clear='%f';
    else
        local c_red='\[\e[31m\]';
        local c_green='\[\e[32m\]';
        local c_lblue='\[\e[1;34m\]';
        local c_clear='\[\e[0m\]';
    fi;
    local bad_color=$c_red;
    local ok_color=$c_green;
    local flags_color="$c_lblue";
    local branch_color="";
    if [ $detached = no ]; then
        branch_color="$ok_color";
    else
        branch_color="$bad_color";
    fi;
    c="$branch_color$c";
    z="$c_clear$z";
    if [ "$w" = "*" ]; then
        w="$bad_color$w";
    fi;
    if [ -n "$i" ]; then
        i="$ok_color$i";
    fi;
    if [ -n "$s" ]; then
        s="$flags_color$s";
    fi;
    if [ -n "$u" ]; then
        u="$bad_color$u";
    fi;
    r="$c_clear$r"
}
__git_ps1_show_upstream () 
{ 
    local key value;
    local svn_remote svn_url_pattern count n;
    local upstream=git legacy="" verbose="";
    svn_remote=();
    local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')";
    while read -r key value; do
        case "$key" in 
            bash.showupstream)
                GIT_PS1_SHOWUPSTREAM="$value";
                if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then
                    p="";
                    return;
                fi
            ;;
            svn-remote.*.url)
                svn_remote[$((${#svn_remote[@]} + 1))]="$value";
                svn_url_pattern+="\\|$value";
                upstream=svn+git
            ;;
        esac;
    done <<< "$output";
    for option in ${GIT_PS1_SHOWUPSTREAM};
    do
        case "$option" in 
            git | svn)
                upstream="$option"
            ;;
            verbose)
                verbose=1
            ;;
            legacy)
                legacy=1
            ;;
        esac;
    done;
    case "$upstream" in 
        git)
            upstream="@{upstream}"
        ;;
        svn*)
            local -a svn_upstream;
            svn_upstream=($(git log --first-parent -1 					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null));
            if [[ 0 -ne ${#svn_upstream[@]} ]]; then
                svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]};
                svn_upstream=${svn_upstream%@*};
                local n_stop="${#svn_remote[@]}";
                for ((n=1; n <= n_stop; n++))
                do
                    svn_upstream=${svn_upstream#${svn_remote[$n]}};
                done;
                if [[ -z "$svn_upstream" ]]; then
                    upstream=${GIT_SVN_ID:-git-svn};
                else
                    upstream=${svn_upstream#/};
                fi;
            else
                if [[ "svn+git" = "$upstream" ]]; then
                    upstream="@{upstream}";
                fi;
            fi
        ;;
    esac;
    if [[ -z "$legacy" ]]; then
        count="$(git rev-list --count --left-right 				"$upstream"...HEAD 2>/dev/null)";
    else
        local commits;
        if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; then
            local commit behind=0 ahead=0;
            for commit in $commits;
            do
                case "$commit" in 
                    "<"*)
                        ((behind++))
                    ;;
                    *)
                        ((ahead++))
                    ;;
                esac;
            done;
            count="$behind	$ahead";
        else
            count="";
        fi;
    fi;
    if [[ -z "$verbose" ]]; then
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p="="
            ;;
            "0	"*)
                p=">"
            ;;
            *"	0")
                p="<"
            ;;
            *)
                p="<>"
            ;;
        esac;
    else
        case "$count" in 
            "")
                p=""
            ;;
            "0	0")
                p=" u="
            ;;
            "0	"*)
                p=" u+${count#0	}"
            ;;
            *"	0")
                p=" u-${count%	0}"
            ;;
            *)
                p=" u+${count#*	}-${count%	*}"
            ;;
        esac;
    fi
}
__git_reassemble_comp_words_by_ref () 
{ 
    local exclude i j first;
    exclude="${1//[^$COMP_WORDBREAKS]}";
    cword_=$COMP_CWORD;
    if [ -z "$exclude" ]; then
        words_=("${COMP_WORDS[@]}");
        return;
    fi;
    for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
    do
        first=t;
        while [ $i -gt 0 ] && [ -n "${COMP_WORDS[$i]}" ] && [ "${COMP_WORDS[$i]//[^$exclude]}" = "${COMP_WORDS[$i]}" ]; do
            if [ $j -ge 2 ] && [ -n "$first" ]; then
                ((j--));
            fi;
            first=;
            words_[$j]=${words_[j]}${COMP_WORDS[i]};
            if [ $i = $COMP_CWORD ]; then
                cword_=$j;
            fi;
            if (($i < ${#COMP_WORDS[@]} - 1)); then
                ((i++));
            else
                return;
            fi;
        done;
        words_[$j]=${words_[j]}${COMP_WORDS[i]};
        if [ $i = $COMP_CWORD ]; then
            cword_=$j;
        fi;
    done
}
__git_refs () 
{ 
    local i hash dir="$(__gitdir "${1-}")" track="${2-}";
    local format refs;
    if [ -d "$dir" ]; then
        case "$cur" in 
            refs | refs/*)
                format="refname";
                refs="${cur%/*}";
                track=""
            ;;
            *)
                for i in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD;
                do
                    if [ -e "$dir/$i" ]; then
                        echo $i;
                    fi;
                done;
                format="refname:short";
                refs="refs/tags refs/heads refs/remotes"
            ;;
        esac;
        git --git-dir="$dir" for-each-ref --format="%($format)" $refs;
        if [ -n "$track" ]; then
            local ref entry;
            git --git-dir="$dir" for-each-ref --shell --format="ref=%(refname:short)" "refs/remotes/" | while read -r entry; do
                eval "$entry";
                ref="${ref#*/}";
                if [[ "$ref" == "$cur"* ]]; then
                    echo "$ref";
                fi;
            done | sort | uniq -u;
        fi;
        return;
    fi;
    case "$cur" in 
        refs | refs/*)
            git ls-remote "$dir" "$cur*" 2> /dev/null | while read -r hash i; do
                case "$i" in 
                    *^{})

                    ;;
                    *)
                        echo "$i"
                    ;;
                esac;
            done
        ;;
        *)
            echo "HEAD";
            git for-each-ref --format="%(refname:short)" -- "refs/remotes/$dir/" | sed -e "s#^$dir/##"
        ;;
    esac
}
__git_refs2 () 
{ 
    local i;
    for i in $(__git_refs "$1");
    do
        echo "$i:$i";
    done
}
__git_refs_remotes () 
{ 
    local i hash;
    git ls-remote "$1" 'refs/heads/*' 2> /dev/null | while read -r hash i; do
        echo "$i:refs/remotes/$1/${i#refs/heads/}";
    done
}
__git_remotes () 
{ 
    local i IFS='
' d="$(__gitdir)";
    test -d "$d/remotes" && ls --color=auto -1 "$d/remotes";
    for i in $(git --git-dir="$d" config --get-regexp 'remote\..*\.url' 2>/dev/null);
    do
        i="${i#remote.}";
        echo "${i/.url*/}";
    done
}
__git_tags () 
{ 
    local dir="$(__gitdir)";
    if [ -d "$dir" ]; then
        git --git-dir="$dir" for-each-ref --format='%(refname:short)' refs/tags;
        return;
    fi
}
__git_wrap__git_main () 
{ 
    __git_func_wrap __git_main
}
__git_wrap__gitk_main () 
{ 
    __git_func_wrap __gitk_main
}
__gitcomp () 
{ 
    local cur_="${3-$cur}";
    case "$cur_" in 
        --*=)

        ;;
        *)
            local c i=0 IFS=' 	
';
            for c in $1;
            do
                c="$c${4-}";
                if [[ $c == "$cur_"* ]]; then
                    case $c in 
                        --*=* | *.)

                        ;;
                        *)
                            c="$c "
                        ;;
                    esac;
                    COMPREPLY[i++]="${2-}$c";
                fi;
            done
        ;;
    esac
}
__gitcomp_file () 
{ 
    local IFS='
';
    __gitcompadd "$1" "${2-}" "${3-$cur}" "";
    compopt -o filenames +o nospace 2> /dev/null || compgen -f /non-existing-dir/ > /dev/null
}
__gitcomp_nl () 
{ 
    local IFS='
';
    __gitcompadd "$1" "${2-}" "${3-$cur}" "${4- }"
}
__gitcompadd () 
{ 
    local i=0;
    for x in $1;
    do
        if [[ "$x" == "$3"* ]]; then
            COMPREPLY[i++]="$2$x$4";
        fi;
    done
}
__gitdir () 
{ 
    if [ -z "${1-}" ]; then
        if [ -n "${__git_dir-}" ]; then
            echo "$__git_dir";
        else
            if [ -n "${GIT_DIR-}" ]; then
                test -d "${GIT_DIR-}" || return 1;
                echo "$GIT_DIR";
            else
                if [ -d .git ]; then
                    echo .git;
                else
                    git rev-parse --git-dir 2> /dev/null;
                fi;
            fi;
        fi;
    else
        if [ -d "$1/.git" ]; then
            echo "$1/.git";
        else
            echo "$1";
        fi;
    fi
}
__gitk_main () 
{ 
    __git_has_doubledash && return;
    local g="$(__gitdir)";
    local merge="";
    if [ -f "$g/MERGE_HEAD" ]; then
        merge="--merge";
    fi;
    case "$cur" in 
        --*)
            __gitcomp "
			$__git_log_common_options
			$__git_log_gitk_options
			$merge
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
__gvfs_multiple_uris () 
{ 
    local IFS='
';
    local cur="${COMP_WORDS[COMP_CWORD]}";
    COMPREPLY=($(compgen -W '$(gvfs-ls --show-completions "$cur")' -- ""));
    case "$cur" in 
        *:*)
            case "$COMP_WORDBREAKS" in 
                *:*)
                    colon_prefix=$(echo $cur | sed 's/:[^:]*$/:/' );
                    COMPREPLY=${COMPREPLY##${colon_prefix}}
                ;;
            esac
        ;;
    esac
}
_alias () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    case "$COMP_LINE" in 
        *[^=])
            COMPREPLY=($( compgen -A alias -- "$cur" ))
        ;;
        *=)
            COMPREPLY=("$( alias ${cur%=} 2>/dev/null | sed                 -e 's|^alias '"$cur"'\(.*\)$|\1|' )")
        ;;
    esac
}
_animate () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-alpha -authenticate -backdrop \
            -background -bordercolor -borderwidth -channel \
            -coalesce -colormap -colors -colorspace -crop -debug \
            -decipher -define -delay -density -depth -display \
            -dispose -dither -extract -filter -flatten -font \
            -foreground -format -gamma -geometry -help \
            -iconGeometry -iconic -identify -immutable -interlace \
            -interpolate -limit -list -log -loop -map -mattecolor \
            -mattecolor -monitor -monochrome -name -page -pause \
            -quantize -quiet -regard-warnings -remote -repage \
            -resample -resize -respect-parenthesis -rotate \
            -sampling-factor -scenes -seed -set -shared-memory \
            -size -strip -title -transparent-color -treedepth \
            -trim -verbose -version -virtual-pixel -visual \
            -window' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+debug +dither +gamma +map +matte'             -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_apport-bug () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help -f --file-bug -u --update-bug -s --symptom -p \
                 --package -P --pid -c --crash-file --save -v --version';
    case "$prev" in 
        ubuntu-bug | apport-bug)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        -f | --file-bug)
            param="-P --pid -p --package -s --symptom";
            COMPREPLY=($( compgen -W "$param $(_apport_symptoms)" -- $cur))
        ;;
        -p | --package)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ))
        ;;
        -u | --update-bug)
            param="-p --package";
            COMPREPLY=($( compgen -W "$param" -- $cur))
        ;;
        -s | --symptom)
            COMPREPLY=($( compgen -W "$(_apport_symptoms)" -- $cur))
        ;;
        -P | --pid)
            COMPREPLY=($( compgen -W '$( command ps axo pid | sed 1d )' -- $cur ))
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -c | --crash-file)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
        -h | --help | -v | --version)
            return 0
        ;;
        *)
            if [ "${COMP_WORDS[COMP_CWORD-2]}" == "--save" ]; then
                case "$cur" in 
                    -*)
                        COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                    ;;
                    *)
                        _apport_parameterless
                    ;;
                esac;
            else
                param="--save";
                COMPREPLY=($( compgen -W "$param" -- $cur));
            fi
        ;;
    esac
}
_apport-cli () 
{ 
    local cur dashoptions prev param;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-h --help -f --file-bug -u --update-bug -s --symptom \
                 -c --crash-file --save -v --version';
    case "$prev" in 
        apport-cli)
            case "$cur" in 
                -*)
                    COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                ;;
                *)
                    _apport_parameterless
                ;;
            esac
        ;;
        -f | --file-bug)
            param="-P --pid -p --package -s --symptom";
            COMPREPLY=($( compgen -W "$param $(_apport_symptoms)" -- $cur))
        ;;
        -s | --symptom)
            COMPREPLY=($( compgen -W "$(_apport_symptoms)" -- $cur))
        ;;
        --save)
            COMPREPLY=($( compgen -o default -G "$cur*" ))
        ;;
        -c | --crash-file)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
        -h | --help | -v | --version)
            return 0
        ;;
        *)
            if [ "${COMP_WORDS[COMP_CWORD-2]}" == "--save" ]; then
                case "$cur" in 
                    -*)
                        COMPREPLY=($( compgen -W "$dashoptions" -- $cur ))
                    ;;
                    *)
                        _apport_parameterless
                    ;;
                esac;
            else
                param="--save";
                COMPREPLY=($( compgen -W "$param" -- $cur));
            fi
        ;;
    esac
}
_apport-collect () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-collect)
            COMPREPLY=($( compgen -W "-p --package" -- $cur))
        ;;
        -p | --package)
            COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ))
        ;;
    esac
}
_apport-unpack () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        apport-unpack)
            COMPREPLY=($( compgen -G "${cur}*.apport"
                       compgen -G "${cur}*.crash" ))
        ;;
    esac
}
_apport_parameterless () 
{ 
    local param;
    param="$dashoptions            $( apt-cache pkgnames $cur 2> /dev/null )            $( command ps axo pid | sed 1d )            $( _apport_symptoms )            $( compgen -G "${cur}*.apport"
              compgen -G "${cur}*.crash" )";
    COMPREPLY=($( compgen -W "$param" -- $cur))
}
_apport_symptoms () 
{ 
    local syms;
    for FILE in $(ls /usr/share/apport/symptoms);
    do
        syms="$syms ${FILE%.py}";
    done;
    echo $syms
}
_apt_cache () 
{ 
    local cur prev special i;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ "$cur" != show ]; then
        for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
        do
            if [[ ${COMP_WORDS[i]} == @(add|depends|dotty|madison|policy|rdepends|show?(pkg|src|)) ]]; then
                special=${COMP_WORDS[i]};
            fi;
        done;
    fi;
    if [ -n "$special" ]; then
        case $special in 
            add)
                _filedir;
                return 0
            ;;
            showsrc)
                COMPREPLY=($( apt-cache dumpavail |                             grep "^Source: $cur" | sort |                             uniq | cut -f2 -d" " ));
                return 0
            ;;
            *)
                COMPREPLY=($( apt-cache --no-generate pkgnames "$cur" 2> /dev/null ));
                return 0
            ;;
        esac;
    fi;
    case "$prev" in 
        -@(c|p|s|-config-file|-@(pkg|src)-cache))
            _filedir;
            return 0
        ;;
        search)
            if [[ "$cur" != -* ]]; then
                return 0;
            fi
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-h -v -p -s -q -i -f -a -g -c \
                -o --help --version --pkg-cache --src-cache \
                --quiet --important --full --all-versions \
                --no-all-versions --generate --no-generate \
                --names-only --all-names --recurse \
                --config-file --option --installed' -- "$cur" ));
    else
        COMPREPLY=($( compgen -W 'add gencaches show showpkg showsrc \
                stats dump dumpavail unmet search search \
                depends rdepends pkgnames dotty xvcg \
                policy madison' -- "$cur" ));
    fi;
    return 0
}
_apt_get () 
{ 
    local cur prev special i;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == @(install|remove|autoremove|purge|source|build-dep) ]]; then
            special=${COMP_WORDS[i]};
        fi;
    done;
    if [ -n "$special" ]; then
        case $special in 
            remove | autoremove | purge)
                if [ -f /etc/debian_version ]; then
                    COMPREPLY=($( _comp_dpkg_installed_packages $cur ));
                else
                    _rpm_installed_packages;
                fi;
                return 0
            ;;
            *)
                COMPREPLY=($( apt-cache --no-generate pkgnames "$cur"                     2> /dev/null ));
                return 0
            ;;
        esac;
    fi;
    case "$prev" in 
        -@(c|-config-file))
            _filedir;
            return 0
        ;;
        -@(t|-target-release|-default-release))
            COMPREPLY=($( apt-cache policy |                  grep "release.o=Debian,a=$cur" |                  sed -e "s/.*a=\(\w*\).*/\1/" | uniq 2> /dev/null));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-d -f -h -v -m -q -s -y -u -t -b -c -o \
            --download-only --fix-broken --help --version --ignore-missing \
            --fix-missing --no-download --quiet --simulate --just-print \
            --dry-run --recon --no-act --yes --assume-yes --show-upgraded \
            --only-source --compile --build --ignore-hold --target-release \
            --no-upgrade --force-yes --print-uris --purge --reinstall \
            --list-cleanup --default-release --trivial-only --no-remove \
            --diff-only --no-install-recommends --tar-only --config-file \
            --option --auto-remove' -- "$cur" ));
    else
        COMPREPLY=($( compgen -W 'update upgrade dselect-upgrade \
            dist-upgrade install remove purge source build-dep \
            check clean autoclean autoremove' -- "$cur" ));
    fi;
    return 0
}
_aptitude () 
{ 
    local cur dashoptions prev special i;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    dashoptions='-S -u -i -h --help --version -s --simulate -d \
        --download-only -P --prompt -y --assume-yes -F \
        --display-format -O --sort -w --width -f -r -g \
        --with-recommends -R -G --without-recommends -t \
        --target-release -V --show-versions -D --show-deps\
        -Z -v --verbose --purge-unused --schedule-only';
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == @(install|reinstall|hold|unhold|markauto|unmarkauto|dist-upgrade|full-upgrade|download|show|forbid-version|purge|remove|changelog|why|why-not|keep|keep-all|build-dep) ]]; then
            special=${COMP_WORDS[i]};
        fi;
        [[ ${COMP_WORDS[i]} == '-u' ]] && dashoptions=${dashoptions/-i};
        [[ ${COMP_WORDS[i]} == '-i' ]] && dashoptions=${dashoptions/-u};
    done;
    if [[ -n "$special" ]]; then
        case $special in 
            @(install|hold|markauto|unmarkauto|dist-upgrade|full-upgrade|download|show|changelog|why|why-not|build-dep))
                COMPREPLY=($( apt-cache pkgnames $cur 2> /dev/null ));
                return 0
            ;;
            @(purge|remove|reinstall|forbid-version))
                COMPREPLY=($( _comp_dpkg_installed_packages "$cur" ));
                return 0
            ;;
            unhold)
                COMPREPLY=($( _comp_dpkg_hold_packages "$cur" ));
                return 0
            ;;
        esac;
    fi;
    case $prev in 
        @(autoclean|clean|forget-new|search|upgrade|safe-upgrade|update|keep-all))
            return 0
        ;;
        -S)
            _filedir;
            return 0
        ;;
        -@(t|-target-release|-default-release))
            COMPREPLY=($( apt-cache policy |                 grep "release.o=Debian,a=$cur" |                 sed -e "s/.*a=\(\w*\).*/\1/" | uniq 2> /dev/null ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$dashoptions" -- "$cur" ));
    else
        COMPREPLY=($( compgen -W 'update upgrade safe-upgrade forget-new \
            clean autoclean install reinstall remove \
            hold unhold purge markauto unmarkauto why why-not \
            dist-upgrade full-upgrade download search show \
            forbid-version changelog keep-all build-dep' -- "$cur" ));
    fi;
    return 0
}
_arch () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -@(w|g|d|--welcome-msg|-goodbye-msg|-digest))
            COMPREPLY=($( compgen -W 'y n' -- "$cur"));
            return 0
        ;;
        -@(d|-file))
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--wipe -s --start -e --end -q --quiet -h \
            --help' -- "$cur" ));
    else
        args=$COMP_CWORD;
        for ((i=1; i < COMP_CWORD; i++ ))
        do
            if [[ "${COMP_WORDS[i]}" == -* ]]; then
                args=$(($args-1));
            fi;
        done;
        case $args in 
            1)
                _mailman_lists
            ;;
            2)
                _filedir
            ;;
        esac;
    fi
}
_aspell () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -c | -p | check | --@(conf|personal|repl|per-conf))
            _filedir;
            return 0
        ;;
        --@(conf-dir|data-dir|dict-dir|home-dir|local-data-dir|prefix))
            _filedir -d;
            return 0
        ;;
        dump | create | merge)
            COMPREPLY=($( compgen -W 'master personal repl' -- "$cur" ));
            return 0
        ;;
        --mode)
            COMPREPLY=($( compgen -W 'none url email sgml tex' -- "$cur" ));
            return 0
        ;;
        --sug-mode)
            COMPREPLY=($( compgen -W 'ultra fast normal bad-speller' -- "$cur" ));
            return 0
        ;;
        --keymapping)
            COMPREPLY=($( compgen -W 'aspell ispell' -- "$cur" ));
            return 0
        ;;
        -d | --master)
            _aspell_dictionary;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--conf --conf-dir --data-dir --dict-dir \
            --encoding --add-filter --rem-filter --mode -e \
            -H -t --add-extra-dicts --rem-extra-dicts \
            --home-dir -W --ignore --ignore-accents \
            --dont-ignore-accents --ignore-case --dont-ignore-case \
            --ignore-repl --dont-ignore-repl --jargon --keyboard \
            --lang --language-tag --local-data-dir -d --master \
            --module --add-module-search-order \
            --rem-module-search-order --per-conf -p --personal \
            --prefix --repl -C -B --run-together --dont-run-together \
            --run-together-limit --run-together-min --save-repl \
            --dont-save-repl --set-prefix --dont-set-prefix --size \
            --spelling --strip-accents --dont-strip-accents \
            --sug-mode --add-word-list-path --rem-word-list-path \
            -b -x --backup -b|-x --dont-backup --reverse --dont-reverse \
            --time --dont-time --keymapping --add-email-quote \
            --rem-email-quote --email-margin --add-tex-command \
            --rem-tex-command --tex-check-comments \
            --dont-tex-check-comments --add-tex-extension \
            --rem-tex-extension --add-sgml-check --rem-sgml-check \
            --add-sgml-extension --rem-sgml-extension' -- "$cur" ));
    else
        COMPREPLY=($( compgen -W '-? help -c check -a pipe -l list \
            config config soundslike filter -v version dump \
            create merge' -- "$cur" ));
    fi
}
_aspell_dictionary () 
{ 
    local datadir;
    datadir=$( aspell config data-dir 2>/dev/null || echo /usr/lib/aspell );
    COMPREPLY=($( command ls $datadir/*.alias 2>/dev/null ));
    COMPREPLY=(${COMPREPLY[@]%.alias});
    COMPREPLY=(${COMPREPLY[@]#$datadir/});
    COMPREPLY=("${COMPREPLY[@]}" $( aspell dicts 2>/dev/null ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ))
}
_available_interfaces () 
{ 
    local cmd;
    if [ "${1:-}" = -w ]; then
        cmd="iwconfig";
    else
        if [ "${1:-}" = -a ]; then
            cmd="ifconfig";
        else
            cmd="ifconfig -a";
        fi;
    fi;
    COMPREPLY=($( eval $cmd 2>/dev/null |         awk '/^[^[:space:]]/ { print $1 }' ));
    COMPREPLY=($( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ))
}
_avctrl () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-h --help -q --quiet' -- "$cur" ));
    else
        _count_args;
        if [ $args -eq 1 ]; then
            COMPREPLY=($( compgen -W 'discover switch' -- "$cur" ));
        fi;
    fi
}
_bluetooth_adresses () 
{ 
    if [ -n "${COMP_BLUETOOTH_SCAN:-}" ]; then
        COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W "$( hcitool scan |             awk '/^\t/{print $1}' )" -- "$cur" ));
    fi
}
_bluetooth_devices () 
{ 
    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W "$( hcitool dev |         awk '/^\t/{print $1}' )" -- "$cur" ))
}
_bluetooth_packet_types () 
{ 
    COMPREPLY=($( compgen -W 'DM1 DM3 DM5 DH1 DH3 DH5 HV1 HV2 HV3'         -- "$cur" ))
}
_bluetooth_services () 
{ 
    COMPREPLY=($( compgen -W 'DID SP DUN LAN FAX OPUSH FTP HS HF HFAG \
        SAP NAP GN PANU HCRP HID CIP A2SRC A2SNK AVRCT AVRTG UDIUE \
        UDITE SYNCML' -- "$cur" ))
}
_bzip2 () 
{ 
    local cur prev xspec;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-c -d -f -h -k -L -q -s \
            -t -v -V -z -1 -2 -3 -4 -5 -6 -7 -8 -9 \
            --help --decompress --compress --keep --force \
            --test --stdout --quiet --verbose --license \
            --version --small --fast --best' -- "$cur" ));
        return 0;
    fi;
    local IFS='	
';
    xspec="*.bz2";
    if [[ "$prev" == --* ]]; then
        [[ "$prev" == --decompress || "$prev" == --list || "$prev" == --test ]] && xspec="!"$xspec;
        [[ "$prev" == --compress ]] && xspec=;
    else
        if [[ "$prev" == -* ]]; then
            [[ "$prev" == -*[dt]* ]] && xspec="!"$xspec;
            [[ "$prev" == -*z* ]] && xspec=;
        fi;
    fi;
    _expand || return 0;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_cancel () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    COMPREPLY=($( compgen -W "$( lpstat | cut -d' ' -f1 )" -- "$cur" ))
}
_cd () 
{ 
    local IFS='	
' cur=`_get_cword` i j k;
    if [[ "$cur" == ?(\\)\$* ]]; then
        COMPREPLY=($( compgen -v -P '$' -- "${cur#?(\\)$}" ));
        return 0;
    fi;
    compgen -f /non-existing-dir/ > /dev/null;
    if [ -z "${CDPATH:-}" ] || [[ "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d;
        return 0;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'	'};
    do
        k="${#COMPREPLY[@]}";
        for j in $( compgen -d $i/$cur );
        do
            if [[ ( -n $mark_symdirs && -h $j || -n $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j="${j}/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]};
        if [ "$i" == "$cur" ] && [[ $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return 0
}
_cdrecord () 
{ 
    local cur prev i generic_options track_options track_mode;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$cur" == *=* ]]; then
        prev=${cur/=*/};
        cur=${cur/*=/};
        case "$prev" in 
            @(text|cue)file)
                _filedir;
                return 0
            ;;
            blank)
                COMPREPLY=($( compgen -W 'help all fast \
                    track unreserve trtail unclose session'                     -- "$cur" ));
                return 0
            ;;
            driveropts)
                COMPREPLY=($( compgen -W 'burnfree noburnfree\
                    varirec= audiomaster forcespeed noforcespeed\
                    speedread nospeedread singlesession \
                    nosinglesession hidecdr nohidecdr tattooinfo\
                    tattoofile=' -- "$cur" ));
                return 0
            ;;
        esac;
    fi;
    generic_options=(-version -v -V -d -silent -s -force -immed -dummy -dao -raw -raw96r -raw96p -raw16 -multi -msinfo -toc -atip -fix -nofix -waiti -load -lock -eject -format -setdropts -checkdrive -prcap -inq -scanbus -reset -abort -overburn -ignsize -useinfo -packet -noclose -text debug= kdebug= kd= minbuf= speed= blank= fs= dev= gracetime= timeout= driver= driveropts= defpregap= pktsize= mcn= textfile= cuefile=);
    track_options=(-audio -swab -data -mode2 -xa -xa1 -xa2 -xamix -cdi -isosize -pad padsize= -nopad -shorttrack -noshorttrack pregap= -preemp -nopreemp -copy -nocopy -scms tcsize= isrc= index=);
    track_mode=0;
    if [ $COMP_CWORD -gt 1 ]; then
        if [ -f "$prev" ]; then
            track_mode=1;
        else
            for ((i=0; i < ${#track_options[@]}; i++ ))
            do
                if [[ "${track_options[i]}" == "$prev" ]]; then
                    track_mode=1;
                    break;
                fi;
            done;
        fi;
    fi;
    _filedir;
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W '${track_options[@]}' -- "$cur" ));
    if [ $track_mode -eq 0 ]; then
        COMPREPLY=("${COMPREPLY[@]}" $( compgen -W '${generic_options[@]}' -- "$cur" ));
    fi
}
_chage () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -d | --lastday | -E | --expiredate | -h | --help | -I | --inactive | -m | --mindays | -M | --maxdays | -W | --warndays)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-d --lastday -E --expiredate \
            -h --help -I --inactive -l --list -m --mindays \
            -M --maxdays -W --warndays' -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -u -- "$cur" ))
}
_chgrp () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    cur=${cur//\\\\/};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    if [[ "$prev" == --reference ]]; then
        _filedir;
        return 0;
    fi;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-c -h -f -R -v --changes \
            --dereference --no-dereference --silent --quiet \
            --reference --recursive --verbose --help --version' -- "$cur" ));
        return 0;
    fi;
    if [ $COMP_CWORD -eq 1 ] && [[ "$cur" != -* ]] || [[ "$prev" == -* ]] && [ -n "$bash205" ]; then
        local IFS='
';
        COMPREPLY=($( compgen -g "$cur" 2>/dev/null ));
    else
        _filedir || return 0;
    fi;
    return 0
}
_chown () 
{ 
    local cur prev split=false;
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        --from)
            _usergroup;
            return 0
        ;;
        --reference)
            _filedir;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-c -h -f -R -v --changes \
            --dereference --no-dereference --from --silent --quiet \
            --reference --recursive --verbose --help --version' -- "$cur" ));
    else
        _count_args;
        case $args in 
            1)
                _usergroup
            ;;
            *)
                _filedir
            ;;
        esac;
    fi
}
_chpasswd () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -c | --crypt)
            COMPREPLY=($( compgen -W 'DES MD5 NONE SHA256 SHA512'                 -- "$cur" ));
            return 0
        ;;
        -s | --sha-rounds)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-c --crypt-method -e --encrypted \
            -h --help -m --md5 -s --sha-rounds' -- "$cur" ));
        return 0;
    fi
}
_chsh () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ "$prev" = "-s" ]; then
        _shells;
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_ciptool () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        -i)
            _bluetooth_devices;
            _bluetooth_adresses;
            return 0
        ;;
    esac;
    _get_command;
    if [ -z $command ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-h --help -i' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W 'show search connect release \
                loopback' -- "$cur" ));
        fi;
    else
        case $command in 
            @(connect|release|loopback))
                _count_args;
                if [ $args -eq 2 ]; then
                    _bluetooth_adresses;
                fi
            ;;
        esac;
    fi
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local cur func cline cspec noglob cmd i char_offset word_offset _COMMAND_FUNC _COMMAND_FUNC_ARGS;
    word_offset=$1;
    local first_word=${COMP_WORDS[$word_offset]};
    for ((i=0; i <= ${#COMP_LINE}; i++ ))
    do
        if [[ "${COMP_LINE:$i:${#first_word}}" == "$first_word" ]]; then
            char_offset=$i;
            break;
        fi;
    done;
    COMP_LINE=${COMP_LINE:$char_offset};
    COMP_POINT=$(( COMP_POINT - $char_offset ));
    for ((i=0; i <= COMP_CWORD - $word_offset; i++ ))
    do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++ ))
    do
        unset COMP_WORDS[i];
    done;
    COMP_CWORD=$(( $COMP_CWORD - $word_offset ));
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ $COMP_CWORD -eq 0 ]]; then
        COMPREPLY=($( compgen -c -- "$cur" ));
    else
        cmd=${COMP_WORDS[0]};
        if complete -p $cmd &>/dev/null; then
            cspec=$( complete -p $cmd );
            if [ "${cspec#* -F }" != "$cspec" ]; then
                func=${cspec#*-F };
                func=${func%% *};
                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}";
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}";
                fi;
                if [ "${cspec#*-o }" != "$cspec" ]; then
                    cspec=${cspec#*-o };
                    cspec=${cspec%% *};
                    if [[ "$cspec" != @(dir|file)names ]]; then
                        COMPREPLY=("${COMPREPLY[@]//\\\\:/:}");
                    fi;
                fi;
            else
                if [ -n "$cspec" ]; then
                    cspec=${cspec#complete};
                    cspec=${cspec%%$cmd};
                    COMPREPLY=($( eval compgen "$cspec" -- "$cur" ));
                fi;
            fi;
        fi;
    fi;
    [ ${#COMPREPLY[@]} -eq 0 ] && _filedir
}
_comp_dpkg_hold_packages () 
{ 
    grep --color=auto -B 2 'hold' /var/lib/dpkg/status | grep --color=auto "Package: $1" | cut -d\  -f2
}
_comp_dpkg_installed_packages () 
{ 
    grep --color=auto -A 1 "Package: $1" /var/lib/dpkg/status | grep --color=auto -B 1 -Ee "ok installed|half-installed|unpacked|             half-configured|config-files" -Ee "^Essential: yes" | grep --color=auto "Package: $1" | cut -d\  -f2
}
_compare () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-alpha -authenticate -channel \
            -colorspace -compress -debug -decipher -define \
            -density -depth -encipher -extract -format -fuzz \
            -help -highlight-color -identify -interlace -limit \
            -list -log -metric -monitor -passphrase -profile \
            -quality -quantize -quiet -regard-warnings \
            -respect-parenthesis -sampling-factor -seed -set \
            -size -transparent-color -type -verbose -version \
            -virtual-pixel' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+debug' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_complete () 
{ 
    local cur prev options;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        -o)
            options="default dirnames filenames";
            [ -n "$bash205b" ] && options="$options nospace";
            [ -n "$bash3" ] && options="$options bashdefault plusdirs";
            COMPREPLY=($( compgen -W "$options" -- "$cur" ));
            return 0
        ;;
        -A)
            COMPREPLY=($( compgen -W 'alias arrayvar binding \
                builtin command directory disabled enabled \
                export file function group helptopic hostname \
                job keyword running service setopt shopt \
                signal stopped user variable' -- "$cur" ));
            return 0
        ;;
        -C)
            COMPREPLY=($( compgen -A command -- "$cur" ));
            return 0
        ;;
        -F)
            COMPREPLY=($( compgen -A function -- "$cur" ));
            return 0
        ;;
        -@(p|r))
            COMPREPLY=($( complete -p | sed -e 's|.* ||' ));
            COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        options="-a -b -c -d -e -f -g -j -k -s -v -u -A -G -W -P -S -X -F -C";
        [ -n "$bash205" ] && options="$options -o";
        COMPREPLY=($( compgen -W "$options" -- "$cur" ));
    else
        COMPREPLY=($( compgen -A command -- "$cur" ));
    fi
}
_composite () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-affine -alpha -authenticate \
            -blend -blue-primary -border -bordercolor -channel \
            -colors -colorspace -comment -compose -compress \
            -debug -decipher -define -density -depth -displace \
            -display -dispose -dissolve -dither -encipher \
            -encoding -endian -extract -filter -font -format \
            -geometry -gravity -green-primary -help -identify \
            -interlace -interpolate -label -limit -list -log \
            -monitor -monochrome -negate -page -profile -quality \
            -quantize -quiet -red-primary -regard-warnings \
            -repage -resize -respect-parenthesis -rotate \
            -sampling-factor -scene -seed -sharpen -shave -size \
            -stegano -stereo -strip -swap -thumbnail -tile \
            -transform -transparent-color -treedepth -type -units \
            -unsharp -verbose -version -virtual-pixel -watermark \
            -white-point -write' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+compress +debug +dither +endian +label \
            +matte +negate +page +write' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_configure () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    [[ "$cur" != -* ]] && return 0;
    if [ -n "$COMP_CONFIGURE_HINTS" ]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             awk '/^  --[A-Za-z]/ { print $1; \
            if ($2 ~ /--[A-Za-z]/) print $2 }' | sed -e 's/[[,].*//g' )"             -- "$cur" ));
    else
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 |             awk '/^  --[A-Za-z]/ { print $1; \
            if ($2 ~ /--[A-Za-z]/) print $2 }' | sed -e 's/[[,=].*//g' )"             -- "$cur" ));
    fi
}
_configured_interfaces () 
{ 
    if [ -f /etc/debian_version ]; then
        COMPREPLY=($( compgen -W "$( sed -ne 's|^iface \([^ ]\+\).*$|\1|p'             /etc/network/interfaces )" -- "$cur" ));
    else
        if [ -f /etc/SuSE-release ]; then
            COMPREPLY=($( compgen -W "$( command ls             /etc/sysconfig/network/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
        else
            if [ -f /etc/pld-release ]; then
                COMPREPLY=($( compgen -W "$( command ls -B             /etc/sysconfig/interfaces |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            else
                COMPREPLY=($( compgen -W "$( command ls             /etc/sysconfig/network-scripts/ifcfg-* |             sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ));
            fi;
        fi;
    fi
}
_conjure () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-debug -help -list -log -monitor -quiet \
            -regard-warnings -seed -verbose -version' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+debug' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_convert () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-adaptive-blur -adaptive-resize \
            -adaptive-sharpen -adjoin -affine -alpha -annotate \
            -antialias -append -attenuate -authenticate \
            -auto-orient -average -background -bench -bias \
            -black-point-compensation -black-threshold \
            -blue-primary -blur -border -bordercolor -caption \
            -channel -charcoal -chop -clip -clip-mask -clip-path \
            -clone -clut -coalesce -colorize -colors -colorspace \
            -combine -comment -compose -composite -compress \
            -contrast -contrast-stretch -convolve -crop -cycle \
            -debug -decipher -deconstruct -define -delay -delete \
            -density -depth -despeckle -display -dispose -distort \
            -dither -draw -edge -emboss -encipher -encoding \
            -endian -enhance -equalize -evaluate -extent -extract \
            -family -fill -filter -flatten -flip -floodfill -flop \
            -font -format -frame -fuzz -fx -gamma -gaussian-blur \
            -geometry -gravity -green-primary -help -identify \
            -implode -insert -intent -interlace -interpolate \
            -label -lat -layers -level -limit -linear-stretch \
            -liquid-rescale -list -log -loop -map -mask \
            -mattecolor -median -modulate -monitor -monochrome \
            -morph -mosaic -motion-blur -negate -noise -normalize \
            -opaque -ordered-dither -orient -page -paint -ping \
            -pointsize -polaroid -posterize -preview -print \
            -process -profile -quality -quantize -quiet \
            -radial-blur -raise -random-threshold -recolor \
            -red-primary -regard-warnings -region -render -repage \
            -resample -resize -respect-parenthesis -reverse -roll \
            -rotate -sample -sampling-factor -scale -scene -seed \
            -segment -separate -sepia-tone -set -shade -shadow \
            -sharpen -shave -shear -sigmoidal-contrast -size \
            -sketch -solarize -splice -spread -stretch -strip \
            -stroke -strokewidth -style -swap -swirl -taint \
            -texture -threshold -thumbnail -tile -tile-offset \
            -tint -transform -transparent -transparent-color \
            -transpose -transverse -treedepth -trim -type \
            -undercolor -unique-colors -units -unsharp -verbose \
            -version -view -vignette -virtual-pixel -wave \
            -weight -white-point -white-threshold \
            -write' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+adjoin +append +compress \
            +contrast +debug +dither +endian +gamma +label +map \
            +mask +matte +negate +noise +page +raise +render \
            +write' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_count_args () 
{ 
    args=1;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            args=$(($args+1));
        fi;
    done
}
_cpan2dist () 
{ 
    local cur prev packagelist cpandirs;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        --format)
            COMPREPLY=($( compgen -W '$(perl -MCPANPLUS::Dist -e \
                "print map { \"\$_\n\" } CPANPLUS::Dist->dist_types")'                 -- "$cur" ));
            return 0
        ;;
        --@(banlist|ignorelist|modulelist|logfile))
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--help --skiptest --force --install \
            --verbose --keepsource --makefile --buildprereq \
            --archive --flushcache --defaults --edit-metafile \
            --format --ban --banlist --ignore --ignorelist \
            --modulelist --logfile --timeout --set-config \
            --set-program --dist-opts --default-banlist \
            --default-ignorelist' -- $cur ));
    else
        cpandirs=("$HOME/.cpanplus/" "$HOME/.cpan/source/modules/");
        for dir in ${cpandirs[@]};
        do
            [ -d "$dir" -a -r "$dir/02packages.details.txt.gz" ] && packagelist="$dir/02packages.details.txt.gz";
        done;
        COMPREPLY=($( zgrep "^${cur//-/::}"             $packagelist 2>/dev/null             | awk '{print $1}' | sed -e 's/::/-/g' ));
    fi
}
_cpio () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case $prev in 
        -H | --format)
            _cpio_format;
            return 0
        ;;
        -@(E|F|I|-?(pattern-)file))
            _filedir;
            return 0
        ;;
        -R | --owner)
            _usergroup;
            return 0
        ;;
        --rsh-command)
            COMPREPLY=($( compgen -c -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W '-o --create -i --extract -p --pass-through' -- "$cur" ));
    else
        case ${COMP_WORDS[1]} in 
            -@(o|-create))
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '-0 -a -c -v -A -B\
                        -L -V -C -H -M -O -F --file --format\
                        --message --null --reset-access-time\
                        --verbose --dot --append --block-size\
                        --dereference --io-size --quiet\
                        --force-local --rsh-command --help\
                        --version' -- "$cur" ));
                fi
            ;;
            -@(i|-extract))
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '-b -c -d -f -m -n -r\
                        -t -s -u -v -B -S -V -C -E -H -M -R -I\
                        -F --file --make-directories\
                        --nonmatching\
                        --preserve-modification-time\
                        --numeric-uid-gid --rename -t --list\
                        --swap-bytes --swap --dot\
                        --unconditional --verbose --block-size\
                        --swap-halfwords --io-size\
                        --pattern-file --format --owner\
                        --no-preserve-owner --message\
                        --force-local --no-absolute-filenames\
                        --sparse --only-verify-crc --quiet\
                        --rsh-command --help\
                        --version' -- "$cur" ));
                fi
            ;;
            -@(p|-pass-through))
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '-0 -a -d -l -m -u -v\
                        -L -V -R --null --reset-access-time\
                        --make-directories --link --quiet\
                        --preserve-modification-time\
                        --unconditional --verbose --dot\
                        --dereference --owner\
                        --no-preserve-owner --sparse --help\
                        --version' -- "$cur" ));
                else
                    _filedir -d;
                fi
            ;;
        esac;
    fi
}
_cpio_format () 
{ 
    COMPREPLY=($( compgen -W 'bin odc newc crc tar ustar hpbin hpodc' -- "$cur" ))
}
_dd () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword =`;
    case "$cur" in 
        if=* | of=*)
            cur=${cur#*=};
            _filedir;
            return 0
        ;;
        conv=*)
            cur=${cur#*=};
            COMPREPLY=($( compgen -W 'ascii ebcdic ibm block unblock \
            lcase notrunc ucase swab noerror sync' -- "$cur" ));
            return 0
        ;;
    esac;
    _expand || return 0;
    COMPREPLY=($( compgen -W '--help --version' -- "$cur" ) $( compgen -W 'bs cbs conv count ibs if obs of seek skip'                -S '=' -- "$cur" ))
}
_debconf_show () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    COMPREPLY=($( compgen -W '--listowners --listdbs --db=' -- $cur ) $( apt-cache pkgnames -- $cur ))
}
_desktop_file_validate () 
{ 
    COMPRELY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    _filedir '@(desktop)'
}
_dfutool () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        -@(d|-device))
            _bluetooth_devices;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-h --help -d --device' -- "$cur" ));
    else
        _count_args;
        case $args in 
            1)
                COMPREPLY=($( compgen -W 'verify modify \
                    upgrade archive' -- "$cur" ))
            ;;
            2)
                _filedir
            ;;
        esac;
    fi
}
_dhclient () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -@(cf|lf|pf|sf))
            _filedir;
            return 0
        ;;
        -s)
            _known_hosts_real "$cur";
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-p -d -q -1 -r -lf -pf \
            -cf -sf -s -g -n -nw -w' -- "$cur" ));
    else
        _available_interfaces;
    fi
}
_display () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-alpha -antialias -authenticate \
            -auto-orient -backdrop -background -border \
            -bordercolor -borderwidth -channel -clip \
            -clip-path -coalesce -colormap -colors -colorspace \
            -comment -compress -contrast -crop -debug -decipher \
            -define -delay -density -depth -despeckle -display \
            -dispose -dither -edge -endian -enhance -extract \
            -filter -flatten -flip -flop -font -foreground \
            -format -frame -gamma -geometry -help -iconGeometry \
            -iconic -identify -immutable -interlace -interpolate \
            -label -limit -list -log -loop -map -mattecolor \
            -monitor -monochrome -name -negate -page -profile \
            -quality -quantize -quiet -raise -regard-warnings \
            -remote -repage -resample -resize \
            -respect-parenthesis -roll -rotate -sample \
            -sampling-factor -scenes -seed -segment -set \
            -shared-memory -sharpen -size -strip -texture -title \
            -transparent-color -treedepth -trim -update \
            -usePixmap -verbose -version -virtual-pixel -visual \
            -window -window-group -write' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+compress +contrast +debug +dither \
            +endian +gamma +label +map +matte +negate +page \
            +raise +write' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_dpkg () 
{ 
    local cur prev i;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    i=$COMP_CWORD;
    _expand || return 0;
    _split_longopt;
    if [[ $cur != -* ]]; then
        while [[ $prev != -* && $i != 1 ]]; do
            i=$((i-1));
            prev=${COMP_WORDS[i-1]};
        done;
    fi;
    case "$prev" in 
        -@(c|i|A|I|f|e|x|X|W|-@(install|unpack|record-avail|contents|info|fsys-tarfile|field|control|extract|show)))
            _filedir '?(u)deb';
            return 0
        ;;
        -@(b|-build))
            _filedir -d;
            return 0
        ;;
        -@(s|p|l|-@(status|print-avail|list)))
            COMPREPLY=($( apt-cache pkgnames "$cur" 2>/dev/null ));
            return 0
        ;;
        -@(S|-search))
            _filedir;
            return 0
        ;;
        -@(r|L|P|-@(remove|purge|listfiles)))
            COMPREPLY=($( _comp_dpkg_installed_packages "$cur" ));
            return 0
        ;;
        *)
            COMPREPLY=($( compgen -W '-i --install --unpack -A --record-avail \
                --configure -r --remove -P --purge --get-selections \
                --set-selections --update-avail --merge-avail \
                --clear-avail  --command-fd --forget-old-unavail -s \
                --status -p --print-avail -L --listfiles -l --list \
                -S --search -C --audit --print-architecture \
                --print-gnu-build-architecture \
                --print-installation-architecture \
                --compare-versions --help --version --force-help \
                --force-all --force-auto-select --force-downgrade \
                --force-configure-any --force-hold --force-bad-path \
                --force-not-root --force-overwrite \
                --force-overwrite-diverted --force-bad-verify \
                --force-depends-version --force-depends \
                --force-confnew --force-confold --force-confdef \
                --force-confmiss --force-conflicts --force-architecture\
                --force-overwrite-dir --force-remove-reinstreq \
                --force-remove-essential -Dh \
                --debug=help --licence --admindir --root --instdir \
                -O --selected-only -E --skip-same-version \
                -G --refuse-downgrade -B --auto-deconfigure \
                --no-debsig --no-act -D --debug --status-fd \
                -b --build -I --info -f --field -c --contents \
                -x --extract -X --vextract --fsys-tarfile -e --control \
                --ignore-depends --abort-after' -- "$cur" ))
        ;;
    esac
}
_dpkg_reconfigure () 
{ 
    local cur prev opt;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -@(f|-frontend))
            opt=($( echo /usr/share/perl5/Debconf/FrontEnd/* ));
            opt=(${opt[@]##*/});
            opt=(${opt[@]%.pm});
            COMPREPLY=($( compgen -W '${opt[@]}' -- "$cur" ));
            return 0
        ;;
        -@(p|-priority))
            COMPREPLY=($( compgen -W 'low medium high critical' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-f --frontend -p --priority -a --all -u \
            --unseen-only -h --help -s --showold --force --terse' -- "$cur" ));
    else
        COMPREPLY=($( _comp_dpkg_installed_packages "$cur" ));
    fi
}
_dpkg_source () 
{ 
    local cur prev options work i action packopts unpackopts;
    packopts="-c -l -F -V -T -D -U -W -E -sa -i -I -sk -sp -su -sr -ss -sn -sA -sK -sP -sU -sR";
    unpackopts="-sp -sn -su";
    options=`echo "-x -b $packopts $unpackopts" | xargs echo | sort -u | xargs echo`;
    COMPREPLY=();
    if [ "$1" != "dpkg-source" ]; then
        return 1;
    fi;
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    action="options";
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ ${COMP_WORDS[$i]} == "-x" ]]; then
            action=unpack;
        else
            if [[ ${COMP_WORDS[$i]} == "-b" ]]; then
                action=pack;
            else
                if [[ ${COMP_WORDS[$i]} == "-h" ]]; then
                    action=help;
                fi;
            fi;
        fi;
    done;
    for i in $options;
    do
        if [ "$cur" = "$i" ]; then
            COMPREPLY=("$cur");
            return 0;
        fi;
    done;
    case "$action" in 
        "unpack")
            if [ "$cur" = "-" -o "$cur" = "-s" ]; then
                COMPREPLY=($unpackopts);
                return 0;
            fi;
            case "$prev" in 
                "-x")
                    COMPREPLY=($( compgen -d -- "$cur" ) $( compgen -f -X '!*.dsc' -- "$cur" ));
                    return 0
                ;;
                *)
                    COMPREPLY=($unpackopts $(compgen -d -f -- "$cur" ));
                    return 0
                ;;
            esac;
            return 0
        ;;
        "pack")
            if [ "$cur" = "-" ]; then
                COMPREPLY=($packopts);
                return 0;
            fi;
            if [ "$cur" = "-s" ]; then
                COMPREPLY=("-sa" "-sk" "-sp" "-su" "-sr" "-ss" "-sn" "-sA" "-sK" "-sP" "-sU" "-sR");
                return 0;
            fi;
            case "$prev" in 
                "-b")
                    COMPREPLY=($( compgen -d -- "$cur" ));
                    return 0
                ;;
                "-c" | "-l" | "-T" | "-i" | "-I")
                    COMPREPLY=($( compgen -d -f ));
                    return 0
                ;;
                "-F")
                    COMPREPLY=($( ( cd /usr/lib/dpkg/parsechangelog; compgen -f "$cur" ) ));
                    return 0
                ;;
                "-V" | "-D")
                    COMPREPLY=();
                    return 0
                ;;
                "-D")
                    if echo -- "$cur" | grep --color=auto -q "="; then
                        COMPREPLY=();
                        return 0;
                    else
                        COMPREPLY=(Format Source Version Binary Maintainer Uploader Architecture Standards-Version Build-Depends Files);
                        return 0;
                    fi
                ;;
                "-U")
                    COMPREPLY=(Format Source Version Binary Maintainer Uploader Architecture Standards-Version Build-Depends Files);
                    return 0
                ;;
                *)
                    COMPREPLY=($packopts);
                    return 0
                ;;
            esac;
            return 0
        ;;
        *)
            if [ "$cur" = "-s" ]; then
                COMPREPLY=("-sa" "-sk" "-sp" "-su" "-sr" "-ss" "-sn" "-sA" "-sK" "-sP" "-sU" "-sR");
                return 0;
            fi;
            COMPREPLY=($options);
            return 0
        ;;
    esac
}
_expand () 
{ 
    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur;
    else
        if [[ "$cur" == \~* ]]; then
            cur=${cur#\~};
            COMPREPLY=($( compgen -P '~' -u "$cur" ));
            [ ${#COMPREPLY[@]} -eq 1 ] && eval COMPREPLY[0]=${COMPREPLY[0]};
            return ${#COMPREPLY[@]};
        fi;
    fi
}
_export () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    case "$COMP_LINE" in 
        *=\$*)
            COMPREPLY=($( compgen -v -P '$' -- "${cur#*=\$}" ))
        ;;
        *[^=])
            COMPREPLY=($( compgen -v -S '=' -- "$cur" ))
        ;;
        *=)
            COMPREPLY=("$( eval echo -n \"$`echo ${cur%=}`\" |
                ( echo -n \'
                  sed -e 's/'\''/'\''\\\'\'''\''/g'
                  echo -n \' ) )")
        ;;
    esac
}
_faillog () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -h | --help | -l | --lock-time | -m | --maximum | -t | --time)
            return 0
        ;;
        -u | --user)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a --all -h --help -l --lock-time \
            -m --maximum -r --reset -t --time -u --user' -- "$cur" ));
        return 0;
    fi
}
_filedir () 
{ 
    local IFS='	
' xspec;
    _expand || return 0;
    local -a toks;
    local tmp;
    toks=(${toks[@]-} $(
    compgen -d -- "$(quote_readline "$cur")" | {
    while read -r tmp; do
        echo $tmp
    done
}
));
    if [[ "$1" != -d ]]; then
        xspec=${1:+"!*.$1"};
        toks=(${toks[@]-} $(
    compgen -f -X "$xspec" -- "$(quote_readline "$cur")" | {
    while read -r tmp; do
        [ -n $tmp ] && echo $tmp
    done
}
));
    fi;
    COMPREPLY=("${COMPREPLY[@]}" "${toks[@]}")
}
_filedir_xspec () 
{ 
    local IFS cur xspec;
    IFS='	
';
    COMPREPLY=();
    cur=`_get_cword`;
    _expand || return 0;
    xspec=$( sed -ne '/^complete .*[ 	]'${1##*/}'\([ 	]\|$\)/{p;q;}'         $BASH_COMPLETION );
    xspec=${xspec#*-X };
    xspec=${xspec%% *};
    local -a toks;
    local tmp;
    toks=(${toks[@]-} $(
        compgen -d -- "$(quote_readline "$cur")" | {
        while read -r tmp; do
            # see long TODO comment in _filedir() --David
            echo $tmp
        done
        }
        ));
    toks=(${toks[@]-} $(
        eval compgen -f -X "$xspec" -- "\$(quote_readline "\$cur")" | {
        while read -r tmp; do
            [ -n $tmp ] && echo $tmp
        done
        }
        ));
    COMPREPLY=("${toks[@]}")
}
_find () 
{ 
    local cur prev i exprfound onlyonce;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -@(max|min)depth)
            COMPREPLY=($( compgen -W '0 1 2 3 4 5 6 7 8 9' -- "$cur" ));
            return 0
        ;;
        -?(a|c)newer | -fls | -fprint?(0|f) | -?(i)?(l)name | -?(i)wholename)
            _filedir;
            return 0
        ;;
        -fstype)
            [ -e /proc/filesystems ] && COMPREPLY=($( compgen -W "$( cut -d'	' -f2 /proc/filesystems )"             -- "$cur" ));
            return 0
        ;;
        -gid)
            _gids;
            return 0
        ;;
        -group)
            if [ -n "$bash205" ]; then
                COMPREPLY=($( compgen -g -- $cur 2>/dev/null));
            fi;
            return 0
        ;;
        -?(x)type)
            COMPREPLY=($( compgen -W 'b c d p f l s' -- "$cur" ));
            return 0
        ;;
        -uid)
            _uids;
            return 0
        ;;
        -user)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
        -exec | -ok)
            COMP_WORDS=(COMP_WORDS[0] "$cur");
            COMP_CWORD=1;
            _command;
            return 0
        ;;
        -[acm]min | -[acm]time | -?(i)?(l)?(whole)name | -inum | -?(i)path | -?(i)regex | -links | -perm | -size | -used | -printf)
            return 0
        ;;
    esac;
    _expand || return 0;
    for i in ${COMP_WORDS[@]};
    do
        [[ "$i" = [-\(\),\!]* ]] && exprfound=1 && break;
    done;
    if [ "$exprfound" != 1 ] && [[ "$cur" != [-\(\),\!]* ]]; then
        _filedir -d;
        return 0;
    fi;
    COMPREPLY=($( compgen -W '-daystart -depth -follow -help -maxdepth \
        -mindepth -mount -noleaf -version -xdev -amin -anewer \
        -atime -cmin -cnewer -ctime -empty -false -fstype \
        -gid -group -ilname -iname -inum -ipath -iregex \
        -wholename \
        -links -lname -mmin -mtime -name -newer -nouser \
        -nogroup -perm -regex -size -true -type -uid -used \
        -user -xtype -exec -fls -fprint -fprint0 -fprintf -ok \
        -print -print0 -printf -prune -ls -wholename -iwholename' -- "$cur" ));
    onlyonce=' -daystart -depth -follow -help -maxdepth -mindepth -mount \
       -noleaf -version -xdev ';
    COMPREPLY=($( echo "${COMP_WORDS[@]}" |            (while read -d ' ' i; do
            [ "$i" == "" ] ||
            [ "${onlyonce/ ${i%% *} / }" == "$onlyonce" ] &&
            continue
            # flatten array with spaces on either side,
            # otherwise we cannot grep on word boundaries of
            # first and last word
            COMPREPLY=" ${COMPREPLY[@]} "
            # remove word from list of completions
            COMPREPLY=( ${COMPREPLY/ ${i%% *} / } )
            done
            echo "${COMPREPLY[@]}")
          ));
    _filedir;
    return 0
}
_function () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ $1 == @(declare|typeset) ]]; then
        if [ "$prev" = -f ]; then
            COMPREPLY=($( compgen -A function -- "$cur" ));
        else
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($( compgen -W '-a -f -F -i -r -x -p' -- "$cur" ));
            fi;
        fi;
    else
        if [ $COMP_CWORD -eq 1 ]; then
            COMPREPLY=($( compgen -A function -- "$cur" ));
        else
            COMPREPLY=("() $( type -- ${COMP_WORDS[1]} | sed -e 1,2d )");
        fi;
    fi
}
_gcc () 
{ 
    local cur cc backend;
    COMPREPLY=();
    cur=`_get_cword`;
    _expand || return 0;
    case "$1" in 
        gcj)
            backend=jc1
        ;;
        gpc)
            backend=gpc1
        ;;
        *77)
            backend=f771
        ;;
        *)
            backend=cc1
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        cc=$( $1 -print-prog-name=$backend );
        COMPREPLY=($( compgen -W "$( $cc --help 2>/dev/null |            tr '\t' ' ' |            sed -e '/^  *-/!d' -e 's/ *-\([^ ]*\).*/-\1/' |            sort -u )" -- "$cur" ));
    else
        _filedir;
    fi
}
_gdb () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ $COMP_CWORD -eq 1 ]; then
        local IFS;
        if [[ "$cur" == */* ]]; then
            IFS='
';
            COMPREPLY=($( PATH="$PATH:." compgen -d -c -- "$cur" ));
        else
            IFS=":";
            local path_array=($(echo "$PATH" | sed 's/::\+/:/g;s/^:\|:$//g'));
            IFS='
';
            COMPREPLY=($( compgen -d -W '$(find "${path_array[@]}" . \
                -mindepth 1 -maxdepth 1 -not -type d -executable \
                -printf "%f\\n" 2>/dev/null)' -- "$cur" ));
        fi;
    else
        if [ $COMP_CWORD -eq 2 ]; then
            prev=${prev##*/};
            COMPREPLY=($( compgen -fW "$( command ps axo comm,pid |             awk '{if ($1 ~ /^'"$prev"'/) print $2}' )" -- "$cur" ));
        fi;
    fi
}
_get_command () 
{ 
    local i;
    command=;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            command=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_comp_words_by_ref () 
{ 
    local exclude cur_ words_ cword_;
    if [ "$1" = "-n" ]; then
        exclude=$2;
        shift 2;
    fi;
    __git_reassemble_comp_words_by_ref "$exclude";
    cur_=${words_[cword_]};
    while [ $# -gt 0 ]; do
        case "$1" in 
            cur)
                cur=$cur_
            ;;
            prev)
                prev=${words_[$cword_-1]}
            ;;
            words)
                words=("${words_[@]}")
            ;;
            cword)
                cword=$cword_
            ;;
        esac;
        shift;
    done
}
_get_cword () 
{ 
    if [ -n "$bash4" ]; then
        __get_cword4 "$@";
    else
        __get_cword3;
    fi
}
_getent () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        passwd)
            COMPREPLY=($( compgen -u "$cur"  ));
            return 0
        ;;
        group)
            COMPREPLY=($( compgen -g "$cur"  ));
            return 0
        ;;
        services)
            COMPREPLY=($( compgen -s "$cur"  ));
            return 0
        ;;
        hosts)
            COMPREPLY=($( compgen -A hostname "$cur"  ));
            return 0
        ;;
        protocols | networks | ahosts | ahostsv4 | ahostsv6 | rpc)
            COMPREPLY=($( compgen -W "$( getent "$prev" |                 awk '{ print $1 }' )" -- "$cur" ));
            return 0
        ;;
        aliases | shadow)
            COMPREPLY=($( compgen -W "$( getent "$prev" | cut -d: -f1 )"                 -- "$cur" ));
            return 0
        ;;
    esac;
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W 'passwd group hosts services protocols \
            networks ahosts ahostsv4 ahostsv6 aliases ethers netgroup rpc \
            shadow' -- "$cur" ));
    fi
}
_gids () 
{ 
    if type getent &>/dev/null; then
        COMPREPLY=($( compgen -W '$( getent group | cut -d: -f3 )'             -- "$cur" ));
    else
        if type perl &>/dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ));
        fi;
    fi
}
_git () 
{ 
    __git_wrap__git_main
}
_git_add () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "
			--interactive --refresh --patch --update --dry-run
			--ignore-errors --intent-to-add
			";
            return
        ;;
    esac;
    __git_complete_index_file "--others --modified"
}
_git_am () 
{ 
    local dir="$(__gitdir)";
    if [ -d "$dir"/rebase-apply ]; then
        __gitcomp "--skip --continue --resolved --abort";
        return;
    fi;
    case "$cur" in 
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --*)
            __gitcomp "
			--3way --committer-date-is-author-date --ignore-date
			--ignore-whitespace --ignore-space-change
			--interactive --keep --no-utf8 --signoff --utf8
			--whitespace= --scissors
			";
            return
        ;;
    esac
}
_git_apply () 
{ 
    case "$cur" in 
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --*)
            __gitcomp "
			--stat --numstat --summary --check --index
			--cached --index-info --reverse --reject --unidiff-zero
			--apply --no-add --exclude=
			--ignore-whitespace --ignore-space-change
			--whitespace= --inaccurate-eof --verbose
			";
            return
        ;;
    esac
}
_git_archive () 
{ 
    case "$cur" in 
        --format=*)
            __gitcomp "$(git archive --list)" "" "${cur##--format=}";
            return
        ;;
        --remote=*)
            __gitcomp_nl "$(__git_remotes)" "" "${cur##--remote=}";
            return
        ;;
        --*)
            __gitcomp "
			--format= --list --verbose
			--prefix= --remote= --exec=
			";
            return
        ;;
    esac;
    __git_complete_file
}
_git_bisect () 
{ 
    __git_has_doubledash && return;
    local subcommands="start bad good skip reset visualize replay log run";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        if [ -f "$(__gitdir)"/BISECT_START ]; then
            __gitcomp "$subcommands";
        else
            __gitcomp "replay start";
        fi;
        return;
    fi;
    case "$subcommand" in 
        bad | good | reset | skip | start)
            __gitcomp_nl "$(__git_refs)"
        ;;
        *)

        ;;
    esac
}
_git_branch () 
{ 
    local i c=1 only_local_ref="n" has_r="n";
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in 
            -d | -m)
                only_local_ref="y"
            ;;
            -r)
                has_r="y"
            ;;
        esac;
        ((c++));
    done;
    case "$cur" in 
        --set-upstream-to=*)
            __gitcomp "$(__git_refs)" "" "${cur##--set-upstream-to=}"
        ;;
        --*)
            __gitcomp "
			--color --no-color --verbose --abbrev= --no-abbrev
			--track --no-track --contains --merged --no-merged
			--set-upstream-to= --edit-description --list
			--unset-upstream
			"
        ;;
        *)
            if [ $only_local_ref = "y" -a $has_r = "n" ]; then
                __gitcomp_nl "$(__git_heads)";
            else
                __gitcomp_nl "$(__git_refs)";
            fi
        ;;
    esac
}
_git_bundle () 
{ 
    local cmd="${words[2]}";
    case "$cword" in 
        2)
            __gitcomp "create list-heads verify unbundle"
        ;;
        3)

        ;;
        *)
            case "$cmd" in 
                create)
                    __git_complete_revlist
                ;;
            esac
        ;;
    esac
}
_git_checkout () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --conflict=*)
            __gitcomp "diff3 merge" "" "${cur##--conflict=}"
        ;;
        --*)
            __gitcomp "
			--quiet --ours --theirs --track --no-track --merge
			--conflict= --orphan --patch
			"
        ;;
        *)
            local flags="--track --no-track --no-guess" track=1;
            if [ -n "$(__git_find_on_cmdline "$flags")" ]; then
                track='';
            fi;
            __gitcomp_nl "$(__git_refs '' $track)"
        ;;
    esac
}
_git_cherry () 
{ 
    __gitcomp "$(__git_refs)"
}
_git_cherry_pick () 
{ 
    local dir="$(__gitdir)";
    if [ -f "$dir"/CHERRY_PICK_HEAD ]; then
        __gitcomp "--continue --quit --abort";
        return;
    fi;
    case "$cur" in 
        --*)
            __gitcomp "--edit --no-commit --signoff --strategy= --mainline"
        ;;
        *)
            __gitcomp_nl "$(__git_refs)"
        ;;
    esac
}
_git_clean () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "--dry-run --quiet";
            return
        ;;
    esac;
    __git_complete_index_file "--others"
}
_git_clone () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "
			--local
			--no-hardlinks
			--shared
			--reference
			--quiet
			--no-checkout
			--bare
			--mirror
			--origin
			--upload-pack
			--template=
			--depth
			--single-branch
			--branch
			";
            return
        ;;
    esac
}
_git_commit () 
{ 
    case "$prev" in 
        -c | -C)
            __gitcomp_nl "$(__git_refs)" "" "${cur}";
            return
        ;;
    esac;
    case "$cur" in 
        --cleanup=*)
            __gitcomp "default strip verbatim whitespace
			" "" "${cur##--cleanup=}";
            return
        ;;
        --reuse-message=* | --reedit-message=* | --fixup=* | --squash=*)
            __gitcomp_nl "$(__git_refs)" "" "${cur#*=}";
            return
        ;;
        --untracked-files=*)
            __gitcomp "all no normal" "" "${cur##--untracked-files=}";
            return
        ;;
        --*)
            __gitcomp "
			--all --author= --signoff --verify --no-verify
			--edit --no-edit
			--amend --include --only --interactive
			--dry-run --reuse-message= --reedit-message=
			--reset-author --file= --message= --template=
			--cleanup= --untracked-files --untracked-files=
			--verbose --quiet --fixup= --squash=
			";
            return
        ;;
    esac;
    if git rev-parse --verify --quiet HEAD > /dev/null; then
        __git_complete_index_file "--committable";
    else
        __git_complete_index_file "--cached";
    fi
}
_git_config () 
{ 
    case "$prev" in 
        branch.*.remote | branch.*.pushremote)
            __gitcomp_nl "$(__git_remotes)";
            return
        ;;
        branch.*.merge)
            __gitcomp_nl "$(__git_refs)";
            return
        ;;
        branch.*.rebase)
            __gitcomp "false true";
            return
        ;;
        remote.pushdefault)
            __gitcomp_nl "$(__git_remotes)";
            return
        ;;
        remote.*.fetch)
            local remote="${prev#remote.}";
            remote="${remote%.fetch}";
            if [ -z "$cur" ]; then
                __gitcomp_nl "refs/heads/" "" "" "";
                return;
            fi;
            __gitcomp_nl "$(__git_refs_remotes "$remote")";
            return
        ;;
        remote.*.push)
            local remote="${prev#remote.}";
            remote="${remote%.push}";
            __gitcomp_nl "$(git --git-dir="$(__gitdir)" 			for-each-ref --format='%(refname):%(refname)' 			refs/heads)";
            return
        ;;
        pull.twohead | pull.octopus)
            __git_compute_merge_strategies;
            __gitcomp "$__git_merge_strategies";
            return
        ;;
        color.branch | color.diff | color.interactive | color.showbranch | color.status | color.ui)
            __gitcomp "always never auto";
            return
        ;;
        color.pager)
            __gitcomp "false true";
            return
        ;;
        color.*.*)
            __gitcomp "
			normal black red green yellow blue magenta cyan white
			bold dim ul blink reverse
			";
            return
        ;;
        diff.submodule)
            __gitcomp "log short";
            return
        ;;
        help.format)
            __gitcomp "man info web html";
            return
        ;;
        log.date)
            __gitcomp "$__git_log_date_formats";
            return
        ;;
        sendemail.aliasesfiletype)
            __gitcomp "mutt mailrc pine elm gnus";
            return
        ;;
        sendemail.confirm)
            __gitcomp "$__git_send_email_confirm_options";
            return
        ;;
        sendemail.suppresscc)
            __gitcomp "$__git_send_email_suppresscc_options";
            return
        ;;
        --get | --get-all | --unset | --unset-all)
            __gitcomp_nl "$(__git_config_get_set_variables)";
            return
        ;;
        *.*)
            return
        ;;
    esac;
    case "$cur" in 
        --*)
            __gitcomp "
			--system --global --local --file=
			--list --replace-all
			--get --get-all --get-regexp
			--add --unset --unset-all
			--remove-section --rename-section
			";
            return
        ;;
        branch.*.*)
            local pfx="${cur%.*}." cur_="${cur##*.}";
            __gitcomp "remote pushremote merge mergeoptions rebase" "$pfx" "$cur_";
            return
        ;;
        branch.*)
            local pfx="${cur%.*}." cur_="${cur#*.}";
            __gitcomp_nl "$(__git_heads)" "$pfx" "$cur_" ".";
            return
        ;;
        guitool.*.*)
            local pfx="${cur%.*}." cur_="${cur##*.}";
            __gitcomp "
			argprompt cmd confirm needsfile noconsole norescan
			prompt revprompt revunmerged title
			" "$pfx" "$cur_";
            return
        ;;
        difftool.*.*)
            local pfx="${cur%.*}." cur_="${cur##*.}";
            __gitcomp "cmd path" "$pfx" "$cur_";
            return
        ;;
        man.*.*)
            local pfx="${cur%.*}." cur_="${cur##*.}";
            __gitcomp "cmd path" "$pfx" "$cur_";
            return
        ;;
        mergetool.*.*)
            local pfx="${cur%.*}." cur_="${cur##*.}";
            __gitcomp "cmd path trustExitCode" "$pfx" "$cur_";
            return
        ;;
        pager.*)
            local pfx="${cur%.*}." cur_="${cur#*.}";
            __git_compute_all_commands;
            __gitcomp_nl "$__git_all_commands" "$pfx" "$cur_";
            return
        ;;
        remote.*.*)
            local pfx="${cur%.*}." cur_="${cur##*.}";
            __gitcomp "
			url proxy fetch push mirror skipDefaultUpdate
			receivepack uploadpack tagopt pushurl
			" "$pfx" "$cur_";
            return
        ;;
        remote.*)
            local pfx="${cur%.*}." cur_="${cur#*.}";
            __gitcomp_nl "$(__git_remotes)" "$pfx" "$cur_" ".";
            return
        ;;
        url.*.*)
            local pfx="${cur%.*}." cur_="${cur##*.}";
            __gitcomp "insteadOf pushInsteadOf" "$pfx" "$cur_";
            return
        ;;
    esac;
    __gitcomp "
		add.ignoreErrors
		advice.commitBeforeMerge
		advice.detachedHead
		advice.implicitIdentity
		advice.pushNonFastForward
		advice.resolveConflict
		advice.statusHints
		alias.
		am.keepcr
		apply.ignorewhitespace
		apply.whitespace
		branch.autosetupmerge
		branch.autosetuprebase
		browser.
		clean.requireForce
		color.branch
		color.branch.current
		color.branch.local
		color.branch.plain
		color.branch.remote
		color.decorate.HEAD
		color.decorate.branch
		color.decorate.remoteBranch
		color.decorate.stash
		color.decorate.tag
		color.diff
		color.diff.commit
		color.diff.frag
		color.diff.func
		color.diff.meta
		color.diff.new
		color.diff.old
		color.diff.plain
		color.diff.whitespace
		color.grep
		color.grep.context
		color.grep.filename
		color.grep.function
		color.grep.linenumber
		color.grep.match
		color.grep.selected
		color.grep.separator
		color.interactive
		color.interactive.error
		color.interactive.header
		color.interactive.help
		color.interactive.prompt
		color.pager
		color.showbranch
		color.status
		color.status.added
		color.status.changed
		color.status.header
		color.status.nobranch
		color.status.untracked
		color.status.updated
		color.ui
		commit.status
		commit.template
		core.abbrev
		core.askpass
		core.attributesfile
		core.autocrlf
		core.bare
		core.bigFileThreshold
		core.compression
		core.createObject
		core.deltaBaseCacheLimit
		core.editor
		core.eol
		core.excludesfile
		core.fileMode
		core.fsyncobjectfiles
		core.gitProxy
		core.ignoreStat
		core.ignorecase
		core.logAllRefUpdates
		core.loosecompression
		core.notesRef
		core.packedGitLimit
		core.packedGitWindowSize
		core.pager
		core.preferSymlinkRefs
		core.preloadindex
		core.quotepath
		core.repositoryFormatVersion
		core.safecrlf
		core.sharedRepository
		core.sparseCheckout
		core.symlinks
		core.trustctime
		core.warnAmbiguousRefs
		core.whitespace
		core.worktree
		diff.autorefreshindex
		diff.external
		diff.ignoreSubmodules
		diff.mnemonicprefix
		diff.noprefix
		diff.renameLimit
		diff.renames
		diff.statGraphWidth
		diff.submodule
		diff.suppressBlankEmpty
		diff.tool
		diff.wordRegex
		diff.algorithm
		difftool.
		difftool.prompt
		fetch.recurseSubmodules
		fetch.unpackLimit
		format.attach
		format.cc
		format.headers
		format.numbered
		format.pretty
		format.signature
		format.signoff
		format.subjectprefix
		format.suffix
		format.thread
		format.to
		gc.
		gc.aggressiveWindow
		gc.auto
		gc.autopacklimit
		gc.packrefs
		gc.pruneexpire
		gc.reflogexpire
		gc.reflogexpireunreachable
		gc.rerereresolved
		gc.rerereunresolved
		gitcvs.allbinary
		gitcvs.commitmsgannotation
		gitcvs.dbTableNamePrefix
		gitcvs.dbdriver
		gitcvs.dbname
		gitcvs.dbpass
		gitcvs.dbuser
		gitcvs.enabled
		gitcvs.logfile
		gitcvs.usecrlfattr
		guitool.
		gui.blamehistoryctx
		gui.commitmsgwidth
		gui.copyblamethreshold
		gui.diffcontext
		gui.encoding
		gui.fastcopyblame
		gui.matchtrackingbranch
		gui.newbranchtemplate
		gui.pruneduringfetch
		gui.spellingdictionary
		gui.trustmtime
		help.autocorrect
		help.browser
		help.format
		http.lowSpeedLimit
		http.lowSpeedTime
		http.maxRequests
		http.minSessions
		http.noEPSV
		http.postBuffer
		http.proxy
		http.sslCAInfo
		http.sslCAPath
		http.sslCert
		http.sslCertPasswordProtected
		http.sslKey
		http.sslVerify
		http.useragent
		i18n.commitEncoding
		i18n.logOutputEncoding
		imap.authMethod
		imap.folder
		imap.host
		imap.pass
		imap.port
		imap.preformattedHTML
		imap.sslverify
		imap.tunnel
		imap.user
		init.templatedir
		instaweb.browser
		instaweb.httpd
		instaweb.local
		instaweb.modulepath
		instaweb.port
		interactive.singlekey
		log.date
		log.decorate
		log.showroot
		mailmap.file
		man.
		man.viewer
		merge.
		merge.conflictstyle
		merge.log
		merge.renameLimit
		merge.renormalize
		merge.stat
		merge.tool
		merge.verbosity
		mergetool.
		mergetool.keepBackup
		mergetool.keepTemporaries
		mergetool.prompt
		notes.displayRef
		notes.rewrite.
		notes.rewrite.amend
		notes.rewrite.rebase
		notes.rewriteMode
		notes.rewriteRef
		pack.compression
		pack.deltaCacheLimit
		pack.deltaCacheSize
		pack.depth
		pack.indexVersion
		pack.packSizeLimit
		pack.threads
		pack.window
		pack.windowMemory
		pager.
		pretty.
		pull.octopus
		pull.twohead
		push.default
		rebase.autosquash
		rebase.stat
		receive.autogc
		receive.denyCurrentBranch
		receive.denyDeleteCurrent
		receive.denyDeletes
		receive.denyNonFastForwards
		receive.fsckObjects
		receive.unpackLimit
		receive.updateserverinfo
		remote.pushdefault
		remotes.
		repack.usedeltabaseoffset
		rerere.autoupdate
		rerere.enabled
		sendemail.
		sendemail.aliasesfile
		sendemail.aliasfiletype
		sendemail.bcc
		sendemail.cc
		sendemail.cccmd
		sendemail.chainreplyto
		sendemail.confirm
		sendemail.envelopesender
		sendemail.from
		sendemail.identity
		sendemail.multiedit
		sendemail.signedoffbycc
		sendemail.smtpdomain
		sendemail.smtpencryption
		sendemail.smtppass
		sendemail.smtpserver
		sendemail.smtpserveroption
		sendemail.smtpserverport
		sendemail.smtpuser
		sendemail.suppresscc
		sendemail.suppressfrom
		sendemail.thread
		sendemail.to
		sendemail.validate
		showbranch.default
		status.relativePaths
		status.showUntrackedFiles
		status.submodulesummary
		submodule.
		tar.umask
		transfer.unpackLimit
		url.
		user.email
		user.name
		user.signingkey
		web.browser
		branch. remote.
	"
}
_git_describe () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "
			--all --tags --contains --abbrev= --candidates=
			--exact-match --debug --long --match --always
			";
            return
        ;;
    esac;
    __gitcomp_nl "$(__git_refs)"
}
_git_diff () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --diff-algorithm=*)
            __gitcomp "$__git_diff_algorithms" "" "${cur##--diff-algorithm=}";
            return
        ;;
        --*)
            __gitcomp "--cached --staged --pickaxe-all --pickaxe-regex
			--base --ours --theirs --no-index
			$__git_diff_common_options
			";
            return
        ;;
    esac;
    __git_complete_revlist_file
}
_git_difftool () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --tool=*)
            __gitcomp "$__git_mergetools_common kompare" "" "${cur##--tool=}";
            return
        ;;
        --*)
            __gitcomp "--cached --staged --pickaxe-all --pickaxe-regex
			--base --ours --theirs
			--no-renames --diff-filter= --find-copies-harder
			--relative --ignore-submodules
			--tool=";
            return
        ;;
    esac;
    __git_complete_revlist_file
}
_git_fetch () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "$__git_fetch_options";
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_format_patch () 
{ 
    case "$cur" in 
        --thread=*)
            __gitcomp "
			deep shallow
			" "" "${cur##--thread=}";
            return
        ;;
        --*)
            __gitcomp "$__git_format_patch_options";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_fsck () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "
			--tags --root --unreachable --cache --no-reflogs --full
			--strict --verbose --lost-found
			";
            return
        ;;
    esac
}
_git_gc () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "--prune --aggressive";
            return
        ;;
    esac
}
_git_gitk () 
{ 
    _gitk
}
_git_grep () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --*)
            __gitcomp "
			--cached
			--text --ignore-case --word-regexp --invert-match
			--full-name --line-number
			--extended-regexp --basic-regexp --fixed-strings
			--perl-regexp
			--files-with-matches --name-only
			--files-without-match
			--max-depth
			--count
			--and --or --not --all-match
			";
            return
        ;;
    esac;
    case "$cword,$prev" in 
        2,* | *,-*)
            if test -r tags; then
                __gitcomp_nl "$(__git_match_ctag "$cur" tags)";
                return;
            fi
        ;;
    esac;
    __gitcomp_nl "$(__git_refs)"
}
_git_help () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "--all --info --man --web";
            return
        ;;
    esac;
    __git_compute_all_commands;
    __gitcomp "$__git_all_commands $(__git_aliases)
		attributes cli core-tutorial cvs-migration
		diffcore gitk glossary hooks ignore modules
		namespaces repository-layout tutorial tutorial-2
		workflows
		"
}
_git_init () 
{ 
    case "$cur" in 
        --shared=*)
            __gitcomp "
			false true umask group all world everybody
			" "" "${cur##--shared=}";
            return
        ;;
        --*)
            __gitcomp "--quiet --bare --template= --shared --shared=";
            return
        ;;
    esac
}
_git_log () 
{ 
    __git_has_doubledash && return;
    local g="$(git rev-parse --git-dir 2>/dev/null)";
    local merge="";
    if [ -f "$g/MERGE_HEAD" ]; then
        merge="--merge";
    fi;
    case "$cur" in 
        --pretty=* | --format=*)
            __gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
			" "" "${cur#*=}";
            return
        ;;
        --date=*)
            __gitcomp "$__git_log_date_formats" "" "${cur##--date=}";
            return
        ;;
        --decorate=*)
            __gitcomp "long short" "" "${cur##--decorate=}";
            return
        ;;
        --*)
            __gitcomp "
			$__git_log_common_options
			$__git_log_shortlog_options
			$__git_log_gitk_options
			--root --topo-order --date-order --reverse
			--follow --full-diff
			--abbrev-commit --abbrev=
			--relative-date --date=
			--pretty= --format= --oneline
			--cherry-pick
			--graph
			--decorate --decorate=
			--walk-reflogs
			--parents --children
			$merge
			$__git_diff_common_options
			--pickaxe-all --pickaxe-regex
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_ls_files () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "--cached --deleted --modified --others --ignored
			--stage --directory --no-empty-directory --unmerged
			--killed --exclude= --exclude-from=
			--exclude-per-directory= --exclude-standard
			--error-unmatch --with-tree= --full-name
			--abbrev --ignored --exclude-per-directory
			";
            return
        ;;
    esac;
    __git_complete_index_file "--cached"
}
_git_ls_remote () 
{ 
    __gitcomp_nl "$(__git_remotes)"
}
_git_ls_tree () 
{ 
    __git_complete_file
}
_git_merge () 
{ 
    __git_complete_strategy && return;
    case "$cur" in 
        --*)
            __gitcomp "$__git_merge_options";
            return
        ;;
    esac;
    __gitcomp_nl "$(__git_refs)"
}
_git_merge_base () 
{ 
    __gitcomp_nl "$(__git_refs)"
}
_git_mergetool () 
{ 
    case "$cur" in 
        --tool=*)
            __gitcomp "$__git_mergetools_common tortoisemerge" "" "${cur##--tool=}";
            return
        ;;
        --*)
            __gitcomp "--tool=";
            return
        ;;
    esac
}
_git_mv () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "--dry-run";
            return
        ;;
    esac;
    if [ $(__git_count_arguments "mv") -gt 0 ]; then
        __git_complete_index_file "--cached --others --directory";
    else
        __git_complete_index_file "--cached";
    fi
}
_git_name_rev () 
{ 
    __gitcomp "--tags --all --stdin"
}
_git_notes () 
{ 
    local subcommands='add append copy edit list prune remove show';
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    case "$subcommand,$cur" in 
        ,--*)
            __gitcomp '--ref'
        ;;
        ,*)
            case "$prev" in 
                --ref)
                    __gitcomp_nl "$(__git_refs)"
                ;;
                *)
                    __gitcomp "$subcommands --ref"
                ;;
            esac
        ;;
        add,--reuse-message=* | append,--reuse-message=* | add,--reedit-message=* | append,--reedit-message=*)
            __gitcomp_nl "$(__git_refs)" "" "${cur#*=}"
        ;;
        add,--* | append,--*)
            __gitcomp '--file= --message= --reedit-message=
				--reuse-message='
        ;;
        copy,--*)
            __gitcomp '--stdin'
        ;;
        prune,--*)
            __gitcomp '--dry-run --verbose'
        ;;
        prune,*)

        ;;
        *)
            case "$prev" in 
                -m | -F)

                ;;
                *)
                    __gitcomp_nl "$(__git_refs)"
                ;;
            esac
        ;;
    esac
}
_git_pull () 
{ 
    __git_complete_strategy && return;
    case "$cur" in 
        --*)
            __gitcomp "
			--rebase --no-rebase
			$__git_merge_options
			$__git_fetch_options
		";
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_push () 
{ 
    case "$prev" in 
        --repo)
            __gitcomp_nl "$(__git_remotes)";
            return
        ;;
    esac;
    case "$cur" in 
        --repo=*)
            __gitcomp_nl "$(__git_remotes)" "" "${cur##--repo=}";
            return
        ;;
        --*)
            __gitcomp "
			--all --mirror --tags --dry-run --force --verbose
			--receive-pack= --repo= --set-upstream
		";
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_rebase () 
{ 
    local dir="$(__gitdir)";
    if [ -d "$dir"/rebase-apply ] || [ -d "$dir"/rebase-merge ]; then
        __gitcomp "--continue --skip --abort";
        return;
    fi;
    __git_complete_strategy && return;
    case "$cur" in 
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --*)
            __gitcomp "
			--onto --merge --strategy --interactive
			--preserve-merges --stat --no-stat
			--committer-date-is-author-date --ignore-date
			--ignore-whitespace --whitespace=
			--autosquash
			";
            return
        ;;
    esac;
    __gitcomp_nl "$(__git_refs)"
}
_git_reflog () 
{ 
    local subcommands="show delete expire";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
    else
        __gitcomp_nl "$(__git_refs)";
    fi
}
_git_remote () 
{ 
    local subcommands="add rename remove set-head set-branches set-url show prune update";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
        return;
    fi;
    case "$subcommand" in 
        rename | remove | set-url | show | prune)
            __gitcomp_nl "$(__git_remotes)"
        ;;
        set-head | set-branches)
            __git_complete_remote_or_refspec
        ;;
        update)
            local i c='' IFS='
';
            for i in $(git --git-dir="$(__gitdir)" config --get-regexp "remotes\..*" 2>/dev/null);
            do
                i="${i#remotes.}";
                c="$c ${i/ */}";
            done;
            __gitcomp "$c"
        ;;
        *)

        ;;
    esac
}
_git_replace () 
{ 
    __gitcomp_nl "$(__git_refs)"
}
_git_reset () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --*)
            __gitcomp "--merge --mixed --hard --soft --patch";
            return
        ;;
    esac;
    __gitcomp_nl "$(__git_refs)"
}
_git_revert () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "--edit --mainline --no-edit --no-commit --signoff";
            return
        ;;
    esac;
    __gitcomp_nl "$(__git_refs)"
}
_git_rm () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "--cached --dry-run --ignore-unmatch --quiet";
            return
        ;;
    esac;
    __git_complete_index_file "--cached"
}
_git_send_email () 
{ 
    case "$cur" in 
        --confirm=*)
            __gitcomp "
			$__git_send_email_confirm_options
			" "" "${cur##--confirm=}";
            return
        ;;
        --suppress-cc=*)
            __gitcomp "
			$__git_send_email_suppresscc_options
			" "" "${cur##--suppress-cc=}";
            return
        ;;
        --smtp-encryption=*)
            __gitcomp "ssl tls" "" "${cur##--smtp-encryption=}";
            return
        ;;
        --thread=*)
            __gitcomp "
			deep shallow
			" "" "${cur##--thread=}";
            return
        ;;
        --*)
            __gitcomp "--annotate --bcc --cc --cc-cmd --chain-reply-to
			--compose --confirm= --dry-run --envelope-sender
			--from --identity
			--in-reply-to --no-chain-reply-to --no-signed-off-by-cc
			--no-suppress-from --no-thread --quiet
			--signed-off-by-cc --smtp-pass --smtp-server
			--smtp-server-port --smtp-encryption= --smtp-user
			--subject --suppress-cc= --suppress-from --thread --to
			--validate --no-validate
			$__git_format_patch_options";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_shortlog () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --*)
            __gitcomp "
			$__git_log_common_options
			$__git_log_shortlog_options
			--numbered --summary
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_show () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --pretty=* | --format=*)
            __gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
			" "" "${cur#*=}";
            return
        ;;
        --diff-algorithm=*)
            __gitcomp "$__git_diff_algorithms" "" "${cur##--diff-algorithm=}";
            return
        ;;
        --*)
            __gitcomp "--pretty= --format= --abbrev-commit --oneline
			$__git_diff_common_options
			";
            return
        ;;
    esac;
    __git_complete_revlist_file
}
_git_show_branch () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "
			--all --remotes --topo-order --current --more=
			--list --independent --merge-base --no-name
			--color --no-color
			--sha1-name --sparse --topics --reflog
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_stage () 
{ 
    _git_add
}
_git_stash () 
{ 
    local save_opts='--keep-index --no-keep-index --quiet --patch';
    local subcommands='save list show apply clear drop pop create branch';
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        case "$cur" in 
            --*)
                __gitcomp "$save_opts"
            ;;
            *)
                if [ -z "$(__git_find_on_cmdline "$save_opts")" ]; then
                    __gitcomp "$subcommands";
                fi
            ;;
        esac;
    else
        case "$subcommand,$cur" in 
            save,--*)
                __gitcomp "$save_opts"
            ;;
            apply,--* | pop,--*)
                __gitcomp "--index --quiet"
            ;;
            show,--* | drop,--* | branch,--*)

            ;;
            show,* | apply,* | drop,* | pop,* | branch,*)
                __gitcomp_nl "$(git --git-dir="$(__gitdir)" stash list 					| sed -n -e 's/:.*//p')"
            ;;
            *)

            ;;
        esac;
    fi
}
_git_submodule () 
{ 
    __git_has_doubledash && return;
    local subcommands="add status init deinit update summary foreach sync";
    if [ -z "$(__git_find_on_cmdline "$subcommands")" ]; then
        case "$cur" in 
            --*)
                __gitcomp "--quiet --cached"
            ;;
            *)
                __gitcomp "$subcommands"
            ;;
        esac;
        return;
    fi
}
_git_svn () 
{ 
    local subcommands="
		init fetch clone rebase dcommit log find-rev
		set-tree commit-diff info create-ignore propget
		proplist show-ignore show-externals branch tag blame
		migrate mkdirs reset gc
		";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
    else
        local remote_opts="--username= --config-dir= --no-auth-cache";
        local fc_opts="
			--follow-parent --authors-file= --repack=
			--no-metadata --use-svm-props --use-svnsync-props
			--log-window-size= --no-checkout --quiet
			--repack-flags --use-log-author --localtime
			--ignore-paths= --include-paths= $remote_opts
			";
        local init_opts="
			--template= --shared= --trunk= --tags=
			--branches= --stdlayout --minimize-url
			--no-metadata --use-svm-props --use-svnsync-props
			--rewrite-root= --prefix= --use-log-author
			--add-author-from $remote_opts
			";
        local cmt_opts="
			--edit --rmdir --find-copies-harder --copy-similarity=
			";
        case "$subcommand,$cur" in 
            fetch,--*)
                __gitcomp "--revision= --fetch-all $fc_opts"
            ;;
            clone,--*)
                __gitcomp "--revision= $fc_opts $init_opts"
            ;;
            init,--*)
                __gitcomp "$init_opts"
            ;;
            dcommit,--*)
                __gitcomp "
				--merge --strategy= --verbose --dry-run
				--fetch-all --no-rebase --commit-url
				--revision --interactive $cmt_opts $fc_opts
				"
            ;;
            set-tree,--*)
                __gitcomp "--stdin $cmt_opts $fc_opts"
            ;;
            create-ignore,--* | propget,--* | proplist,--* | show-ignore,--* | show-externals,--* | mkdirs,--*)
                __gitcomp "--revision="
            ;;
            log,--*)
                __gitcomp "
				--limit= --revision= --verbose --incremental
				--oneline --show-commit --non-recursive
				--authors-file= --color
				"
            ;;
            rebase,--*)
                __gitcomp "
				--merge --verbose --strategy= --local
				--fetch-all --dry-run $fc_opts
				"
            ;;
            commit-diff,--*)
                __gitcomp "--message= --file= --revision= $cmt_opts"
            ;;
            info,--*)
                __gitcomp "--url"
            ;;
            branch,--*)
                __gitcomp "--dry-run --message --tag"
            ;;
            tag,--*)
                __gitcomp "--dry-run --message"
            ;;
            blame,--*)
                __gitcomp "--git-format"
            ;;
            migrate,--*)
                __gitcomp "
				--config-dir= --ignore-paths= --minimize
				--no-auth-cache --username=
				"
            ;;
            reset,--*)
                __gitcomp "--revision= --parent"
            ;;
            *)

            ;;
        esac;
    fi
}
_git_tag () 
{ 
    local i c=1 f=0;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in 
            -d | -v)
                __gitcomp_nl "$(__git_tags)";
                return
            ;;
            -f)
                f=1
            ;;
        esac;
        ((c++));
    done;
    case "$prev" in 
        -m | -F)

        ;;
        -* | tag)
            if [ $f = 1 ]; then
                __gitcomp_nl "$(__git_tags)";
            fi
        ;;
        *)
            __gitcomp_nl "$(__git_refs)"
        ;;
    esac
}
_git_whatchanged () 
{ 
    _git_log
}
_gitk () 
{ 
    __git_wrap__gitk_main
}
_gpasswd () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -a | -d | -A | -M)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -d -r -R -A -M' -- "$cur" ));
        return 0;
    fi;
    [ -n "$bash205" ] && COMPREPLY=($( compgen -g -- "$cur" ))
}
_gpg () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -@(s|-sign|-clearsign|-decrypt-files|-load-extension))
            _filedir;
            return 0
        ;;
        --@(export|@(?(l|nr|nrl)sign|edit)-key))
            COMPREPLY=($( compgen -W "$( gpg --list-keys 2>/dev/null |                 sed -ne 's@^pub.*/\([^ ]*\).*$@\1@p;s@^.*\(<\([^>]*\)>\).*$@\2@p')" -- "$cur" ));
            return 0
        ;;
        -@(r|-recipient))
            COMPREPLY=($( compgen -W "$( gpg --list-keys 2>/dev/null |                 sed -ne 's@^.*<\([^>]*\)>.*$@\1@p')" -- "$cur" ));
            if [ -e ~/.gnupg/gpg.conf ]; then
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -W "$( sed -ne                     's@^[ \t]*group[ \t][ \t]*\([^=]*\).*$@\1@p'                     ~/.gnupg/gpg.conf  )" -- "$cur"));
            fi;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-s -b -e -f -c -d -a -r -u -Z -o -v\
            -q -n -N $(gpg --dump-options)' -- "$cur" ));
    fi
}
_groupadd () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -g | --gid | -K | --key | -p | --password)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-f --force -g --gid -h --help \
            -K --key -o --non-unique -p --password -r --system'             -- "$cur" ));
        return 0;
    fi
}
_groupmod () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -g | --gid | -h | --help | -n | --new-name | -p | --password)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-g --gid -h --help -n --new-name \
            -o --non-unique -p --password' -- "$cur" ));
        return 0;
    fi;
    [ -n "$bash205" ] && COMPREPLY=($( compgen -g -- "$cur" ))
}
_grpck () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-r -s' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_gzip () 
{ 
    local cur prev xspec helpopts;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    helpopts=`_parse_help gzip`;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$helpopts -2 -3 -4 -5 -6 -7 -8" -- "$cur" ));
        return 0;
    fi;
    local IFS='	
';
    xspec="*.?(t)gz";
    if [[ "$prev" == --* ]]; then
        [[ "$prev" == --decompress || "$prev" == --list || "$prev" == --test ]] && xspec="!"$xspec;
        [[ "$prev" == --force ]] && xspec=;
    else
        if [[ "$prev" == -* ]]; then
            [[ "$prev" == -*[dlt]* ]] && xspec="!"$xspec;
            [[ "$prev" == -*f* ]] && xspec=;
        else
            if [ "$prev" = '>' -o "$prev" = '>>' ]; then
                xspec=;
            else
                if [ "$prev" = '<' ]; then
                    xspec=;
                fi;
            fi;
        fi;
    fi;
    _expand || return 0;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_hciattach () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-n -p -t -b -s -l' -- "$cur" ));
    else
        _count_args;
        case $args in 
            1)
                COMPREPLY=($( command ls /dev/tty* ));
                COMPREPLY=($( compgen -W '${COMPREPLY[@]} \
                    ${COMPREPLY[@]#/dev/}' -- "$cur" ))
            ;;
            2)
                COMPREPLY=($( compgen -W 'any ericsson digi \
                    xircom csr bboxes swave bcsp 0x0105 \
                    0x080a 0x0160 0x0002' -- "$cur" ))
            ;;
            3)
                COMPREPLY=($( compgen -W '9600 19200 38400 \
                    57600 115200 230400 460800 921600' -- "$cur" ))
            ;;
            4)
                COMPREPLY=($( compgen -W 'flow noflow' -- "$cur" ))
            ;;
            5)
                _bluetooth_adresses
            ;;
        esac;
    fi
}
_hciconfig () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _get_command;
    if [ -z $command ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-h --help -a --all' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W 'up down reset rstat auth \
                noauth encrypt noencrypt secmgr nosecmgr \
                piscan noscan iscan pscan ptype name class \
                voice iac inqmode inqdata inqtype inqparams \
                pageparms pageto afhmode aclmtu scomtu putkey \
                delkey commands features version revision lm'                 -- "$cur" ));
        fi;
    else
        case $command in 
            @(putkey|delkey))
                _count_args;
                if [ $args -eq 2 ]; then
                    _bluetooth_adresses;
                fi
            ;;
            lm)
                _count_args;
                if [ $args -eq 2 ]; then
                    COMPREPLY=($( compgen -W 'MASTER \
                        SLAVE NONE ACCEPT' -- "$cur" ));
                fi
            ;;
            ptype)
                _count_args;
                if [ $args -eq 2 ]; then
                    _bluetooth_packet_types;
                fi
            ;;
        esac;
    fi
}
_hcitool () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case $prev in 
        -i)
            _bluetooth_devices;
            return 0
        ;;
        --role)
            COMPREPLY=($( compgen -W 'm s' -- "$cur" ));
            return 0
        ;;
        --pkt-type)
            _bluetooth_packet_types;
            return 0
        ;;
    esac;
    $split && return 0;
    _get_command;
    if [ -z $command ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-h -i' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W 'dev inq scan name info \
                spinq epinq cmd con cc dc sr cpt rssi lq tpl \
                afh lst auth enc key clkoff clock' -- "$cur" ));
        fi;
    else
        case $command in 
            @(name|info|dc|rssi|lq|afh|auth|key|clkoff|lst))
                _count_args;
                if [ $args -eq 2 ]; then
                    _bluetooth_adresses;
                fi
            ;;
            cc)
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '--role --pkt-type' -- "$cur" ));
                else
                    _count_args;
                    if [ $args -eq 2 ]; then
                        _bluetooth_adresses;
                    fi;
                fi
            ;;
            sr)
                _count_args;
                if [ $args -eq 2 ]; then
                    _bluetooth_adresses;
                else
                    COMPREPLY=($( compgen -W 'master slave' -- "$cur" ));
                fi
            ;;
            cpt)
                _count_args;
                if [ $args -eq 2 ]; then
                    _bluetooth_adresses;
                else
                    _bluetooth_packet_types;
                fi
            ;;
            @(tpl|enc|clock))
                _count_args;
                if [ $args -eq 2 ]; then
                    _bluetooth_adresses;
                else
                    COMPREPLY=($( compgen -W '0 1' -- "$cur" ));
                fi
            ;;
        esac;
    fi
}
_hid2hci () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-h --help -q --quiet -0 --tohci -1 \
            --tohid' -- "$cur" ));
    fi
}
_iconv () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -@(f|t|-@(from|to)-code))
            COMPREPLY=($( compgen -W                 '$( iconv --list | sed -e "s@//@@;" )' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" = -* ]]; then
        COMPREPLY=($( compgen -W '--from-code -f --to-code -t --list
            --output -o --verbose' -- "$cur" ));
        return 0;
    fi
}
_id () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -g --group -G --groups -n --name\
            -r --real -u --user --help --version' -- "$cur" ));
    else
        COMPREPLY=($( compgen -u "$cur" ));
    fi
}
_identify () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-alpha -antialias -authenticate \
            -channel -colorspace -crop -debug -define -density \
            -depth -extract -format -fuzz -gamma -help -interlace \
            -interpolate -limit -list -log -monitor -ping -quiet \
            -regard-warnings -respect-parenthesis \
            -sampling-factor -seed -set -size -strip -units \
            -verbose -version -virtual-pixel' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+debug' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_ifupdown () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [ $COMP_CWORD -eq 1 ]; then
        _configured_interfaces;
        COMPREPLY=($(compgen -W '${COMPREPLY[@]}' -- "$cur"));
    fi;
    return 0
}
_import () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-adjoin -annotate -border -channel \
            -colors -colorspace -comment -compress -crop -debug \
            -define -delay -density -depth -descend -display \
            -dispose -dither -encipher -encoding -endian -filter \
            -format -frame -geometry -gravity -help -identify \
            -interlace -interpolate -label -limit -list -log \
            -monitor -monochrome -negate -page -pause -pointsize \
            -quality -quantize -quiet -regard-warnings -repage \
            -resize -respect-parenthesis -rotate -sampling-factor \
            -scene -screen -seed -set -silent -snaps -strip \
            -thumbnail -transparent -transparent-color -treedepth \
            -trim -type -verbose -version -virtual-pixel \
            -window' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+debug' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_info () 
{ 
    local cur i infopath;
    COMPREPLY=();
    cur=`_get_cword`;
    _expand || return 0;
    if [[ "$cur" == */* ]]; then
        _filedir;
        return 0;
    fi;
    infopath='/usr/share/info';
    if [ "${INFOPATH: -1:1}" == ':' ]; then
        infopath=${INFOPATH}${infopath};
    else
        if [ ${INFOPATH:+set} ]; then
            infopath=$INFOPATH;
        fi;
    fi;
    infopath=$infopath:;
    if [ -n "$cur" ]; then
        infopath="${infopath//://$cur* }";
    else
        infopath="${infopath//:// }";
    fi;
    COMPREPLY=($( eval command ls "$infopath" 2>/dev/null ));
    COMPREPLY=(${COMPREPLY[@]##*/?(:)});
    for ((i=0 ; i < ${#COMPREPLY[@]} ; ++i ))
    do
        if [ "${COMPREPLY[$i]}" == 'dir' ]; then
            unset COMPREPLY[$i];
        fi;
    done;
    COMPREPLY=(${COMPREPLY[@]%.@(gz|bz2|xz|lzma)});
    COMPREPLY=($( compgen -W '${COMPREPLY[@]%.*}' -- "${cur//\\\\/}" ));
    return 0
}
_insmod () 
{ 
    local cur prev modpath;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ $1 = "modprobe" ] && [ "${COMP_WORDS[1]}" = "-r" ]; then
        _installed_modules "$cur";
        return 0;
    fi;
    if [[ "$cur" == */* ]]; then
        _filedir '@(?(k)o?(.gz))';
        return 0;
    fi;
    if [ $COMP_CWORD -gt 1 ] && [[ "${COMP_WORDS[COMP_CWORD-1]}" != -* ]]; then
        COMPREPLY=($( compgen -W "$( /sbin/modinfo -p ${COMP_WORDS[1]} |                 cut -d: -f1 )" -- "$cur" ));
    else
        _modules $(uname -r);
    fi;
    return 0
}
_installed_alternatives () 
{ 
    local admindir;
    for i in alternatives dpkg/alternatives rpm/alternatives;
    do
        [ -d /var/lib/$i ] && admindir=/var/lib/$i && break;
    done;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == --admindir ]]; then
            admindir=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    COMPREPLY=($( compgen -W '$( command ls $admindir )' -- "$cur" ))
}
_installed_modules () 
{ 
    COMPREPLY=($( compgen -W "$( PATH="$PATH:/sbin" lsmod |         awk '{if (NR != 1) print $1}' )" -- "$1" ))
}
_invoke_rc_d () 
{ 
    local cur prev sysvdir services options valid_options;
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    [ -d /etc/rc.d/init.d ] && sysvdir=/etc/rc.d/init.d || sysvdir=/etc/init.d;
    services=($(echo $sysvdir/!(README*|*.sh|*.dpkg*|*.rpm@(orig|new|save))));
    services=(${services[@]#$sysvdir/});
    options=(--help --quiet --force --try-anyway --disclose-deny --query --no-fallback);
    if [[ ( $COMP_CWORD -eq 1 ) || ( "$prev" == --* ) ]]; then
        valid_options=($(         echo ${COMP_WORDS[@]} ${options[@]}         | tr " " "\n"         | sed -ne "/$( echo ${options[@]} | sed "s/ /\\\\|/g" )/p"         | sort | uniq -u         ));
        COMPREPLY=($( compgen -W '${valid_options[@]} ${services[@]}' -- "$cur" ));
    else
        if [ -x $sysvdir/$prev ]; then
            COMPREPLY=($( compgen -W '`sed -ne "y/|/ /; \
            s/^.*Usage:[ ]*[^ ]*[ ]*{*\([^}\"]*\).*$/\1/p" \
            $sysvdir/$prev`' -- "$cur" ));
        else
            COMPREPLY=();
        fi;
    fi;
    return 0
}
_iptables () 
{ 
    local cur prev table chain;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    chain='s/^Chain \([^ ]\+\).*$/\1/p';
    if [[ $COMP_LINE == *-t\ *filter* ]]; then
        table="-t filter";
    else
        if [[ $COMP_LINE == *-t\ *nat* ]]; then
            table="-t nat";
        else
            if [[ $COMP_LINE == *-t\ *mangle* ]]; then
                table="-t mangle";
            fi;
        fi;
    fi;
    _split_longopt;
    case "$prev" in 
        -*[AIDRPFXLZ])
            COMPREPLY=($( compgen -W '`iptables $table -nL | \
                sed -ne "s/^Chain \([^ ]\+\).*$/\1/p"`' -- "$cur" ))
        ;;
        -*t)
            COMPREPLY=($( compgen -W 'nat filter mangle' -- "$cur" ))
        ;;
        -j)
            if [ "$table" = "-t filter" -o "$table" = "" ]; then
                COMPREPLY=($( compgen -W 'ACCEPT DROP LOG ULOG REJECT \
                `iptables $table -nL | sed -ne "$chain" \
                -e "s/INPUT|OUTPUT|FORWARD|PREROUTING|POSTROUTING//"`' --                 "$cur" ));
            else
                if [ "$table" = "-t nat" ]; then
                    COMPREPLY=($( compgen -W 'ACCEPT DROP LOG ULOG REJECT \
                MIRROR SNAT DNAT MASQUERADE `iptables $table -nL | \
                sed -ne "$chain" -e "s/OUTPUT|PREROUTING|POSTROUTING//"`'                 -- "$cur" ));
                else
                    if [ "$table" = "-t mangle" ]; then
                        COMPREPLY=($( compgen -W 'ACCEPT DROP LOG ULOG REJECT \
                MARK TOS `iptables $table -nL | sed -ne "$chain" \
                -e "s/INPUT|OUTPUT|FORWARD|PREROUTING|POSTROUTING//"`' --                 "$cur" ));
                    fi;
                fi;
            fi
        ;;
        *)
            if [[ "$cur" == -* ]]; then
                COMPREPLY=($( compgen -W '-i -o -s -d -p -f -m --append \
                --delete --insert --replace --list --flush --zero --new \
                --delete-chain --policy --rename-chain --proto --source \
                --destination --in-interface --jump --match --numeric \
                --out-interface --table --verbose --line-numbers --exact \
                --fragment --modprobe --set-counters --version' -- "$cur"));
            fi
        ;;
    esac
}
_isql () 
{ 
    local cur;
    cur=`_get_cword`;
    [ -f "$ODBCINI" ] && COMPREPLY=($( grep \\["$cur" "$ODBCINI" | tr -d \\[\\] ))
}
_iwconfig () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        mode)
            COMPREPLY=($( compgen -W 'managed ad-hoc master \
                repeater secondary monitor' -- "$cur" ));
            return 0
        ;;
        essid)
            COMPREPLY=($( compgen -W 'on off any' -- "$cur" ));
            if [ -n "${COMP_IWLIST_SCAN:-}" ]; then
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -W                     "$( iwlist ${COMP_WORDS[1]} scan |                     awk -F '\"' '/ESSID/ {print $2}' )" -- "$cur" ));
            fi;
            return 0
        ;;
        nwid)
            COMPREPLY=($( compgen -W 'on off' -- "$cur" ));
            return 0
        ;;
        channel)
            COMPREPLY=($( compgen -W "$( iwlist ${COMP_WORDS[1]} channel |                 awk '/^[[:space:]]*Channel/ {print $2}' )" -- "$cur" ));
            return 0
        ;;
        freq)
            COMPREPLY=($( compgen -W "$( iwlist ${COMP_WORDS[1]} channel |                 awk '/^[[:space:]]*Channel/ {print $4\"G\"}')" -- "$cur" ));
            return 0
        ;;
        ap)
            COMPREPLY=($( compgen -W 'on off any' -- "$cur" ));
            if [ -n "${COMP_IWLIST_SCAN:-}" ]; then
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -W                     "$( iwlist ${COMP_WORDS[1]} scan |                     awk -F ': ' '/Address/ {print $2}' )" -- "$cur" ));
            fi;
            return 0
        ;;
        rate)
            COMPREPLY=($( compgen -W 'auto fixed' -- "$cur" ));
            COMPREPLY=("${COMPREPLY[@]}" $( compgen -W                 "$( iwlist ${COMP_WORDS[1]} rate |                 awk '/^[[:space:]]*[0-9]/ {print $1\"M\"}' )" -- "$cur" ));
            return 0
        ;;
        rts | frag)
            COMPREPLY=($( compgen -W 'auto fixed off' -- "$cur" ));
            return 0
        ;;
        key | enc)
            COMPREPLY=($( compgen -W 'off on open restricted' -- "$cur" ));
            return 0
        ;;
        power)
            COMPREPLY=($( compgen -W 'period timeout off on' -- "$cur" ));
            return 0
        ;;
        txpower)
            COMPREPLY=($( compgen -W 'off on auto' -- "$cur" ));
            return 0
        ;;
        retry)
            COMPREPLY=($( compgen -W 'limit lifetime' -- "$cur" ));
            return 0
        ;;
    esac;
    if [ $COMP_CWORD -eq 1 ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--help --version' -- "$cur" ));
        else
            _available_interfaces -w;
        fi;
    else
        COMPREPLY=($( compgen -W 'essid nwid mode freq channel sens mode \
            ap nick rate rts frag enc key power txpower commit' -- "$cur" ));
    fi
}
_iwlist () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ $COMP_CWORD -eq 1 ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--help --version' -- "$cur" ));
        else
            _available_interfaces -w;
        fi;
    else
        COMPREPLY=($( compgen -W 'scan scanning freq frequency \
            channel rate bit bitrate key enc encryption power \
            txpower retry ap accesspoint peers event' -- "$cur" ));
    fi
}
_iwpriv () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        roam)
            COMPREPLY=($( compgen -W 'on off' -- "$cur" ));
            return 0
        ;;
        port)
            COMPREPLY=($( compgen -W 'ad-hoc managed' -- "$cur" ));
            return 0
        ;;
    esac;
    if [ $COMP_CWORD -eq 1 ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--help --version' -- "$cur" ));
        else
            _available_interfaces -w;
        fi;
    else
        COMPREPLY=($( compgen -W '--all roam port' -- "$cur" ));
    fi
}
_iwspy () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [ $COMP_CWORD -eq 1 ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--help --version' -- "$cur" ));
        else
            _available_interfaces -w;
        fi;
    else
        COMPREPLY=($( compgen -W 'setthr getthr off' -- "$cur" ));
    fi
}
_jar () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [ $COMP_CWORD = 1 ]; then
        COMPREPLY=($( compgen -W 'c t x u' -- "$cur" ));
        return 0;
    fi;
    case "${COMP_WORDS[1]}" in 
        *c*f)
            _filedir
        ;;
        *f)
            _filedir '?([ejw]ar|zip|[EJW]AR|ZIP)'
        ;;
        *)
            _filedir
        ;;
    esac
}
_java () 
{ 
    local cur prev i;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    for ((i=1; i < $COMP_CWORD; i++))
    do
        case ${COMP_WORDS[$i]} in 
            -cp | -classpath)
                ((i++))
            ;;
            -*)

            ;;
            *)
                _filedir;
                return 0
            ;;
        esac;
    done;
    case $prev in 
        -@(cp|classpath))
            _java_path;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-client -hotspot -server -classic \
            -cp -classpath -D -verbose -verbose:class \
            -verbose:gc -version:jni -version \
            -showversion -? -help -X -jar \
            -ea -enableassertions -da -disableassertions \
            -esa -enablesystemassertions \
            -dsa -disablesystemassertions ' -- "$cur" ));
    else
        if [[ "$prev" == -jar ]]; then
            _filedir jar;
        else
            _java_classes;
        fi;
    fi
}
_java_classes () 
{ 
    local classpath i;
    _java_find_classpath;
    cur=${cur//.//};
    for i in ${classpath//:/ };
    do
        if [ -r $i ] && [[ "$i" == *.@(jar|zip) ]]; then
            if type zipinfo &>/dev/null; then
                COMPREPLY=("${COMPREPLY[@]}" $( zipinfo -1                     "$i" "$cur*" 2>/dev/null |                     grep '^[^$]*\.class$' ));
            else
                COMPREPLY=("${COMPREPLY[@]}" $( jar tf "$i"                     "$cur" | grep '^[^$]*\.class$' ));
            fi;
        else
            if [ -d $i ]; then
                i=${i%/};
                COMPREPLY=("${COMPREPLY[@]}" $( find "$i" -type f                 -maxdepth 1 -path "$i/$cur*.class" 2>/dev/null |                 grep -v "\\$" | sed -e "s|^$i/||" ));
            fi;
        fi;
    done;
    COMPREPLY=(${COMPREPLY[@]%.class});
    COMPREPLY=(${COMPREPLY[@]//\//.})
}
_java_find_classpath () 
{ 
    local i;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -@(cp|classpath) ]]; then
            classpath=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    [ -z "$classpath" ] && classpath=$CLASSPATH;
    [ -z "$classpath" ] && classpath=.
}
_java_find_sourcepath () 
{ 
    local i;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -sourcepath ]]; then
            sourcepath=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    if [ -z "$sourcepath" ]; then
        _java_find_classpath;
        sourcepath=$classpath;
    fi
}
_java_packages () 
{ 
    local sourcepath i;
    _java_find_sourcepath;
    cur=${cur//.//};
    for i in ${sourcepath//:/ };
    do
        if [ -d $i ]; then
            COMPREPLY=("${COMPREPLY[@]}" $( command ls -F -d                 $i/$cur* 2>/dev/null | sed -e 's|^'$i'/||' ));
        fi;
    done;
    COMPREPLY=($( echo "${COMPREPLY[@]}" | tr " " "\n" | grep "/$" ));
    COMPREPLY=(${COMPREPLY[@]%/});
    cur=${COMPREPLY[@]//\//.}
}
_java_path () 
{ 
    cur=${cur##*:};
    _filedir '@(jar|zip)'
}
_javac () 
{ 
    COMPREPLY=();
    local cur prev;
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        -d)
            _filedir -d;
            return 0
        ;;
        -@(classpath|bootclasspath|sourcepath|extdirs))
            _java_path;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-g -g:none -g:lines -g:vars\
            -g:source -O -nowarn -verbose -deprecation -classpath\
            -sourcepath -bootclasspath -extdirs -d -encoding -source\
            -target -help' -- "$cur" ));
    else
        _filedir java;
    fi
}
_javadoc () 
{ 
    COMPREPLY=();
    local cur prev;
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        -@(overview|helpfile|stylesheetfile))
            _filedir;
            return 0
        ;;
        -d)
            _filedir -d;
            return 0
        ;;
        -@(classpath|bootclasspath|docletpath|sourcepath|extdirs))
            _java_path;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-overview -public -protected \
            -package -private -help -doclet -docletpath \
            -sourcepath -classpath -exclude -subpackages \
            -breakiterator -bootclasspath -source -extdirs \
            -verbose -locale -encoding -J -d -use -version \
            -author -docfilessubdirs -splitindex \
            -windowtitle -doctitle -header -footer -bottom \
            -link -linkoffline -excludedocfilessubdir \
            -group -nocomment -nodeprecated -noqualifier \
            -nosince -nodeprecatedlist -notree -noindex \
            -nohelp -nonavbar -quiet -serialwarn -tag \
            -taglet -tagletpath -charset -helpfile \
            -linksource -stylesheetfile -docencoding' -- "$cur" ));
    else
        _filedir java;
        _java_packages;
    fi
}
_kernel_versions () 
{ 
    COMPREPLY=($( compgen -W '$( command ls /lib/modules )' -- "$cur" ))
}
_kill () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [ $COMP_CWORD -eq 1 ] && [[ "$cur" == -* ]]; then
        _signals;
    else
        _pids;
    fi
}
_killall () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [ $COMP_CWORD -eq 1 ] && [[ "$cur" == -* ]]; then
        _signals;
    else
        _pnames;
    fi;
    return 0
}
_known_hosts () 
{ 
    local options;
    COMPREPLY=();
    [ "$1" = -a ] || [ "$2" = -a ] && options=-a;
    [ "$1" = -c ] || [ "$2" = -c ] && options="$options -c";
    _known_hosts_real $options "$(_get_cword)"
}
_known_hosts_real () 
{ 
    local configfile flag prefix;
    local cur curd awkcur user suffix aliases hosts i host;
    local -a kh khd config;
    local OPTIND=1;
    while getopts "acF:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
        esac;
    done;
    [ $# -lt $OPTIND ] && echo "error: $FUNCNAME: missing mandatory argument CWORD";
    cur=${!OPTIND};
    let "OPTIND += 1";
    [ $# -ge $OPTIND ] && echo "error: $FUNCNAME("$@"): unprocessed arguments:" $(while [ $# -ge $OPTIND ]; do echo ${!OPTIND}; shift; done);
    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [ -n "$configfile" ]; then
        [ -r "$configfile" ] && config=("${config[@]}" "$configfile");
    else
        [ -r /etc/ssh/ssh_config ] && config=("${config[@]}" "/etc/ssh/ssh_config");
        [ -r "${HOME}/.ssh/config" ] && config=("${config[@]}" "${HOME}/.ssh/config");
        [ -r "${HOME}/.ssh2/config" ] && config=("${config[@]}" "${HOME}/.ssh2/config");
    fi;
    if [ ${#config[@]} -gt 0 ]; then
        local OIFS=$IFS IFS='
';
        local -a tmpkh;
        tmpkh=($( sed -ne 's/^[ \t]*\([Gg][Ll][Oo][Bb][Aa][Ll]\|[Uu][Ss][Ee][Rr]\)[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee]['"$'\t '"']*\(.*\)$/\2/p' "${config[@]}" | sort -u ));
        for i in "${tmpkh[@]//\"/}";
        do
            i=$( eval echo "$i" );
            [ -r "$i" ] && kh=("${kh[@]}" "$i");
        done;
        IFS=$OIFS;
    fi;
    if [ -z "$configfile" ]; then
        [ -r /etc/ssh/ssh_known_hosts ] && kh=("${kh[@]}" /etc/ssh/ssh_known_hosts);
        [ -r /etc/ssh/ssh_known_hosts2 ] && kh=("${kh[@]}" /etc/ssh/ssh_known_hosts2);
        [ -r /etc/known_hosts ] && kh=("${kh[@]}" /etc/known_hosts);
        [ -r /etc/known_hosts2 ] && kh=("${kh[@]}" /etc/known_hosts2);
        [ -d /etc/ssh2/knownhosts ] && khd=("${khd[@]}" /etc/ssh2/knownhosts/*pub);
    fi;
    if [ -z "$configfile" ]; then
        [ -r ~/.ssh/known_hosts ] && kh=("${kh[@]}" ~/.ssh/known_hosts);
        [ -r ~/.ssh/known_hosts2 ] && kh=("${kh[@]}" ~/.ssh/known_hosts2);
        [ -d ~/.ssh2/hostkeys ] && khd=("${khd[@]}" ~/.ssh2/hostkeys/*pub);
    fi;
    if [ ${#kh[@]} -gt 0 -o ${#khd[@]} -gt 0 -o -n "$configfile" ]; then
        awkcur=${cur//\//\\\/};
        awkcur=${awkcur//\./\\\.};
        curd=$awkcur;
        if [[ "$awkcur" == [0-9]*.* ]]; then
            awkcur="^$awkcur.*";
        else
            if [[ "$awkcur" == [0-9]* ]]; then
                awkcur="^$awkcur.*\.";
            else
                if [ -z "$awkcur" ]; then
                    awkcur="[a-z.]";
                else
                    awkcur="^$awkcur";
                fi;
            fi;
        fi;
        if [ ${#kh[@]} -gt 0 ]; then
            COMPREPLY=($( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {for (i=1; i<=2; ++i) { \
            gsub(" .*$", "", $i); \
            gsub("[\\[\\]]", "", $i); \
            gsub(":[0-9]+$", "", $i); \
            if ($i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ));
        fi;
        if [ ${#khd[@]} -gt 0 ]; then
            for i in "${khd[@]}";
            do
                if [[ "$i" == *key_22_$awkcurd*.pub ]] && [ -r "$i" ]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY=("${COMPREPLY[@]}" $host);
                fi;
            done;
        fi;
        if [ ${#config[@]} -gt 0 ] && [ -n "$aliases" ]; then
            local host_aliases=$( sed -ne 's/^[ \t]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\?['"$'\t '"']\+\([^#*?]*\)\(#.*\)\?$/\2/p' "${config[@]}" );
            hosts=$( compgen -W "$host_aliases" -- "$cur" );
            COMPREPLY=("${COMPREPLY[@]}" $hosts);
        fi;
        for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
        do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [ -n "${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1}" ]; then
        COMPREPLY=("${COMPREPLY[@]}" $( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ));
    fi;
    return 0
}
_l2ping () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        -i)
            _bluetooth_devices;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-i -s -c -t -f -r' -- "$cur" ));
    else
        _bluetooth_adresses;
    fi
}
_lastlog () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -b | --before | -h | --help | -t | --time)
            return 0
        ;;
        -u | --user)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b --before -h --help -t --time \
            -u --user' -- "$cur" ));
        return 0;
    fi
}
_lftp () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [ $COMP_CWORD -eq 1 ] && [ -f ~/.lftp/bookmarks ]; then
        COMPREPLY=($( compgen -W '$( sed -ne "s/^\(.*\)''	''.*$/\1/p" \
            ~/.lftp/bookmarks )' -- "$cur" ));
    fi;
    return 0
}
_longopt () 
{ 
    local cur prev;
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if _split_longopt; then
        case "$prev" in 
            *[Dd][Ii][Rr]*)
                _filedir -d
            ;;
            *[Ff][Ii][Ll][Ee]*)
                _filedir
            ;;
        esac;
        return 0;
    fi;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W "$( $1 --help 2>&1 | sed -e '/--/!d'             -e 's/.*\(--[-A-Za-z0-9]\+\).*/\1/' |sort -u )"            -- "$cur" ));
    else
        if [[ "$1" == rmdir ]]; then
            _filedir -d;
        else
            _filedir;
        fi;
    fi
}
_look () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [ $COMP_CWORD = 1 ]; then
        COMPREPLY=($( compgen -W '$(look "$cur" 2>/dev/null)' ));
    fi
}
_lzma () 
{ 
    local cur prev xspec;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-c -d -f -h -k -L -q -s \
            -v -V -z -1 -2 -3 -4 -5 -6 -7 -8 -9 \
            --help --decompress --compress --keep --force \
            --test --stdout --quiet --verbose --license \
            --version --small --fast --best --text' -- "$cur" ));
        return 0;
    fi;
    local IFS='	
';
    xspec="*.lzma";
    if [[ "$prev" == --* ]]; then
        [[ "$prev" == --decompress || "$prev" == --list || "$prev" == --test ]] && xspec="!"$xspec;
        [[ "$prev" == --compress ]] && xspec=;
    else
        if [[ "$prev" == -* ]]; then
            [[ "$prev" == -*[dt]* ]] && xspec="!"$xspec;
            [[ "$prev" == -*z* ]] && xspec=;
        fi;
    fi;
    _expand || return 0;
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_make () 
{ 
    local file makef makef_dir="." makef_inc cur prev i split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case $prev in 
        -@(f|o|W|-@(?(make|old-|new-)file|assume-@(old|new)|what-if)))
            _filedir;
            return 0
        ;;
        -I | -C | --directory | --include-dir)
            _filedir -d;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b -m -B -C -d -e -f -h -i -I\
            -j -l -k -n -o -p -q -r -R - s -S -t -v -w -W \
            --always-make --directory --debug \
            --environment-overrides --file --makefile --help \
            --ignore-errors --include-dir --jobs --load-average \
            --max-load --keep-going --just-print --dry-run \
            --recon --old-file --assume-old --print-data-base \
            --question --no-builtin-rules --no-builtin-variables \
            --silent --quiet --no-keep-goind --stop --touch \
            --version --print-directory --no-print-directory \
            --what-if --new-file --assume-new \
            --warn-undefined-variables' -- "$cur" ));
    else
        for ((i=0; i < ${#COMP_WORDS[@]}; i++ ))
        do
            if [[ ${COMP_WORDS[i]} == -C ]]; then
                eval makef_dir=${COMP_WORDS[i+1]};
                break;
            fi;
        done;
        for ((i=0; i < ${#COMP_WORDS[@]}; i++ ))
        do
            if [[ ${COMP_WORDS[i]} == -f ]]; then
                eval makef=${COMP_WORDS[i+1]};
                break;
            fi;
        done;
        [ -n "$makef" ] && makef="-f ${makef}";
        [ -n "$makef_dir" ] && makef_dir="-C ${makef_dir}";
        COMPREPLY=($( compgen -W "$( make -qp $makef $makef_dir 2>/dev/null |             awk -F':' '/^[a-zA-Z0-9][^$#\/\t=]*:([^=]|$)/ \
            {split($1,A,/ /);for(i in A)print A[i]}' )"             -- "$cur" ));
    fi
}
_man () 
{ 
    local cur i prev sect manpath manext mansect uname;
    manext="@([0-9lnp]|[0-9][px]|man|3pm)?(.@(gz|bz2|lzma))";
    mansect="@([0-9lnp]|[0-9][px]|3pm)";
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$prev" == -l ]]; then
        _filedir $manext;
        return 0;
    fi;
    _expand || return 0;
    if [[ "$cur" == */* ]]; then
        _filedir $manext;
        return 0;
    fi;
    uname=$( uname -s );
    if [[ $uname == @(Linux|GNU|GNU/*|FreeBSD|Cygwin|CYGWIN_*) ]]; then
        manpath=$( manpath 2>/dev/null || command man --path );
    else
        manpath=$MANPATH;
    fi;
    if [ -z "$manpath" ]; then
        COMPREPLY=($( compgen -c -- "$cur" ));
        return 0;
    fi;
    [[ "$prev" == $mansect ]] && sect=$prev || sect='*';
    manpath=$manpath:;
    if [ -n "$cur" ]; then
        manpath="${manpath//://*man$sect/$cur* } ${manpath//://*cat$sect/$cur* }";
    else
        manpath="${manpath//://*man$sect/ } ${manpath//://*cat$sect/ }";
    fi;
    COMPREPLY=($( eval command ls "$manpath" 2>/dev/null ));
    COMPREPLY=(${COMPREPLY[@]##*/?(:)});
    COMPREPLY=(${COMPREPLY[@]%.@(gz|bz2|lzma)});
    COMPREPLY=($( compgen -W '${COMPREPLY[@]%.*}' -- "${cur//\\\\/}" ));
    if [[ "$prev" != $mansect ]]; then
        local start=${#COMPREPLY[@]};
        _filedir $manext;
        for ((i=$start; i < ${#COMPREPLY[@]}; i++ ))
        do
            [[ ${COMPREPLY[i]} == */* ]] || COMPREPLY[i]=./${COMPREPLY[i]};
        done;
    fi;
    return 0
}
_mii_tool () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case $prev in 
        -F | --force)
            COMPREPLY=($( compgen -W '100baseTx-FD 100baseTx-HD \
                10baseT-FD 10baseT-HD' -- "$cur" ));
            return 0
        ;;
        -A | --advertise)
            COMPREPLY=($( compgen -W '100baseT4 100baseTx-FD 100baseTx-HD \
                10baseT-FD 10baseT-HD' -- "$cur" ));
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-v --verbose -V --version -R \
            --reset -r --restart -w  --watch -l --log -A \
            --advertise -F --force' -- "$cur" ));
    else
        _available_interfaces -a;
    fi
}
_mkisofs () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -@(o|abstract|biblio|check-session|copyright|log-file|root-info|prep-boot|*-list))
            _filedir;
            return 0
        ;;
        -*-charset)
            COMPREPLY=($( compgen -W '$( mkisofs -input-charset \
                    help 2>&1 | tail -n +3 )' -- "$cur" ));
            return 0
        ;;
        -uid)
            _uids;
            return 0
        ;;
        -gid)
            _gids;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-abstract -A -allow-lowercase \
            -allow-multidot -biblio -cache-inodes \
            -no-cache-inodes -b -eltorito-alt-boot -B -G \
            -hard-disk-boot -no-emul-boot -no-boot \
            -boot-load-seg -boot-load-size \
            -boot-info-table -C -c -check-oldname \
            -check-session -copyright -d -D -dir-mode \
            -dvd-video -f -file-mode -gid -gui \
            -graft-points -hide -hide-list -hidden \
            -hidden-list -hide-joliet -hide-joliet-list \
            -hide-joliet-trans-tbl -hide-rr-moved \
            -input-charset -output-charset -iso-level -J \
            -joliet-long -jcharset -l -L -log-file -m \
            -exclude-list -max-iso9660-filenames -M -N \
            -new-dir-mode -nobak -no-bak -force-rr -no-rr \
            -no-split-symlink-components \
            -no-split-symlink-fields -o -pad -no-pad \
            -path-list -P -p -print-size -quiet -R -r \
            -relaxed-filenames -sort -split-output \
            -stream-media-size -stream-file-name -sysid -T\
            -table-name -ucs-level -udf -uid \
            -use-fileversion -U -no-iso-translate -V \
            -volset -volset-size -volset-seqno -v -x -z \
            -hfs -apple -map -magic -hfs-creator \
            -hfs-type -probe -no-desktop -mac-name \
            -boot-hfs-file -part -auto -cluster-size \
            -hide-hfs -hide-hfs-list -hfs-volid \
            -icon-position -root-info -prep-boot \
            -input-hfs-charset -output-hfs-charset \
            -hfs-unlock -hfs-bless -hfs-parms --cap \
            --netatalk --double --ethershare --ushare \
            --exchange --sgi --xinet --macbin --single \
            --dave --sfm --osx-double --osx-hfs' -- "$cur" ));
    else
        _filedir;
    fi
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($( compgen -W "$( command ls -R $modpath |         sed -ne 's/^\(.*\)\.k\?o\(\|.gz\)$/\1/p' )" -- "$cur" ))
}
_mogrify () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-adaptive-blur -adaptive-resize \
            -adaptive-sharpen -adjoin -affine -alpha -annotate \
            -antialias -attenuate -authenticate -auto-orient \
            -background -bias -black-point-compensation \
            -black-threshold -blue-primary -blur -border \
            -bordercolor -caption -channel -charcoal -chop -clip \
            -clip-mask -clip-path -clut -colorize -colors \
            -colorspace -comment -compose -compress -contrast \
            -contrast-stretch -convolve -cycle -debug -decipher \
            -define -delay -density -depth -despeckle -display \
            -dispose -distort -dither -draw -edge -emboss \
            -encipher -encoding -endian -enhance -equalize \
            -evaluate -extent -extract -family -fill -filter \
            -flip -floodfill -flop -font -format -frame -fuzz \
            -gamma -gaussian-blur -geometry -gravity \
            -green-primary -help -identify -implode -intent \
            -interlace -interpolate -label -lat -layers -level \
            -limit -linear-stretch -liquid-rescale -list -log \
            -loop -mask -mattecolor -median -modulate -monitor \
            -monochrome -motion-blur -negate -noise -normalize \
            -opaque -ordered-dither -orient -page -paint -path \
            -ping -pointsize -polaroid -posterize -preview -print \
            -profile -quality -quantize -quiet -radial-blur \
            -raise -random-threshold -recolor -red-primary \
            -regard-warnings -region -render -repage -resample \
            -resize -roll -rotate -sample -sampling-factor -scale \
            -scene -seed -segment -sepia-tone -set -shade -shadow \
            -sharpen -shave -shear -sigmoidal-contrast -size \
            -sketch -solarize -splice -spread -stretch -strip \
            -stroke -strokewidth -style -swirl -taint -texture \
            -threshold -thumbnail -tile -tile-offset -tint \
            -transform -transparent -transparent-color -transpose \
            -transverse -treedepth -trim -type -undercolor \
            -unique-colors -units -unsharp -verbose -version \
            -view -vignette -virtual-pixel -wave -weight \
            -white-point -white-threshold' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+compress +contrast +debug +dither \
            +endian +gamma +label +map +mask +matte +negate +page \
            +raise' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_montage () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-adjoin -affine -alpha \
            -authenticate -background -blue-primary -blur -border \
            -bordercolor -borderwidth -caption -channel -clone \
            -coalesce -colors -colorspace -comment -compose \
            -compress -crop -debug -define -density -depth \
            -display -dispose -dither -draw -encoding -endian \
            -extract -fill -filter -flatten -flip -flop -font \
            -format -frame -gamma -geometry -gravity \
            -green-primary -help -identify -interlace \
            -interpolate -label -limit -list -log -mattecolor \
            -mode -monitor -monochrome -origin -page -pointsize \
            -polaroid -profile -quality -quantize -quiet \
            -red-primary -regard-warnings -repage -resize \
            -respect-parenthesis -rotate -sampling-factor -scenes \
            -seed -set -shadow -size -strip -stroke -texture \
            -thumbnail -tile -title -transform -transparent \
            -transparent-color -treedepth -trim -type -units \
            -verbose -version -virtual-pixel \
            -white-point' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+adjoin +compress +debug +dither \
            +endian +gamma +label +matte +page' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_mount () 
{ 
    local cur i sm host prev;
    COMPREPLY=();
    cur=`_get_cword`;
    [[ "$cur" == \\ ]] && cur="/";
    prev=${COMP_WORDS[COMP_CWORD-1]};
    for i in {,/usr}/{,s}bin/showmount;
    do
        [ -x $i ] && sm=$i && break;
    done;
    if [ -n "$sm" ] && [[ "$cur" == *:* ]]; then
        COMPREPLY=($( compgen -W "$( $sm -e ${cur%%:*} | sed 1d |                 awk '{print $1}' )" -- "$cur" ));
    else
        if [[ "$cur" == //* ]]; then
            host=${cur#//};
            host=${host%%/*};
            if [ -n "$host" ]; then
                COMPREPLY=($( compgen -P "//$host" -W                     "$( smbclient -d 0 -NL $host 2>/dev/null |
                    sed -ne '/^['"$'\t '"']*Sharename/,/^$/p' |
                    sed -ne '3,$s|^[^A-Za-z]*\([^'"$'\t '"']*\).*$|/\1|p' )"                     -- "${cur#//$host}" ));
            fi;
        else
            if [ -r /etc/vfstab ]; then
                COMPREPLY=($( compgen -W "$( awk '! /^[ \t]*#/ {if ($3 ~ /\//) print $3}' /etc/vfstab )" -- "$cur" ));
            else
                if [ ! -e /etc/fstab ]; then
                    COMPREPLY=($( compgen -W "$( mount | awk '! /^[ \t]*#/ {if ($3 ~ /\//) print $3}' )" -- "$cur" ));
                else
                    if [ $prev = -L ]; then
                        COMPREPLY=($( compgen -W '$(sed -ne "s/^[[:space:]]*LABEL=\([^[:space:]]*\).*/\1/p" /etc/fstab )' -- "$cur" ));
                    else
                        if [ $prev = -U ]; then
                            COMPREPLY=($( compgen -W '$(sed -ne "s/^[[:space:]]*UUID=\([^[:space:]]*\).*/\1/p" /etc/fstab )' -- "$cur" ));
                        else
                            COMPREPLY=($( compgen -W "$( awk '! /^[ \t]*#/ {if ($2 ~ /\//) print $2}' /etc/fstab )" -- "$cur" ));
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi;
    return 0
}
_newgrp () 
{ 
    COMPREPLY=();
    if [[ "`_get_cword`" == "-" ]]; then
        COMPREPLY=(-);
    fi
}
_newusers () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -c | --crypt)
            COMPREPLY=($( compgen -W 'DES MD5 NONE SHA256 SHA512'                 -- "$cur" ));
            return 0
        ;;
        -s | --sha-rounds)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-c --crypt-method --r --system \
            -s --sha-rounds' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_nslookup () 
{ 
    local cur;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]#-};
    COMPREPLY=($( compgen -P '-' -W 'all class= debug d2 domain= srchlist= \
        defname search port= querytype= type= recurse retry root timeout vc \
        ignoretc' -- "$cur" ))
}
_ntpdate () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        -k)
            _filedir;
            return 0
        ;;
        -U)
            COMPREPLY=($( compgen -u "$cur"  ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-4 -6 -b -B -d -Q -q -s -u -v -a\
            -e -k -p -o -r -t' -- "$cur" ));
    else
        _known_hosts_real "$cur";
    fi
}
_ooexp_ () 
{ 
    local c=${COMP_WORDS[COMP_CWORD]};
    local a="${COMP_LINE}";
    local e s g=0 cd dc t="";
    local IFS;
    shopt -q extglob && g=1;
    test $g -eq 0 && shopt -s extglob;
    cd='*-?(c)d*';
    dc='*-d?(c)*';
    case "${1##*/}" in 
        oobase)
            e='!*.+(odb|ODB)'
        ;;
        oofromtemplate)
            e='!*.+(stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX)'
        ;;
        oodraw)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG)'
        ;;
        oocalc)
            e='!*.+(sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX)'
        ;;
        oomath)
            e='!*.+(sxm|SXM|smf|SMF|mml|MML|odf|ODF)'
        ;;
        ooweb)
            e='!*.+(htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        ooffice)
            e='!*.+(sxd|SXD|std|STD|dxf|DXF|emf|EMF|eps|EPS|met|MET|pct|PCT|sgf|SGF|sgv|SGV|sda|SDA|sdd|SDD|vor|VOR|svm|SVM|wmf|WMF|bmp|BMP|gif|GIF|jpg|JPG|jpeg|JPEG|jfif|JFIF|fif|FIF|jpe|JPE|pcd|PCD|pcx|PCX|pgm|PGM|png|PNG|ppm|PPM|psd|PSD|ras|RAS|tga|TGA|tif|TIF|tiff|TIFF|xbm|XBM|xpm|XPM|odg|ODG|otg|OTG|fodg|FODG|odc|ODC|odi|ODI|sds|SDS|wpg|WPG|svg|SVG|doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxm|SXM|smf|SMF|mml|MML|odf|ODF|sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX|odb|ODB|sxc|SXC|stc|STC|dif|DIF|dbf|DBF|xls|XLS|xlw|XLW|xlt|XLT|rtf|RTF|sdc|SDC|vor|VOR|slk|SLK|txt|TXT|htm|HTM|html|HTML|wk1|WK1|wks|WKS|123|123|xml|XML|ods|ODS|ots|OTS|fods|FODS|csv|CSV|xlsb|XLSB|xlsm|XLSM|xlsx|XLSX|xltm|XLTM|xltx|XLTX|sxg|SXG|odm|ODM|sgl|SGL|stw|STW|dot|DOT|vor|VOR|stc|STC|xlt|XLT|sti|STI|pot|POT|std|STD|stw|STW|dotm|DOTM|dotx|DOTX|potm|POTM|potx|POTX|xltm|XLTM|xltx|XLTX|htm|HTM|html|HTML|stw|STW|txt|TXT|vor|VOR|oth|OTH)'
        ;;
        oowriter)
            e='!*.+(doc|DOC|dot|DOT|rtf|RTF|sxw|SXW|stw|STW|sdw|SDW|vor|VOR|txt|TXT|htm?|HTM?|xml|XML|wp|WP|wpd|WPD|wps|WPS|odt|ODT|ott|OTT|fodt|FODT|docm|DOCM|docx|DOCX|dotm|DOTM|dotx|DOTX|sxg|SXG|odm|ODM|sgl|SGL)'
        ;;
        ooimpress)
            e='!*.+(sxi|SXI|sti|STI|ppt|PPT|pps|PPS|pot|POT|sxd|SXD|sda|SDA|sdd|SDD|sdp|SDP|vor|VOR|cgm|CGM|odp|ODP|otp|OTP|fodp|FODP|ppsm|PPSM|ppsx|PPSX|pptm|PPTM|pptx|PPTX|potm|POTM|potx|POTX)'
        ;;
        unopkg)
            e='!*.+(oxt|OXT)'
        ;;
        *)
            e='!*'
        ;;
    esac;
    case "$(complete -p ${1##*/} 2> /dev/null)" in 
        *-d*)

        ;;
        *)
            s="-S/"
        ;;
    esac;
    IFS='
';
    case "$c" in 
        \$\(*\))
            eval COMPREPLY=\(${c}\)
        ;;
        \$\(*)
            COMPREPLY=($(compgen -c -P '$(' -S ')'  -- ${c#??}))
        ;;
        \`*\`)
            eval COMPREPLY=\(${c}\)
        ;;
        \`*)
            COMPREPLY=($(compgen -c -P '\`' -S '\`' -- ${c#?}))
        ;;
        \$\{*\})
            eval COMPREPLY=\(${c}\)
        ;;
        \$\{*)
            COMPREPLY=($(compgen -v -P '${' -S '}'  -- ${c#??}))
        ;;
        \$*)
            COMPREPLY=($(compgen -v -P '$'          -- ${c#?}))
        ;;
        \~*/*)
            COMPREPLY=($(compgen -f -X "$e"         -- ${c}))
        ;;
        \~*)
            COMPREPLY=($(compgen -u ${s}	 	-- ${c}))
        ;;
        *@*)
            COMPREPLY=($(compgen -A hostname -P '@' -S ':' -- ${c#*@}))
        ;;
        *[*?[]*)
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *[?*+\!@]\(*\)*)
            if test $g -eq 0; then
                COMPREPLY=($(compgen -f -X "$e" -- $c));
                test $g -eq 0 && shopt -u extglob;
                return;
            fi;
            COMPREPLY=($(compgen -G "${c}"))
        ;;
        *)
            if test "$c" = ".."; then
                COMPREPLY=($(compgen -d -X "$e" -S / ${_nosp} -- $c));
            else
                for s in $(compgen -f -X "$e" -- $c);
                do
                    if test -d $s; then
                        COMPREPLY=(${COMPREPLY[@]} $(compgen -f -X "$e" -S / -- $s));
                    else
                        if test -z "$t"; then
                            COMPREPLY=(${COMPREPLY[@]} $s);
                        else
                            case "$(file -b $s 2> /dev/null)" in 
                                $t)
                                    COMPREPLY=(${COMPREPLY[@]} $s)
                                ;;
                            esac;
                        fi;
                    fi;
                done;
            fi
        ;;
    esac;
    test $g -eq 0 && shopt -u extglob
}
_openssl () 
{ 
    local cur prev commands command options formats;
    COMPREPLY=();
    cur=`_get_cword`;
    commands='asn1parse ca ciphers crl crl2pkcs7 dgst dh dhparam dsa \
        dsaparam ec ecparam enc engine errstr gendh gendsa genrsa \
        nseq ocsp passwd pkcs12 pkcs7 pkcs8 prime rand req rsa \
        rsautl s_client s_server s_time sess_id smime speed spkac \
        verify version x509 md2 md4 md5 rmd160 sha sha1 aes-128-cbc \
        aes-128-ecb aes-192-cbc aes-192-ecb aes-256-cbc aes-256-ecb \
        base64 bf bf-cbc bf-cfb bf-ecb bf-ofb camellia-128-cbc \
        camellia-128-ecb camellia-192-cbc camellia-192-ecb \
        camellia-256-cbc camellia-256-ecb cast cast-cbc cast5-cbc \
        cast5-cfb cast5-ecb cast5-ofb des des-cbc des-cfb des-ecb \
        des-ede des-ede-cbc des-ede-cfb des-ede-ofb des-ede3 \
        des-ede3-cbc des-ede3-cfb des-ede3-ofb des-ofb des3 desx rc2 \
        rc2-40-cbc rc2-64-cbc rc2-cbc rc2-cfb rc2-ecb rc2-ofb rc4 \
        rc4-40';
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$commands" -- "$cur" ));
    else
        command=${COMP_WORDS[1]};
        prev=${COMP_WORDS[COMP_CWORD-1]};
        case $prev in 
            -@(CA|CAfile|CAkey|CAserial|cert|certfile|config|content|dcert|dkey|dhparam|extfile|in|inkey|kfile|key|keyout|out|oid|prvrify|rand|recip|revoke|sess_in|sess_out|spkac|sign|signkey|signer|signature|ss_cert|untrusted|verify))
                _filedir;
                return 0
            ;;
            -@(outdir|CApath))
                _filedir -d;
                return 0
            ;;
            -@(name|crlexts|extensions))
                _openssl_sections;
                return 0
            ;;
            -@(in|out|key|cert|CA|CAkey|dkey|dcert)form)
                formats='DER PEM';
                case $command in 
                    x509)
                        formats="$formats NET"
                    ;;
                    smime)
                        formats="$formats SMIME"
                    ;;
                esac;
                COMPREPLY=($( compgen -W "$formats" -- "$cur" ));
                return 0
            ;;
            -connect)
                _known_hosts_real "$cur";
                return 0
            ;;
            -starttls)
                COMPREPLY=($( compgen -W 'smtp pop3 imap ftp'                     -- "$cur" ));
                return 0
            ;;
            -cipher)
                COMPREPLY=($( compgen -W "$(openssl ciphers |                     tr ':' '\n')" -- "$cur" ));
                return 0
            ;;
        esac;
        if [[ "$cur" == -* ]]; then
            case $command in 
                asn1parse)
                    options='-inform -in -out -noout -offset -length -i -oid \
                        -strparse'
                ;;
                ca)
                    options='-verbose -config -name -gencrl -revoke \
                        -crl_reason -crl_hold -crl_compromise \
                        -crl_CA_compromise -crldays -crlhours -crlexts \
                        -startdate -enddate -days -md -policy -keyfile -key \
                        -passin -cert -selfsig -in -out -notext -outdir \
                        -infiles -spkac -ss_cert -preserveDN -noemailDN \
                        -batch -msie_hack -extensions -extfile -engine \
                        -subj -utf8 -multivalue-rdn'
                ;;
                ciphers)
                    options='-v -ssl2 -ssl3 -tls1'
                ;;
                crl)
                    options='-inform -outform -text -in -out -noout -hash \
                        -issuer -lastupdate -nextupdate -CAfile -CApath'
                ;;
                crl2pkcs7)
                    options='-inform -outform -in -out -print_certs'
                ;;
                dgst)
                    options='-md5 -md4 -md2 -sha1 -sha -mdc2 -ripemd160 -dss1 \
                        -c -d -hex -binary -out -sign -verify -prverify \
                        -signature'
                ;;
                dsa)
                    options='-inform -outform -in -passin -out -passout -des \
                        -des3 -idea -text -noout -modulus -pubin -pubout'
                ;;
                dsaparam)
                    options='-inform -outform -in -out -noout -text -C -rand \
                        -genkey'
                ;;
                enc)
                    options='-ciphername -in -out -pass -e -d -a -A -k -kfile \
                        -S -K -iv -p -P -bufsize -debug'
                ;;
                dhparam)
                    options='-inform -outform -in -out -dsaparam -noout -text \
                        -C -2 -5 -rand'
                ;;
                gendsa)
                    options='-out -des -des3 -idea -rand'
                ;;
                genrsa)
                    options='-out -passout -des -des3 -idea -f4 -3 -rand'
                ;;
                pkcs7)
                    options='-inform -outform -in -out -print_certs -text \
                        -noout'
                ;;
                rand)
                    options='-out -rand -base64'
                ;;
                req)
                    options='-inform -outform -in -passin -out -passout -text \
                        -noout -verify -modulus -new -rand -newkey -newkey \
                        -nodes -key -keyform -keyout -md5 -sha1 -md2 -mdc2 \
                        -config -x509 -days -asn1-kludge -newhdr -extensions \
                        -reqexts section'
                ;;
                rsa)
                    options='-inform -outform -in -passin -out -passout \
                        -sgckey -des -des3 -idea -text -noout -modulus -check \
                        -pubin -pubout -engine'
                ;;
                rsautl)
                    options='-in -out -inkey -pubin -certin -sign -verify \
                        -encrypt -decrypt -pkcs -ssl -raw -hexdump -asn1parse'
                ;;
                s_client)
                    options='-connect -verify -cert -certform -key -keyform \
                        -pass -CApath -CAfile -reconnect -pause -showcerts \
                        -debug -msg -nbio_test -state -nbio -crlf -ign_eof \
                        -quiet -ssl2 -ssl3 -tls1 -no_ssl2 -no_ssl3 -no_tls1 \
                        -bugs -cipher -starttls -engine -tlsextdebug \
                        -no_ticket -sess_out -sess_in -rand'
                ;;
                s_server)
                    options='-accept -context -verify -Verify -crl_check \
                        -crl_check_all -cert -certform -key -keyform -pass \
                        -dcert -dcertform -dkey -dkeyform -dpass -dhparam \
                        -nbio -nbio_test -crlf -debug -msg -state -CApath \
                        -CAfile -nocert -cipher -quiet -no_tmp_rsa -ssl2 \
                        -ssl3 -tls1 -no_ssl2 -no_ssl3 -no_tls1 -no_dhe \
                        -bugs -hack -www -WWW -HTTP -engine -tlsextdebug \
                        -no_ticket -id_prefix -rand'
                ;;
                s_time)
                    options='-connect -www -cert -key -CApath -CAfile -reuse \
                        -new -verify -nbio -time -ssl2 -ssl3 -bugs -cipher'
                ;;
                sess_id)
                    options='-inform -outform -in -out -text -noout -context \
                        ID'
                ;;
                smime)
                    options='-encrypt -decrypt -sign -verify -pk7out -des \
                        -des3 -rc2-40 -rc2-64 -rc2-128 -aes128 -aes192 -aes256 \
                        -in -certfile -signer -recip -inform -passin -inkey \
                        -out -outform -content -to -from -subject -text -rand'
                ;;
                speed)
                    options='-engine'
                ;;
                verify)
                    options='-CApath -CAfile -purpose -untrusted -help \
                        -issuer_checks -verbose -certificates'
                ;;
                x509)
                    options='-inform -outform -keyform -CAform -CAkeyform -in \
                        -out -serial -hash -subject-hash -issuer_hash -subject \
                        -issuer -nameopt -email -startdate -enddate -purpose \
                        -dates -modulus -fingerprint -alias -noout -trustout \
                        -clrtrust -clrreject -addtrust -addreject -setalias \
                        -days -set_serial -signkey -x509toreq -req -CA -CAkey \
                        -CAcreateserial -CAserial -text -C -md2 -md5 -sha1 \
                        -mdc2 -clrext -extfile -extensions -engine'
                ;;
                @(md5|md4|md2|sha1|sha|mdc2|ripemd160))
                    options='-c -d'
                ;;
            esac;
            COMPREPLY=($( compgen -W "$options" -- "$cur" ));
        else
            if [[ "$command" == speed ]]; then
                COMPREPLY=($( compgen -W 'md2 mdc2 md5 hmac sha1 rmd160 \
                    idea-cbc rc2-cbc rc5-cbc bf-cbc des-cbc des-ede3 rc4 \
                    rsa512 rsa1024 rsa2048 rsa4096 dsa512 dsa1024 dsa2048 idea \
                    rc2 des rsa blowfish' -- "$cur" ));
            else
                _filedir;
            fi;
        fi;
    fi
}
_openssl_sections () 
{ 
    local config f;
    for ((i=2; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == -config ]]; then
            config=${COMP_WORDS[i+1]};
            break;
        fi;
    done;
    if [ -z "$config" ]; then
        for f in /etc/ssl/openssl.cnf /etc/pki/tls/openssl.cnf /usr/share/ssl/openssl.cnf;
        do
            [ -f $f ] && config=$f && break;
        done;
    fi;
    [ ! -f "$config" ] && return 0;
    COMPREPLY=($( compgen -W "$( awk '/\[.*\]/ {print $2}' $config )"         -- "$cur" ))
}
_parse_help () 
{ 
    local cmd;
    cmd=$1;
    $cmd --help | grep --color=auto -- "^[[:space:]]*-" | tr "," " " | awk '{print $1; if ($2 ~ /-.*/) { print $2 } }' | sed -e "s:=.*::g"
}
_passwd () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -n | -x | -w | -i | -\? | --help | --usage)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-k -l --stdin -u -d -n -x -w -i -S \
            -? --help --usage' -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -u -- "$cur" ))
}
_pci_ids () 
{ 
    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W     "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ))
}
_perl () 
{ 
    local cur prev prefix temp;
    local optPrefix optSuffix;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prefix="";
    if [[ "$cur" == -?* ]]; then
        temp=$cur;
        prev=${temp:0:2};
        cur=${temp:2};
        optPrefix=-P$prev;
        optSuffix=-S/;
        prefix=$prev;
    fi;
    case "$prev" in 
        -I | -x)
            local IFS='	
';
            COMPREPLY=($( compgen -d $optPrefix $optSuffix -- "$cur" ));
            return 0
        ;;
        -m | -M)
            _perlmodules;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-C -s -T -u -U -W -X -h -v -V -c -w -d \
		    -D -p -n -a -F -l -0 -I -m -M -P -S -x -i -e ' -- "$cur" ));
    else
        _filedir;
    fi
}
_perldoc () 
{ 
    local cur prev prefix temp;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    prefix="";
    if [[ "$cur" == -?* ]]; then
        temp=$cur;
        prev=${temp:0:2};
        cur=${temp:2};
        prefix=$prev;
    fi;
    case $prev in 
        -f)
            COMPREPLY=($( compgen -W 'chomp chop chr crypt hex index lc \
                lcfirst length oct ord pack q qq reverse rindex sprintf \
                substr tr uc ucfirst y m pos quotemeta s split study qr abs \
                atan2 cos exp hex int log oct rand sin sqrt srand pop push \
                shift splice unshift grep join map qw reverse sort unpack \
                delete each exists keys values binmode close closedir \
                dbmclose dbmopen die eof fileno flock format getc print \
                printf read readdir rewinddir seek seekdir select syscall \
                sysread sysseek syswrite tell telldir truncate warn write \
                pack read syscall sysread syswrite unpack vec -X chdir chmod \
                chown chroot fcntl glob ioctl link lstat mkdir open opendir \
                readlink rename rmdir stat symlink umask unlink utime caller \
                continue do dump eval exit goto last next redo return \
                sub wantarray caller import local my our package use defined \
                formline reset scalar undef \
                alarm exec fork getpgrp getppid getpriority kill pipe qx \
                setpgrp setpriority sleep system times wait waitpid \
                import no package require use bless dbmclose dbmopen package \
                ref tie tied untie use accept bind connect getpeername \
                getsockname getsockopt listen recv send setsockopt shutdown \
                socket socketpair msgctl msgget msgrcv msgsnd semctl semget \
                semop shmctl shmget shmread shmwrite endgrent endhostent \
                endnetent endpwent getgrent getgrgid getgrnam getlogin \
                getpwent getpwnam getpwuid setgrent setpwent endprotoent \
                endservent gethostbyaddr gethostbyname gethostent \
                getnetbyaddr getnetbyname getnetent getprotobyname \
                getprotobynumber getprotoent getservbyname getservbyport \
                getservent sethostent setnetent setprotoent setservent \
                gmtime localtime time times' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-h -v -t -u -m -l -F -X -f -q' -- "$cur" ));
    else
        if [[ "$cur" != */* ]]; then
            _perlmodules;
            COMPREPLY=("${COMPREPLY[@]}" $( compgen -W                 '$( PAGER=/bin/cat man perl |  \
                sed -ne "/perl.*Perl overview/,/perlwin32/p" | \
                awk "\$NF=2 { print \$1}" | grep perl )' -- "$cur" ));
        fi;
    fi
}
_perlmodules () 
{ 
    COMPREPLY=($( compgen -P "$prefix" -W "$( perl -e 'sub mods { my ($base,$dir)=@_; return if  $base !~ /^\Q$ENV{cur}/; chdir($dir) or return; for (glob(q[*.pm])) {s/\.pm$//; print qq[$base$_\n]}; mods(/^(?:[.\d]+|$Config{archname}-$Config{osname}|auto)$/ ? undef : qq[${base}${_}\\\\:\\\\:],qq[$dir/$_]) for grep {-d} glob(q[*]); } mods(undef,$_) for @INC;' )" -- "$cur" ))
}
_pgids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}
_pgrep () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _pnames;
    return 0
}
_pids () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo pid= )' -- "$cur" ))
}
_pkg_config () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case $prev in 
        --@(?(define-)variable|@(atleast?(-pkgconfig)|exact|max)-version))
            return 0
        ;;
        -\? | --help | --version | --usage)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--version --modversion \
            --atleast-pkgconfig-version --libs --static \
            --short-errors --libs-only-l --libs-only-other \
            --libs-only-L --cflags --cflags-only-I \
            --cflags-only-other --variable --define-variable \
            --exists --uninstalled --atleast-version \
            --exact-version --max-version --list-all --debug \
            --print-errors --silence-errors --errors-to-stdout \
            --print-provides --print-requires -? --help --usage'             -- "$cur"));
    else
        COMPREPLY=($( compgen -W "$( pkg-config --list-all             2>/dev/null | awk '{print $1}' )" -- "$cur" ));
    fi
}
_pnames () 
{ 
    COMPREPLY=($( compgen -W '$( command ps axo command= | \
    sed -e "s/ .*//; s:.*/::; s/:$//;" \
    -e "s/^[[(-]//; s/[])]$//" \
    -e "s/^<defunct>$//")'     -- "$cur" ))
}
_poff () 
{ 
    local prev cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    prev=${COMP_WORDS[COMP_CWORD-1]};
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($(compgen -W '-r -d -c -a -h -v' -- $cur));
        return 0;
    fi;
    if [ $COMP_CWORD -eq 1 ] && [[ "$cur" != -* ]] || [[ "$prev" == -* ]]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pon () 
{ 
    local cur conns;
    [ -r /etc/ppp/peers/ ] || return 0;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    conns=$(\ls --color=none /etc/ppp/peers | egrep -v '(\.bak|~)$');
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($(compgen -o filenames -W "$conns" $cur));
    fi;
    return 0
}
_pwck () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-q -r -s' -- "$cur" ));
        return 0;
    fi;
    _filedir
}
_python () 
{ 
    local prev cur i;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]##*/};
    case "$prev" in 
        -Q)
            COMPREPLY=($( compgen -W "old new warn warnall" -- "$cur" ));
            return 0
        ;;
        -W)
            COMPREPLY=($( compgen -W "ignore default all module once error"             -- "$cur" ));
            return 0
        ;;
        -c)
            _filedir '@(py|pyc|pyo)';
            return 0
        ;;
        !(python|-?))
            [[ ${COMP_WORDS[COMP_CWORD-2]} != -@(Q|W) ]] && _filedir
        ;;
    esac;
    for ((i=0; i < ${#COMP_WORDS[@]}-1; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == -c ]]; then
            _filedir;
        fi;
    done;
    if [[ "$cur" != -* ]]; then
        _filedir '@(py|pyc|pyo)';
    else
        COMPREPLY=($( compgen -W "- -d -E -h -i -O -Q -S -t -u             -U -v -V -W -x -c" -- "$cur" ));
    fi;
    return 0
}
_rdesktop () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        -k)
            COMPREPLY=($( command ls                 /usr/share/rdesktop/keymaps 2>/dev/null |                 egrep -v '(common|modifiers)' ));
            COMPREPLY=(${COMPREPLY[@]:-} $( command ls                 $HOME/.rdesktop/keymaps 2>/dev/null ));
            COMPREPLY=(${COMPREPLY[@]:-} $( command ls                 ./keymaps 2>/dev/null ));
            COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
            return 0
        ;;
        -a)
            COMPREPLY=($( compgen -W '8 15 16 24' -- "$cur" ));
            return 0
        ;;
        -x)
            COMPREPLY=($( compgen -W 'b broadband m modem l lan'                 -- $cur ));
            return 0
        ;;
        -r)
            COMPREPLY=($( compgen -W 'comport: disk: lptport: \
                printer: sound: lspci scard' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-u -d -s -c -p -n -k -g -f -b -L \
            -A -B -e -E -m -C -D -K -S -T -N -X -a -z -x -P -r \
            -0 -4 -5' -- "$cur" ));
    else
        _known_hosts_real "$cur";
    fi
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p readlink > /dev/null; then
                readlink -f "$(type -P "$1")";
            else
                type -P "$1";
            fi;
        fi
    }
}
_renice () 
{ 
    local command cur curopt i;
    COMPREPLY=();
    cur=`_get_cword`;
    command=$1;
    i=0;
    while [ $i -le $COMP_CWORD -a ${#COMPREPLY[@]} -eq 0 ]; do
        curopt=${COMP_WORDS[COMP_CWORD-$i]};
        case "$curopt" in 
            -u)
                COMPREPLY=($( compgen -u -- "$cur" ))
            ;;
            -g)
                _pgids
            ;;
            -p | $command)
                _pids
            ;;
        esac;
        i=$(( ++i ));
    done
}
_rfcomm () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        -@(f|-config))
            _filedir;
            return 0
        ;;
        -i)
            _bluetooth_devices;
            _bluetooth_adresses;
            return 0
        ;;
    esac;
    _get_command;
    if [ -z $command ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-h --help -a -r --raw -f \
                --config -i -A --auth -E --encrypt -S --secure \
                -M --master' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W 'show connect listen watch \
                bind release' -- "$cur" ));
        fi;
    else
        _count_args;
        if [ $args -eq 2 ]; then
            _bluetooth_devices;
        else
            case $command in 
                @(connect|bind))
                    if [ $args -eq 3 ]; then
                        _bluetooth_adresses;
                    fi
                ;;
            esac;
        fi;
    fi
}
_rfkill () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '--version' -- "$cur" ));
    else
        case $COMP_CWORD in 
            1)
                COMPREPLY=($( compgen -W "help event list block unblock"                     -- "$cur" ))
            ;;
            2)
                prev=${COMP_WORDS[COMP_CWORD-1]};
                if [ $prev == block -o $prev == unblock ]; then
                    COMPREPLY=($( compgen -W "$(rfkill list | awk -F:                         '/^[0-9]/ {print $1}') all wifi bluetooth uwb wimax                         wwan gps" -- "$cur" ));
                fi
            ;;
        esac;
    fi
}
_rl_enabled () 
{ 
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}
_rmmod () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _installed_modules "$cur";
    return 0
}
_root_command () 
{ 
    PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin _command $1 $2 $3
}
_route () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ "$prev" = dev ]; then
        COMPREPLY=($( ifconfig -a | sed -ne 's|^\('$cur'[^ ]*\).*$|\1|p' ));
        return 0;
    fi;
    COMPREPLY=($( compgen -W 'add del -host -net netmask metric mss \
        window irtt reject mod dyn reinstate dev \
        default gw' -- "$cur" ));
    COMPREPLY=($( echo " ${COMP_WORDS[@]}" |         (while read -d ' ' i; do
            [ "$i" == "" ] && continue
            # flatten array with spaces on either side,
            # otherwise we cannot grep on word
            # boundaries of first and last word
            COMPREPLY=" ${COMPREPLY[@]} "
            # remove word from list of completions
            COMPREPLY=( ${COMPREPLY/ $i / } )
        done
           echo "${COMPREPLY[@]}")
        ));
    return 0
}
_rpcdebug () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        -s)
            _rpcdebug_flags;
            return 0
        ;;
        -c)
            _rpcdebug_flags;
            return 0
        ;;
        -m)
            COMPREPLY=($( compgen -W 'rpc nfs nfsd nlm' -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-v -h -m -s -c' -- "$cur" ));
    fi
}
_rpcdebug_flags () 
{ 
    local i module;
    for ((i=0; i < ${#COMP_WORDS[@]}; i++ ))
    do
        if [[ ${COMP_WORDS[i]} == -m ]]; then
            module=${COMP_WORDS[i+1]};
        fi;
    done;
    if [ -n "$module" ]; then
        COMPREPLY=($( compgen -W "$(rpcdebug -vh 2>&1             | grep '^'$module' '            | awk '{$1 = ""; print $0}')" -- "$cur" ));
    fi
}
_rsync () 
{ 
    local cur prev shell i userhost path;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _expand || return 0;
    case "$prev" in 
        --@(config|password-file|include-from|exclude-from))
            _filedir;
            return 0
        ;;
        -@(T|-temp-dir|-compare-dest))
            _filedir -d;
            return 0
        ;;
        -@(e|-rsh))
            COMPREPLY=($( compgen -W 'rsh ssh' -- "$cur" ));
            return 0
        ;;
    esac;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W '-v -q  -c -a -r -R -b -u -l -L -H \
            -p -o -g -D -t -S -n -W -x -B -e -C -I -T -P \
            -z -h -4 -6 --verbose --quiet --checksum \
            --archive --recursive --relative --backup \
            --backup-dir --suffix= --update --links \
            --copy-links --copy-unsafe-links --safe-links \
            --hard-links --perms --owner --group --devices\
            --times --sparse --dry-run --whole-file \
            --no-whole-file --one-file-system \
            --block-size= --rsh= --rsync-path= \
            --cvs-exclude --existing --ignore-existing \
            --delete --delete-excluded --delete-after \
            --ignore-errors --max-delete= --partial \
            --force --numeric-ids --timeout= \
            --ignore-times --size-only --modify-window= \
            --temp-dir= --compare-dest= --compress \
            --exclude= --exclude-from= --include= \
            --include-from= --version --daemon --no-detach\
            --address= --config= --port= --blocking-io \
            --no-blocking-io --stats --progress \
            --log-format= --password-file= --bwlimit= \
            --write-batch= --read-batch= --help' -- "$cur" ))
        ;;
        *:*)
            shell=ssh;
            for ((i=1; i < COMP_CWORD; i++ ))
            do
                if [[ "${COMP_WORDS[i]}" == -@(e|-rsh) ]]; then
                    shell=${COMP_WORDS[i+1]};
                    break;
                fi;
            done;
            if [[ "$shell" == ssh ]]; then
                cur=${cur/\\:/:};
                userhost=${cur%%?(\\):*};
                path=${cur#*:};
                path=${path//\\\\\\\\ / };
                if [ -z "$path" ]; then
                    path=$(ssh -o 'Batchmode yes' $userhost pwd 2>/dev/null);
                fi;
                COMPREPLY=($( ssh -o 'Batchmode yes' $userhost                 command ls -aF1d "$path*" 2>/dev/null |                 sed -e 's/ /\\\\\\\ /g' -e 's/[*@|=]$//g'                 -e 's/[^\/]$/& /g' ));
            fi
        ;;
        *)
            _known_hosts_real -c -a "$cur";
            _filedir
        ;;
    esac;
    return 0
}
_samba_debuglevel () 
{ 
    COMPREPLY=($( compgen -W '0 1 2 3 4 5 6 7 8 9 10' -- "$cur" ))
}
_samba_domains () 
{ 
    if [ -n "${COMP_SAMBA_SCAN:-}" ]; then
        COMPREPLY=($( compgen -W '$( smbtree -N -D )' -- "$cur" ));
    fi
}
_samba_hosts () 
{ 
    if [ -n "${COMP_SAMBA_SCAN:-}" ]; then
        COMPREPLY=($( compgen -W "$( smbtree -N -S |             sed -ne 's/^[[:space:]]*\\\\*\([^[:space:]]*\).*/\1/p'             )" -- $cur ));
    fi
}
_samba_resolve_order () 
{ 
    COMPREPLY=($( compgen -W 'lmhosts host wins bcast' -- "$cur" ))
}
_scp () 
{ 
    local configfile cur userhost path prefix;
    COMPREPLY=();
    cur=`_get_cword ":"`;
    _expand || return 0;
    if [[ "$cur" == *:* ]]; then
        local IFS='	
';
        cur=${cur/\\:/:};
        userhost=${cur%%?(\\):*};
        path=${cur#*:};
        path=${path//\\\\\\\\ / };
        if [ -z "$path" ]; then
            path=$(ssh -o 'Batchmode yes' $userhost pwd 2>/dev/null);
        fi;
        COMPREPLY=($( ssh -o 'Batchmode yes' $userhost             command ls -aF1d "$path*" 2>/dev/null |             sed -e "s/[][(){}<>\",:;^&\!$=?\`|\\ ']/\\\\\\\\\\\\&/g"             -e 's/[*@|=]$//g' -e 's/[^\/]$/& /g' ));
        return 0;
    fi;
    if [[ "$cur" = -F* ]]; then
        cur=${cur#-F};
        prefix=-F;
    else
        set -- "${COMP_WORDS[@]}";
        while [ $# -gt 0 ]; do
            if [ "${1:0:2}" = -F ]; then
                if [ ${#1} -gt 2 ]; then
                    configfile="$(dequote "${1:2}")";
                else
                    shift;
                    [ "$1" ] && configfile="$(dequote "$1")";
                fi;
                break;
            fi;
            shift;
        done;
        [[ "$cur" == */* ]] || _known_hosts_real -c -a -F "$configfile" "$cur";
    fi;
    local IFS='	
';
    COMPREPLY=("${COMPREPLY[@]}" $( command ls -aF1d $cur* 2>/dev/null | sed         -e "s/[][(){}<>\",:;^&\!$=?\`|\\ ']/\\\\&/g"         -e 's/[*@|=]$//g' -e 's/[^\/]$/& /g' -e "s/^/$prefix/"));
    return 0
}
_screen () 
{ 
    local cur prev preprev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    [ "$COMP_CWORD" -ge 2 ] && preprev=${COMP_WORDS[COMP_CWORD-2]};
    case "$preprev" in 
        -[dD])
            _screen_sessions;
            return 0
        ;;
    esac;
    case "$prev" in 
        -[rR])
            _screen_sessions 'Detached';
            return 0
        ;;
        -[dDx])
            _screen_sessions 'Attached';
            return 0
        ;;
        -s)
            COMPREPLY=($( grep ^${cur:-[^#]} /etc/shells ))
        ;;
        -c)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -A -c -d -D -e -f -fn -fa -h -i \
            -l -ln -ls -list -L -m -O -p -q -r -R -s -S -t -U -v \
            -wipe -x -X' -- "$cur" ));
    fi
}
_screen_sessions () 
{ 
    local pattern;
    if [ -n "$1" ]; then
        pattern=".*$1.*";
    else
        pattern=".*";
    fi;
    COMPREPLY=($( command screen -ls | sed -ne         's|^[''	'']\+\('"$cur"'[0-9]\+\.[^''	'']\+\)'"$pattern"'$|\1|p' ))
}
_sdptool () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case $prev in 
        --bdaddr)
            _bluetooth_adresses;
            return 0
        ;;
    esac;
    $split && return 0;
    _get_command;
    if [ -z $command ]; then
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '--help' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W 'search browse records add \
                del get setattr setseq' -- "$cur" ));
        fi;
    else
        case $command in 
            search)
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '--bdaddr \
                        --tree --raw --xml' -- "$cur" ));
                else
                    _bluetooth_services;
                fi
            ;;
            @(browse|records))
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '--tree --raw --xml' -- "$cur" ));
                else
                    _bluetooth_adresses;
                fi
            ;;
            add)
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '--handle --channel' -- "$cur" ));
                else
                    _bluetooth_services;
                fi
            ;;
            get)
                if [[ "$cur" == -* ]]; then
                    COMPREPLY=($( compgen -W '--bdaddr \
                        --tree --raw --xml' -- "$cur" ));
                fi
            ;;
        esac;
    fi
}
_service () 
{ 
    local cur prev sysvdir;
    COMPREPLY=();
    prev=${COMP_WORDS[COMP_CWORD-1]};
    cur=`_get_cword`;
    [[ ${COMP_WORDS[0]} != @(*init.d/!(functions|~)|service) ]] && return 0;
    [ $COMP_CWORD -gt 2 ] && return 0;
    [ -d /etc/rc.d/init.d ] && sysvdir=/etc/rc.d/init.d || sysvdir=/etc/init.d;
    if [[ $COMP_CWORD -eq 1 ]] && [[ $prev == "service" ]]; then
        _services;
    else
        COMPREPLY=($( compgen -W '`sed -ne "y/|/ /; \
            s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\1/p" \
            $sysvdir/${prev##*/} 2>/dev/null`' -- "$cur" ));
    fi;
    return 0
}
_services () 
{ 
    local sysvdir famdir;
    [ -d /etc/rc.d/init.d ] && sysvdir=/etc/rc.d/init.d || sysvdir=/etc/init.d;
    famdir=/etc/xinetd.d;
    COMPREPLY=($( builtin echo $sysvdir/!(*.rpm@(orig|new|save)|*~|functions)));
    if [ -d $famdir ]; then
        COMPREPLY=("${COMPREPLY[@]}" $( builtin echo $famdir/!(*.rpm@(orig|new|save)|*~)));
    fi;
    COMPREPLY=($( compgen -W '${COMPREPLY[@]#@($sysvdir|$famdir)/}' -- "$cur" ))
}
_sftp () 
{ 
    local cur prev configfile;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -@(b|F|P))
            _filedir;
            return 0
        ;;
        -o)
            _ssh_options;
            return 0
        ;;
    esac;
    if [[ "$cur" == -F* ]]; then
        cur=${cur#-F};
        _filedir;
        COMPREPLY=("${COMPREPLY[@]/#/-F}");
        cur=-F$cur;
    else
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-1 -C -v -B -b -F -o -P -R -S -s' 			-- "$cur" ));
        else
            set -- "${COMP_WORDS[@]}";
            while [ $# -gt 0 ]; do
                if [ "${1:0:2}" = -F ]; then
                    if [ ${#1} -gt 2 ]; then
                        configfile="$(dequote "${1:2}")";
                    else
                        shift;
                        [ "$1" ] && configfile="$(dequote "$1")";
                    fi;
                    break;
                fi;
                shift;
            done;
            _known_hosts_real -a -F "$configfile" "$cur";
        fi;
    fi;
    return 0
}
_shells () 
{ 
    COMPREPLY=("${COMPREPLY[@]}" $( compgen -W '$( grep "^[[:space:]]*/" \
    /etc/shells 2>/dev/null )' -- "$cur" ))
}
_signals () 
{ 
    local i;
    COMPREPLY=($( compgen -A signal SIG${cur#-} ));
    for ((i=0; i < ${#COMPREPLY[@]}; i++ ))
    do
        COMPREPLY[i]=-${COMPREPLY[i]#SIG};
    done
}
_smbcacls () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case $prev in 
        -s)
            _filedir;
            return 0
        ;;
        -l | --log-basename)
            _filedir -d;
            return 0
        ;;
        -d | --debuglevel)
            _samba_debuglevel;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -M -D -S -U -C -G --numeric -t \
            -h --help -V -s -d --debuglevel -l --log-basename' -- "$cur" ));
    fi
}
_smbclient () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case $prev in 
        -R)
            _samba_resolve_order;
            return 0
        ;;
        -t)
            COMPREPLY=($( compgen -W 'SJIS EUC JIS7 JIS8 JUNET HEX CAP'                 -- "$cur" ));
            return 0
        ;;
        -s | -A | --authentication-file)
            _filedir;
            return 0
        ;;
        -l | --log-basename | -D)
            _filedir -d;
            return 0
        ;;
        -O)
            COMPREPLY=($( compgen -W 'SO_KEEPALIVE SO_REUSEADDR \
                SO_BROADCAST TCP_NODELAY IPTOS_LOWDELAY \
                IPTOS_THROUGHPUT SO_SNDBUF SO_RCVBUF \
                SO_SNDLOWAT SO_RCVLOWAT' -- "$cur" ));
            return 0
        ;;
        -T)
            COMPREPLY=($( compgen -W 'c x I X F b g q r N a' -- "$cur" ));
            return 0
        ;;
        -W | --workgroup)
            _samba_domains;
            return 0
        ;;
        -d | --debuglevel)
            _samba_debuglevel;
            return 0
        ;;
        -p | --port | -M | -I | -b | -U | --user | -n | -i | -T | -c)
            return 0
        ;;
        -\? | --help | -V | --version)
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b -d -L -U -I -M -m -A -N -i -O \
            -p -R -s -k -P -c -D -W -l -E --debuglevel \
            --log-basename --workgroup' -- "$cur" ));
    fi
}
_smbcquotas () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case $prev in 
        -s | -A | --authentication-file)
            _filedir;
            return 0
        ;;
        -l | --log-basename)
            _filedir -d;
            return 0
        ;;
        -d | --debuglevel)
            _samba_debuglevel;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-u -L -F -S -n -t -v -h --help -V \
            -s -d --debuglevel -l --log-basename -N -k -A \
            --authentication-file -U --user' -- "$cur" ));
    fi
}
_smbget () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case $prev in 
        -@(o|f|-outputfile|-rcfile))
            _filedir;
            return 0
        ;;
        -d | --debuglevel)
            _samba_debuglevel;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a --guest -r --resume -R --recursive -u \
            --username -p --password -w --workgroup -n --nonprompt -d \
            --debuglevel -D --dots -P --keep-permissions -o --outputfile -f \
            --rcfile -q --quiet -v --verbose -b --blocksize -? --help --usage'             -- "$cur" ));
    fi
}
_smbpasswd () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        -r)
            _samba_hosts;
            return 0
        ;;
        -R)
            _samba_resolve_order;
            return 0
        ;;
        -c)
            _filedir;
            return 0
        ;;
        -D)
            _samba_debuglevel;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -c -x -d -e -D -n -r -R -m -U -h \
            -s -w -W -i -L' -- "$cur" ));
    fi
}
_smbtar () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case $prev in 
        -@(r|t))
            _filedir tar;
            return 0
        ;;
        -s)
            _samba_hosts;
            return 0
        ;;
        -l)
            _samba_debuglevel;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-r -i -a -v -s -p -x -X -N -b -d -l -u -t'             -- "$cur" ));
    fi
}
_smbtree () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case $prev in 
        -s | -A | --authentication-file)
            _filedir;
            return 0
        ;;
        -l | --log-basename)
            _filedir -d;
            return 0
        ;;
        -d | --debuglevel)
            _samba_debuglevel;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b -D -S -V -s -d --debuglevel -l \
            --log-basename -N -k -A --authentication-file -U --user\
            -h --help' -- "$cur" ));
    fi
}
_split_longopt () 
{ 
    if [[ "$cur" == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_ssh () 
{ 
    local cur prev configfile;
    local -a config;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -@(F|i|S))
            _filedir;
            return 0
        ;;
        -c)
            COMPREPLY=($( compgen -W '3des-cbc aes128-cbc \
				aes192-cbc aes256-cbc aes128-ctr aes192-ctr \
				aes256-ctr arcfour128 arcfour256 arcfour \
				blowfish-cbc cast128-cbc' -- "$cur" ));
            return 0
        ;;
        -c)
            COMPREPLY=($( compgen -W 'hmac-md5 hmac-sha1 \
				umac-64@openssh.com hmac-ripemd160 \
				hmac-sha1-96 hmac-md5-96' -- "$cur" ));
            return 0
        ;;
        -l)
            COMPREPLY=($( compgen -u -- "$cur" ));
            return 0
        ;;
        -o)
            _ssh_options;
            return 0
        ;;
        -w)
            _available_interfaces;
            return 0
        ;;
        -b)
            COMPREPLY=($( compgen -W "$(/sbin/ifconfig | 				awk '/adr:/ {print $2}' | 				awk -F: '{print $2}' )" -- "$cur" ));
            return 0
        ;;
    esac;
    if [[ "$cur" == -F* ]]; then
        cur=${cur#-F};
        _filedir;
        COMPREPLY=("${COMPREPLY[@]/#/-F}");
        cur=-F$cur;
    else
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-1 -2 -4 -6 -A -a -C -f -g -K -k -M \
			-N -n -q -s -T -t -V -v -X -v -Y -y -b -b -c -D -e -F \
			-i -L -l -m -O -o -p -R -S -w' -- "$cur" ));
        else
            set -- "${COMP_WORDS[@]}";
            while [ $# -gt 0 ]; do
                if [ "${1:0:2}" = -F ]; then
                    if [ ${#1} -gt 2 ]; then
                        configfile="$(dequote "${1:2}")";
                    else
                        shift;
                        [ "$1" ] && configfile="$(dequote "$1")";
                    fi;
                    break;
                fi;
                shift;
            done;
            _known_hosts_real -a -F "$configfile" "$cur";
            if [ $COMP_CWORD -ne 1 ]; then
                COMPREPLY=("${COMPREPLY[@]}" $( compgen -c -- "$cur" ));
            fi;
        fi;
    fi;
    return 0
}
_ssh_copy_id () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -i)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-i' -- "$cur" ));
    else
        _known_hosts_real -a "$cur";
    fi;
    return 0
}
_ssh_options () 
{ 
    COMPREPLY=($( compgen -W 'AddressFamily BatchMode BindAddress \
		ChallengeResponseAuthentication CheckHostIP Cipher Ciphers \
		ClearAllForwardings Compression CompressionLevel \
		ConnectionAttempts ConnectTimeout ControlMaster ControlPath \
		DynamicForward EscapeChar ExitOnForwardFailure ForwardAgent \
		ForwardX11 ForwardX11Trusted GatewayPorts GlobalKnownHostsFile \
		GSSAPIAuthentication GSSAPIDelegateCredentials HashKnownHosts \
		Host HostbasedAuthentication HostKeyAlgorithms HostKeyAlias \
		HostName IdentityFile IdentitiesOnly KbdInteractiveDevices \
		LocalCommand LocalForward LogLevel MACs \
		NoHostAuthenticationForLocalhost NumberOfPasswordPrompts \
		PasswordAuthentication PermitLocalCommand Port \
		PreferredAuthentications Protocol ProxyCommand \
		PubkeyAuthentication RekeyLimit RemoteForward \
		RhostsRSAAuthentication RSAAuthentication SendEnv \
		ServerAliveInterval ServerAliveCountMax SmartcardDevice \
		StrictHostKeyChecking TCPKeepAlive Tunnel TunnelDevice \
		UsePrivilegedPort User UserKnownHostsFile VerifyHostKeyDNS \
		VisualHostKey XAuthLocation' -- "$cur" ))
}
_strace () 
{ 
    local cur prev offset i syscalls arch unistd;
    offset=0;
    for ((i=1; i <= COMP_CWORD; i++ ))
    do
        case ${COMP_WORDS[$i]} in 
            -@(o|e|p))
                i=$((i+1));
                continue
            ;;
            -*)
                continue
            ;;
        esac;
        offset=$i;
        break;
    done;
    if [ $offset -gt 0 ]; then
        _command_offset $offset;
    else
        COMPREPLY=();
        cur=`_get_cword`;
        prev=${COMP_WORDS[COMP_CWORD-1]};
        case $prev in 
            -e)
                if [[ "$cur" == *=* ]]; then
                    prev=${cur/=*/};
                    cur=${cur/*=/};
                    arch=$(command uname -m);
                    syscalls=$(awk '/^#define __NR/ {print $2}'                     /usr/include/asm/unistd.h | sed -e                     's/__NR_//');
                    if [ -z "$syscalls" ]; then
                        if [[ "$arch" =~ 86$ ]]; then
                            unistd=/usr/include/asm/unistd_32.h;
                        else
                            unistd=/usr/include/asm/unistd_64.h;
                        fi;
                        syscalls=$(awk '/^#define __NR/ {print $2}'                         $unistd | sed -e 's/__NR_//');
                    fi;
                    case $prev in 
                        trace)
                            COMPREPLY=($( compgen -W "$syscalls file process                             network signal ipc desc all none" -- "$cur"));
                            return 0
                        ;;
                    esac;
                else
                    COMPREPLY=($( compgen -S"=" -W 'trace abbrev \
                    verbose raw signal read write' -- "$cur" ));
                fi;
                return 0
            ;;
            -o)
                _filedir;
                return 0
            ;;
            -p)
                _pids;
                return 0
            ;;
            -S)
                COMPREPLY=($( compgen -W 'time calls name nothing' -- "$cur" ));
                return 0
            ;;
            -u)
                COMPREPLY=($( compgen -u -- "$cur" ));
                return 0
            ;;
        esac;
        if [[ "$cur" == -* ]]; then
            COMPREPLY=($( compgen -W '-c -d -f -ff -F -h --help -i -q \
                -r -t -tt -ttt -T -v -V -x -xx -a -e -o -O -p \
                -s -S -u -E' -- "$cur" ));
        else
            COMPREPLY=($( compgen -c -- "$cur" ));
        fi;
    fi
}
_stream () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    _ImageMagick;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-authenticate -channel -colorspace \
            -compress -debug -define -density -depth -extract \
            -help -identify -interlace -interpolate -limit -list \
            -log -map -monitor -quantize -quiet -regard-warnings \
            -respect-parenthesis -sampling-factor -seed -set \
            -size -storage-type -transparent-color -verbose \
            -version -virtual-pixel' -- "$cur" ));
    else
        if [[ "$cur" == +* ]]; then
            COMPREPLY=($( compgen -W '+debug' -- "$cur" ));
        else
            _filedir;
        fi;
    fi
}
_svn () 
{ 
    local cur cmds cmdOpts pOpts mOpts rOpts qOpts nOpts optsParam opt;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='add blame annotate praise cat changelist cl checkout co cleanup';
    cmds="$cmds commit ci copy cp delete remove rm diff export help import";
    cmds="$cmds info list ls lock log merge mergeinfo mkdir move mv rename";
    cmds="$cmds propdel pdel propedit pedit propget pget proplist plist";
    cmds="$cmds propset pset resolve resolved revert status switch unlock";
    cmds="$cmds update";
    local helpOpts='--help -h';
    local specOpts="--version $helpOpts";
    optsParam="-r|--revision|--username|--password|--targets";
    optsParam="$optsParam|-x|--extensions|-m|--message|-F|--file";
    optsParam="$optsParam|--encoding|--diff-cmd|--diff3-cmd|--editor-cmd";
    optsParam="$optsParam|--old|--new|--config-dir|--config-option";
    optsParam="$optsParam|--native-eol|-l|--limit|-c|--change";
    optsParam="$optsParam|--depth|--set-depth|--with-revprop";
    optsParam="$optsParam|--changelist|--accept|--show-revs";
    local svnProps revProps allProps psCmds propCmds;
    svnProps="svn:keywords svn:executable svn:needs-lock svn:externals
	          svn:ignore svn:eol-style svn:mime-type $SVN_BASH_FILE_PROPS";
    revProps="svn:author svn:log svn:date $SVN_BASH_REV_PROPS";
    allProps=($svnProps $revProps);
    psCmds='propset|pset|ps';
    propCmds="$psCmds|propget|pget|pg|propedit|pedit|pe|propdel|pdel|pd";
    local cmd= isPropCmd= isPsCmd= isHelpCmd= nExpectArgs= isCur= i=0;
    local prev= help= prop= val= isRevProp= last='none' nargs=0 stat=;
    local options= hasRevPropOpt= hasRevisionOpt= hasRelocateOpt=;
    local acceptOpt= URL= hasReintegrateOpt=;
    for opt in "${COMP_WORDS[@]}";
    do
        [[ -n $isCur ]] && stat=$last;
        isCur=;
        [[ $i -eq $COMP_CWORD ]] && isCur=1;
        let i++;
        [ $last = 'none' ] && { 
            last='first';
            continue
        };
        if [[ $prev == @($optsParam) ]]; then
            [[ $prev = '--accept' ]] && acceptOpt=$opt;
            prev='';
            last='skip';
            continue;
        fi;
        if [[ $prev == @(<|>|>>|[12]>|[12]>>) ]]; then
            prev='';
            last='skip';
            continue;
        fi;
        prev=$opt;
        if [[ ! -n $cmd && -n $opt && ( $opt != -* || $opt == @(${specOpts// /|}) ) ]]; then
            cmd=$opt;
            [[ $cmd == @($propCmds) ]] && isPropCmd=1;
            [[ $cmd == @($psCmds) ]] && isPsCmd=1;
            [[ $cmd == @(${helpOpts// /|}) ]] && cmd='help';
            [[ $cmd = 'help' ]] && isHelpCmd=1;
            if [[ -n $isHelpCmd && -n $cmd && $cmd != 'help' && ! -n $help ]]; then
                help=$cmd;
                cmd='help';
            fi;
            last='cmd';
            continue;
        fi;
        if [[ -n $isHelpCmd && ! -n $help && -n $opt && $opt != -* ]]; then
            help=$opt;
            last='help';
            continue;
        fi;
        if [[ -n $isPropCmd && ! -n $prop && -n $opt && $opt != -* ]]; then
            prop=$opt;
            [[ $prop == @(${revProps// /|}) ]] && isRevProp=1;
            last='prop';
            continue;
        fi;
        if [[ -n $isPsCmd && -n $prop && ! -n $val && $opt != -* ]]; then
            val=$opt;
            last='val';
            continue;
        fi;
        if [[ $last != 'onlyarg' ]]; then
            case $opt in 
                -r | --revision | --revision=*)
                    hasRevisionOpt=1
                ;;
                --revprop)
                    hasRevPropOpt=1;
                    allProps=($revProps);
                    nExpectArgs=1
                ;;
                -h | --help)
                    isHelpCmd=1
                ;;
                -F | --file)
                    val='-F'
                ;;
                --relocate)
                    hasRelocateOpt=1
                ;;
                --reintegrate)
                    hasReintegrateOpt=1
                ;;
            esac;
            if [[ $opt = '--' && ! -n $isCur ]]; then
                last='onlyarg';
                continue;
            fi;
            if [[ $opt == -* ]]; then
                [[ ! -n $isCur ]] && options="$options $opt ";
                last='opt';
                continue;
            fi;
        else
            let nargs++;
            continue;
        fi;
        if [[ $cmd = 'merge' && ! -n $URL ]]; then
            URL=$opt;
        fi;
        last='arg';
        let nargs++;
    done;
    [[ -n $stat ]] || stat=$last;
    if [[ ! -n $cmd || $stat = 'cmd' ]]; then
        COMPREPLY=($( compgen -W "$cmds $specOpts" -- $cur ));
        return 0;
    fi;
    if [[ $stat = 'help' || ( -n $isHelpCmd && ! -n $help ) ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    if [[ $cmd = 'merge' || $cmd = 'mergeinfo' ]]; then
        local here=$(_svn_info URL);
        if [[ ! -n $URL && $stat = 'arg' ]]; then
            if [[ "$here" == */branches/* ]]; then
                COMPREPLY=($(compgen -W ${here/\/branches\/*/\/trunk} -- $cur ));
                return 0;
            else
                if [[ "$here" == */trunk* ]]; then
                    COMPREPLY=($(compgen -W ${here/\/trunk*/\/branches\/} -- $cur ));
                    return 0;
                else
                    COMPREPLY=($(compgen -W $(_svn_info Root) -- $cur ));
                    return 0;
                fi;
            fi;
        else
            if [[ $URL == */branches/* && $here == */trunk* && ! -n $hasReintegrateOpt && $cur = '' && $stat = 'arg' ]]; then
                COMPREPLY=($(compgen -W '--reintegrate' -- $cur ));
                return 0;
            fi;
        fi;
    fi;
    if [[ $stat = 'skip' ]]; then
        local previous=${COMP_WORDS[COMP_CWORD-1]};
        local values= dirs= beep= exes=;
        [[ $previous = '--config-dir' ]] && dirs=1;
        [[ $previous = --*-cmd ]] && exes=1;
        [[ $previous = '--native-eol' ]] && values='LF CR CRLF';
        [[ $previous = '--limit' ]] && values='0 1 2 3 4 5 6 7 8 9';
        [[ $previous = '--revision' || $previous = '-r' ]] && values='HEAD BASE PREV COMMITTED 0 {';
        [[ $previous = '--encoding' ]] && values="latin1 utf8 $SVN_BASH_ENCODINGS";
        [[ $previous = '--extensions' || $previous = '-x' ]] && values="--unified --ignore-space-change    		        --ignore-all-space --ignore-eol-style";
        [[ $previous = '--depth' ]] && values='empty files immediates infinity';
        [[ $previous = '--set-depth' ]] && values='empty exclude files immediates infinity';
        [[ $previous = '--accept' ]] && { 
            if [[ $cmd = 'resolve' ]]; then
                values='base working mine-full theirs-full';
            else
                values='postpone base mine-full theirs-full edit launch';
            fi
        };
        [[ $previous = '--show-revs' ]] && values='merged eligible';
        if [[ $previous = '--username' ]]; then
            values="$SVN_BASH_USERNAME";
            if [[ $SVN_BASH_COMPL_EXT == *username* ]]; then
                local file=;
                for file in ~/.subversion/auth/svn.simple/*;
                do
                    if [ -r $file ]; then
                        values="$values $(_svn_read_hashfile username < $file)";
                    fi;
                done;
            fi;
            [[ ! -n "$values" ]] && beep=1;
        fi;
        [[ $previous = '--password' ]] && beep=1;
        [[ -n $values ]] && COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n $dirs ]] && COMPREPLY=($( compgen -o dirnames -- $cur ));
        [[ -n $exes ]] && COMPREPLY=($( compgen -c -- $cur ));
        [[ -n $beep ]] && { 
            echo -en "\a";
            COMPREPLY=('')
        };
        return 0;
    fi;
    if [[ -n $isPropCmd && ( ! -n $prop || $stat = 'prop' ) && $cur != -* ]]; then
        local choices=;
        if [[ $cur == *:* ]]; then
            local prefix=${cur%:*} suffix=${cur#*:} c=;
            for c in ${allProps[@]};
            do
                [[ $c == $prefix:* ]] && choices="$choices ${c#*:}";
            done;
            cur=$suffix;
        else
            COMPREPLY=($( compgen -W "${allProps[*]}" -- $cur ));
            [ ${#COMPREPLY[@]} -eq 1 ] && return 0;
            local seen= n=0 last= c=;
            for c in ${allProps[@]%:*};
            do
                if [[ $c == $cur* && ( ! -n $seen || $c != @($seen) ) ]]; then
                    let n++;
                    last=$c;
                    choices="$choices $c:";
                    if [[ -n $seen ]]; then
                        seen="$seen|$c*";
                    else
                        seen="$c*";
                    fi;
                fi;
            done;
            [[ $n -eq 1 ]] && choices="$last:1 $last:2";
        fi;
        COMPREPLY=($( compgen -W "$choices" -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && ! -n $hasRevPropOpt ]]; then
        COMPREPLY=($( compgen -W '--revprop' -- $cur ));
        return 0;
    fi;
    if [[ -n $isRevProp && -n $hasRevPropOpt && ! -n $hasRevisionOpt ]]; then
        COMPREPLY=($( compgen -W '--revision' -- $cur ));
        return 0;
    fi;
    if [[ -n $isPsCmd && -n $prop && ( ! -n $val || $stat = 'val' ) ]]; then
        local values="\' --file";
        case $prop in 
            svn:keywords)
                values="Id Rev URL Date Author Header \' $SVN_BASH_KEYWORDS"
            ;;
            svn:executable | svn:needs-lock)
                values='\\*'
            ;;
            svn:eol-style)
                values='native LF CR CRLF'
            ;;
            svn:mime-type)
                values="text/ text/plain text/html text/xml text/rtf
                       image/ image/png image/gif image/jpeg image/tiff
                       audio/ audio/midi audio/mpeg
                       video/ video/mpeg video/mp4
                       application/ application/octet-stream
                       $SVN_BASH_MIME_TYPE"
            ;;
        esac;
        COMPREPLY=($( compgen -W "$values" -- $cur ));
        [[ -n ${COMPREPLY} ]] && return 0;
    fi;
    if [[ $cmd = 'resolve' && ! -n $acceptOpt ]]; then
        COMPREPLY=($( compgen -W '--accept' -- $cur ));
        return 0;
    fi;
    case $cmd in 
        merge)
            nExpectArgs=3
        ;;
        mergeinfo)
            nExpectArgs=1
        ;;
        copy | cp | move | mv | rename | ren | export | import)
            nExpectArgs=2
        ;;
        switch | sw)
            [[ ! -n $hasRelocateOpt ]] && nExpectArgs=2
        ;;
        help | h)
            nExpectArgs=0
        ;;
        --version)
            nExpectArgs=0
        ;;
    esac;
    if [[ -n $nExpectArgs && $nargs -gt $nExpectArgs ]]; then
        echo -en "\a";
        COMPREPLY=('');
        return 0;
    fi;
    if [[ $cur != -* || $stat = 'onlyarg' ]]; then
        if [[ $SVN_BASH_COMPL_EXT == *svnstatus* ]]; then
            local status='svn status --non-interactive';
            [[ $SVN_BASH_COMPL_EXT == *recurse* ]] || status="$status --non-recursive";
            [[ $SVN_BASH_COMPL_EXT == *externals* ]] || status="$status --ignore-externals";
            local cs= files=;
            [[ -n $cur ]] && cs=$cur*;
            case $cmd in 
                st*)
                    files=$cur*
                ;;
                ci | commit | revert | di*)
                    files=$($status $cs| _svn_grcut '@([MADR!]*| M*|_M*)')
                ;;
                add)
                    files=$($status $cs| _svn_grcut '\?*')
                ;;
                unlock)
                    files=$($status $cs| _svn_grcut '@(??L*|?????[KOTB]*)')
                ;;
                resolve*)
                    files=$($status $cs| _svn_grcut '@(?C*|C*)')
                ;;
                praise | blame | ann*)
                    files=$( _svn_lls all $cur* )
                ;;
                p*)
                    if [[ $cmd == @($propCmds) && $prop == @(svn:ignore|svn:externals) ]]; then
                        files=$( _svn_lls dir . $cur* );
                    else
                        files="$( _svn_lls all $cur* )
                                   $($status $cs | _svn_grcut 'A*' )";
                    fi
                ;;
                info)
                    files="$( _svn_lls all $cur* )
                               $($status $cs | _svn_grcut 'A*' )"
                ;;
                remove | rm | del* | move | mv | rename)
                    files=$( _svn_lls all $cur* )
                ;;
                mkdir)
                    files=$( _svn_lls dir $cur* )
                ;;
                log | lock | up* | cl* | switch)
                    files=$( _svn_lls all $cur* )
                ;;
                merge)
                    files=$( _svn_lls all $cur* )
                ;;
                ls | list)
                    files=$( _svn_lls all $cur* )
                ;;
                *)
                    local fallback=1
                ;;
            esac;
            if [[ $SVN_BASH_COMPL_EXT != *recurse* ]]; then
                files="$files $( _svn_lls dir $cur* )";
            fi;
            if [[ -n $files ]]; then
                COMPREPLY=($( compgen -W "$files" -- $cur ));
                [[ -n "${COMPREPLY[*]}" ]] || COMPREPLY=('');
            else
                if [[ ! -n $fallback ]]; then
                    echo -en "\a";
                    COMPREPLY=('');
                fi;
            fi;
        fi;
        return 0;
    fi;
    pOpts="--username --password --no-auth-cache --non-interactive";
    mOpts="-m --message -F --file --encoding --force-log --with-revprop";
    rOpts="-r --revision";
    qOpts="-q --quiet";
    nOpts="-N --non-recursive --depth";
    gOpts="-g --use-merge-history";
    cmdOpts=;
    case $cmd in 
        --version)
            cmdOpts="$qOpts"
        ;;
        add)
            cmdOpts="--auto-props --no-auto-props --force --targets 		         --no-ignore --parents $nOpts $qOpts $pOpts"
        ;;
        blame | annotate | ann | praise)
            cmdOpts="$rOpts $pOpts -v --verbose --incremental --xml 		         -x --extensions --force $gOpts"
        ;;
        cat)
            cmdOpts="$rOpts $pOpts"
        ;;
        changelist | cl)
            cmdOpts="--targets $pOpts $qOpts --changelist                          -R --recursive --depth --remove"
        ;;
        checkout | co)
            cmdOpts="$rOpts $qOpts $nOpts $pOpts --ignore-externals                          --force --accept"
        ;;
        cleanup)
            cmdOpts="--diff3-cmd $pOpts"
        ;;
        commit | ci)
            cmdOpts="$mOpts $qOpts $nOpts --targets --editor-cmd $pOpts 		         --no-unlock --changelist --keep-changelists"
        ;;
        copy | cp)
            cmdOpts="$mOpts $rOpts $qOpts --editor-cmd $pOpts --parents"
        ;;
        delete | del | remove | rm)
            cmdOpts="--force $mOpts $qOpts --targets --editor-cmd $pOpts                          --keep-local"
        ;;
        diff | di)
            cmdOpts="$rOpts -x --extensions --diff-cmd --no-diff-deleted 		         $nOpts $pOpts --force --old --new --notice-ancestry 		         -c --change --summarize --changelist --xml"
        ;;
        export)
            cmdOpts="$rOpts $qOpts $pOpts $nOpts --force --native-eol                          --ignore-externals"
        ;;
        help | h | \?)
            cmdOpts=
        ;;
        import)
            cmdOpts="--auto-props --no-auto-props $mOpts $qOpts $nOpts 		         --no-ignore --editor-cmd $pOpts --force"
        ;;
        info)
            cmdOpts="$pOpts $rOpts --targets -R --recursive --depth                          --incremental --xml --changelist"
        ;;
        list | ls)
            cmdOpts="$rOpts -v --verbose -R --recursive $pOpts                          --incremental --xml --depth"
        ;;
        lock)
            cmdOpts="-m --message -F --file --encoding --force-log                          --targets --force $pOpts"
        ;;
        log)
            cmdOpts="$rOpts -v --verbose --targets $pOpts --stop-on-copy 		         --incremental --xml $qOpts -l --limit -c --change                          $gOpts --with-all-revprops --with-revprop"
        ;;
        merge)
            cmdOpts="$rOpts $nOpts $qOpts --force --dry-run --diff3-cmd 		         $pOpts --ignore-ancestry -c --change -x --extensions                          --record-only --accept --reintegrate"
        ;;
        mergeinfo)
            cmdOpts="$rOpts $pOpts --show-revs"
        ;;
        mkdir)
            cmdOpts="$mOpts $qOpts --editor-cmd $pOpts --parents"
        ;;
        move | mv | rename | ren)
            cmdOpts="$mOpts $rOpts $qOpts --force --editor-cmd $pOpts                          --parents"
        ;;
        propdel | pdel | pd)
            cmdOpts="$qOpts -R --recursive $rOpts $pOpts --changelist                          --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        propedit | pedit | pe)
            cmdOpts="--editor-cmd $pOpts $mOpts --force";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts"
        ;;
        propget | pget | pg)
            cmdOpts="-v --verbose -R --recursive $rOpts --strict $pOpts --changelist                          --depth --xml";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-v --verbose -R --recursive $rOpts --revprop $qOpts 		         $pOpts --changelist --depth --xml"
        ;;
        propset | pset | ps)
            cmdOpts="$qOpts --targets -R --recursive 		         --encoding $pOpts --force --changelist --depth";
            [[ -n $isRevProp || ! -n $prop ]] && cmdOpts="$cmdOpts --revprop $rOpts";
            [[ -n $val ]] || cmdOpts="$cmdOpts -F --file"
        ;;
        resolve)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --accept                          --depth"
        ;;
        resolved)
            cmdOpts="--targets -R --recursive $qOpts $pOpts --depth"
        ;;
        revert)
            cmdOpts="--targets -R --recursive $qOpts --changelist                          --depth $pOpts"
        ;;
        status | stat | st)
            cmdOpts="-u --show-updates -v --verbose $nOpts $qOpts $pOpts 		         --no-ignore --ignore-externals --incremental --xml                          --changelist"
        ;;
        switch | sw)
            cmdOpts="--relocate $rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --force --accept --ignore-externals --set-depth"
        ;;
        unlock)
            cmdOpts="--targets --force $pOpts"
        ;;
        update | up)
            cmdOpts="$rOpts $nOpts $qOpts $pOpts --diff3-cmd                          --ignore-externals --force --accept --changelist                          --editor-cmd --set-depth"
        ;;
        *)

        ;;
    esac;
    [[ "$cmd" != "--version" ]] && cmdOpts="$cmdOpts $helpOpts";
    cmdOpts="$cmdOpts --config-dir --config-option";
    if [[ $acceptOpt == @(edit|launch) ]]; then
        cmdOpts=${cmdOpts/ --non-interactive / };
    fi;
    for opt in $options;
    do
        local optBase;
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -R)
                cmdOpts=${cmdOpts/ --recursive / }
            ;;
            --recursive)
                cmdOpts=${cmdOpts/ -R / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -c)
                cmdOpts=${cmdOpts/ --change / }
            ;;
            --change)
                cmdOpts=${cmdOpts/ -c / }
            ;;
            --auto-props)
                cmdOpts=${cmdOpts/ --no-auto-props / }
            ;;
            --no-auto-props)
                cmdOpts=${cmdOpts/ --auto-props / }
            ;;
            -g)
                cmdOpts=${cmdOpts/ --use-merge-history / }
            ;;
            --use-merge-history)
                cmdOpts=${cmdOpts/ -g / }
            ;;
            -m | --message | -F | --file)
                cmdOpts=${cmdOpts/ --message / };
                cmdOpts=${cmdOpts/ -m / };
                cmdOpts=${cmdOpts/ --file / };
                cmdOpts=${cmdOpts/ -F / }
            ;;
        esac;
        if [ $isHelpCmd ]; then
            cmdOpts=${cmdOpts/ -h / };
            cmdOpts=${cmdOpts/ --help / };
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svn_grcut () 
{ 
    local re=$1 line= old_IFS;
    old_IFS="$IFS";
    IFS='
';
    while read -r line; do
        [[ ! -n $re || $line == $re ]] && echo "${line/????????/}";
    done;
    IFS="$old_IFS"
}
_svn_info () 
{ 
    local what=$1 line=;
    LANG=C LC_MESSAGES=C svn info --non-interactive 2> /dev/null | while read line; do
        [[ $line == *"$what: "* ]] && echo ${line#*: };
    done
}
_svn_lls () 
{ 
    local opt=$1 f=;
    shift;
    for f in "$@";
    do
        if [[ $opt == @(dir|all) && -d "$f" ]]; then
            echo "$f/";
        else
            if [[ $opt == @(file|all) ]]; then
                local dn= fn="$f";
                [[ "$f" == */* ]] && dn=${f%\/*}/ fn=${f##*\/};
                [ -f "${dn}.svn/text-base/${fn}.svn-base" ] && echo "$f";
            fi;
        fi;
    done
}
_svn_read_hashfile () 
{ 
    local tkey=$1 key= val=;
    while true; do
        read tag len;
        [ $tag = 'END' ] && break;
        [ $tag != 'K' ] && { 
            return
        };
        read -r -n $len key;
        read;
        read tag len;
        [ $tag != 'V' ] && { 
            return
        };
        read -r -n $len val;
        read;
        if [[ $key = $tkey ]]; then
            echo "$val";
            return;
        fi;
    done
}
_svnadmin () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='crashtest create deltify dump help hotcopy list-dblogs \
	      list-unused-dblogs load lslocks lstxns pack recover rmlocks \
	      rmtxns setlog setrevprop setuuid upgrade verify --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|--parent-dir|--fs-type";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        create)
            cmdOpts="--bdb-txn-nosync --bdb-log-keep --config-dir 		         --fs-type --pre-1.4-compatible --pre-1.5-compatible"
        ;;
        deltify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        dump)
            cmdOpts="-r --revision --incremental -q --quiet --deltas"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        hotcopy)
            cmdOpts="--clean-logs"
        ;;
        load)
            cmdOpts="--ignore-uuid --force-uuid --parent-dir -q --quiet 		         --use-pre-commit-hook --use-post-commit-hook"
        ;;
        recover)
            cmdOpts="--wait"
        ;;
        rmtxns)
            cmdOpts="-q --quiet"
        ;;
        setlog)
            cmdOpts="-r --revision --bypass-hooks"
        ;;
        setrevprop)
            cmdOpts="-r --revision --use-pre-revprop-change-hook 		         --use-post-revprop-change-hook"
        ;;
        verify)
            cmdOpts="-r --revision -q --quiet"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svndumpfilter () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='exclude help include --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--targets";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        exclude | include)
            cmdOpts="--drop-empty-revs --renumber-revs
		         --skip-missing-merge-sources --targets
		         --preserve-revprops --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnlook () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='author cat changed date diff dirs-changed help history info \
	      lock log propget proplist tree uuid youngest --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="-r|--revision|-t|--transaction|-l|--limit|-x|--extensions";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        author)
            cmdOpts="-r --revision -t --transaction"
        ;;
        cat)
            cmdOpts="-r --revision -t --transaction"
        ;;
        changed)
            cmdOpts="-r --revision -t --transaction --copy-info"
        ;;
        date)
            cmdOpts="-r --revision -t --transaction"
        ;;
        diff)
            cmdOpts="-r --revision -t --transaction --diff-copy-from 		         --no-diff-added --no-diff-deleted -x --extensions"
        ;;
        dirs-changed)
            cmdOpts="-r --revision -t --transaction"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        history)
            cmdOpts="-r --revision -l --limit --show-ids"
        ;;
        info)
            cmdOpts="-r --revision -t --transaction"
        ;;
        lock)
            cmdOpts=
        ;;
        log)
            cmdOpts="-r --revision -t --transaction"
        ;;
        propget | pget | pg)
            cmdOpts="-r --revision -t --transaction --revprop"
        ;;
        proplist | plist | pl)
            cmdOpts="-r --revision -t --transaction --revprop -v --verbose --xml"
        ;;
        tree)
            cmdOpts="-r --revision -t --transaction --full-paths -N --non-recursive --show-ids"
        ;;
        uuid)
            cmdOpts=
        ;;
        youngest)
            cmdOpts=
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -N)
                cmdOpts=${cmdOpts/ --non-recursive / }
            ;;
            --non-recursive)
                cmdOpts=${cmdOpts/ -N / }
            ;;
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -l)
                cmdOpts=${cmdOpts/ --limit / }
            ;;
            --limit)
                cmdOpts=${cmdOpts/ -l / }
            ;;
            -r)
                cmdOpts=${cmdOpts/ --revision / }
            ;;
            --revision)
                cmdOpts=${cmdOpts/ -r / }
            ;;
            -t)
                cmdOpts=${cmdOpts/ --transaction / }
            ;;
            --transaction)
                cmdOpts=${cmdOpts/ -t / }
            ;;
            -v)
                cmdOpts=${cmdOpts/ --verbose / }
            ;;
            --verbose)
                cmdOpts=${cmdOpts/ -v / }
            ;;
            -x)
                cmdOpts=${cmdOpts/ --extensions / }
            ;;
            --extensions)
                cmdOpts=${cmdOpts/ -x / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_svnsync () 
{ 
    local cur cmds cmdOpts optsParam opt helpCmds optBase i;
    COMPREPLY=();
    cur=${COMP_WORDS[COMP_CWORD]};
    cmds='copy-revprops help info initialize synchronize --version';
    if [[ $COMP_CWORD -eq 1 ]]; then
        COMPREPLY=($( compgen -W "$cmds" -- $cur ));
        return 0;
    fi;
    optsParam="--config-dir|--config-option|--source-username|--source-password";
    optsParam="$optsParam|--sync-username|--sync-password";
    helpCmds='help|--help|h|\?';
    if [[ ${COMP_WORDS[1]} != @($helpCmds) ]] && [[ "$cur" != -* ]] || [[ ${COMP_WORDS[COMP_CWORD-1]} == @($optsParam) ]]; then
        return 0;
    fi;
    cmdOpts=;
    case ${COMP_WORDS[1]} in 
        copy-revprops | initialize | init | synchronize | sync)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option -q --quiet"
        ;;
        help | h | \?)
            cmdOpts="$cmds"
        ;;
        info)
            cmdOpts="--non-interactive --no-auth-cache --trust-server-cert 		         --source-username --source-password --sync-username 		         --sync-password --config-dir --config-option"
        ;;
        *)

        ;;
    esac;
    cmdOpts="$cmdOpts --help -h";
    for ((i=2; i<=$COMP_CWORD-1; ++i ))
    do
        opt=${COMP_WORDS[$i]};
        case $opt in 
            --*)
                optBase=${opt/=*/}
            ;;
            -*)
                optBase=${opt:0:2}
            ;;
        esac;
        cmdOpts=" $cmdOpts ";
        cmdOpts=${cmdOpts/ ${optBase} / };
        case $optBase in 
            -h)
                cmdOpts=${cmdOpts/ --help / }
            ;;
            --help)
                cmdOpts=${cmdOpts/ -h / }
            ;;
            -q)
                cmdOpts=${cmdOpts/ --quiet / }
            ;;
            --quiet)
                cmdOpts=${cmdOpts/ -q / }
            ;;
        esac;
        if [[ $opt == @($optsParam) ]]; then
            ((++i));
        fi;
    done;
    COMPREPLY=($( compgen -W "$cmdOpts" -- $cur ));
    return 0
}
_sysctl () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    COMPREPLY=($( compgen -W "$(sysctl -N -a 2>/dev/null)" -- "$cur" ));
    return 0
}
_tar () 
{ 
    local cur ext regex tar untar;
    COMPREPLY=();
    cur=`_get_cword`;
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W 'c t x u r d A' -- "$cur" ));
        return 0;
    fi;
    case "${COMP_WORDS[1]}" in 
        ?(-)[cr]*f)
            _filedir;
            return 0
        ;;
        +([^IZzJjy])f)
            ext='t@(ar?(.@(Z|gz|bz?(2)|lz?(ma)))|gz|bz?(2)|lz?(ma))';
            regex='t\(ar\(\.\(Z\|gz\|bz2\?\|lzma\|xz\)\)\?\|gz\|bz2\?\|lzma\|xz\)'
        ;;
        *[Zz]*f)
            ext='t?(ar.)@(gz|Z)';
            regex='t\(ar\.\)\?\(gz\|Z\)'
        ;;
        *[Ijy]*f)
            ext='t?(ar.)bz?(2)';
            regex='t\(ar\.\)\?bz2\?'
        ;;
        *[J]*f)
            ext='t?(ar.)@(lz?(ma)|xz)';
            regex='t\(ar\.\)\?\(lzma\|xz\)\?'
        ;;
        *)
            _filedir;
            return 0
        ;;
    esac;
    if [[ "$COMP_LINE" == *$ext' ' ]]; then
        tar=$( echo "$COMP_LINE" | sed -e 's/^.* \([^ ]*'$regex'\) .*$/\1/' );
        untar=t${COMP_WORDS[1]//[^Izjyf]/};
        COMPREPLY=($( compgen -W "$( echo $( tar $untar $tar             2>/dev/null ) )" -- "$cur" ));
        return 0;
    fi;
    _filedir "$ext";
    return 0
}
_tcpdump () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -@(r|w|F))
            _filedir;
            return 0
        ;;
        -i)
            _available_interfaces -a;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a -d -e -f -l -n -N -O -p \
            -q -R -S -t -u -v -x -C -F -i -m -r -s -T -w -E' -- "$cur" ));
    fi
}
_ufw () 
{ 
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$(_ufw_commands)" $cur ));
    else
        if [ $COMP_CWORD -eq 2 ]; then
            case "$prev" in 
                app)
                    COMPREPLY=($( compgen -W "$(_ufw_app_commands)" $cur ))
                ;;
                status)
                    COMPREPLY=($( compgen -W "$(_ufw_status_commands)" $cur ))
                ;;
                delete)
                    COMPREPLY=($( compgen -W "$(_ufw_rule_commands)" $cur ))
                ;;
                logging)
                    COMPREPLY=($( compgen -W "$(_ufw_logging_commands)" $cur ))
                ;;
                show)
                    COMPREPLY=($( compgen -W "$(_ufw_show_commands)" $cur ))
                ;;
                default)
                    COMPREPLY=($( compgen -W "$(_ufw_default_commands)" $cur ))
                ;;
            esac;
        fi;
    fi
}
_ufw_app_commands () 
{ 
    ufw --help | sed -e '1,/^Application profile commands:/d' -e '/^ [^ ]/!d' -e 's/[ \t]\+app[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g'
}
_ufw_commands () 
{ 
    commands=$(ufw --help | sed -e '1,/^Commands:/d' -e '/^Application profile commands:/Q' -e 's/^[ \t]\+\([a-z|]\+\)[ \t]\+.*/\1/g' -e 's/|/ /g' | uniq);
    echo "$commands app"
}
_ufw_default_commands () 
{ 
    echo "allow deny reject"
}
_ufw_logging_commands () 
{ 
    echo "off on low medium high full"
}
_ufw_rule_commands () 
{ 
    echo "`_ufw_default_commands` limit"
}
_ufw_show_commands () 
{ 
    echo "raw"
}
_ufw_status_commands () 
{ 
    echo "numbered verbose"
}
_uids () 
{ 
    if type getent &>/dev/null; then
        COMPREPLY=($( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ));
    else
        if type perl &>/dev/null; then
            COMPREPLY=($( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ));
        else
            COMPREPLY=($( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ));
        fi;
    fi
}
_umount () 
{ 
    local cur IFS='
';
    COMPREPLY=();
    cur=`_get_cword`;
    COMPREPLY=($( compgen -W '$( mount | cut -d" " -f 3 )' -- "$cur" ));
    return 0
}
_unrar () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    case "$cur" in 
        -*)
            COMPREPLY=($( compgen -W '-ad -ap -av- -c- -cfg- -cl -cu \
            -dh -ep -f -idp -ierr -inul -kb -o+ -o- -ow -p -p- -r -ta \
            -tb -tn -to -u -v -ver -vp -x -x@ -y' -- "$cur" ))
        ;;
        *)
            if [ $COMP_CWORD -eq 1 ]; then
                COMPREPLY=($( compgen -W 'e l lb lt p t v vb vt x' -- "$cur" ));
            else
                _filedir '@(rar|RAR)';
            fi
        ;;
    esac;
    return 0
}
_update_alternatives () 
{ 
    local cur prev mode args i;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        --@(altdir|admindir))
            _filedir -d;
            return 0
        ;;
        --@(help|version))
            return 0
        ;;
    esac;
    for ((i=1; i < COMP_CWORD; i++ ))
    do
        if [[ "${COMP_WORDS[i]}" == --@(install|remove|auto|display|config|remove-all) ]]; then
            mode=${COMP_WORDS[i]};
            args=$(($COMP_CWORD - i));
            break;
        fi;
    done;
    case $mode in 
        --install)
            case $args in 
                1)
                    _filedir
                ;;
                2)
                    _installed_alternatives
                ;;
                3)
                    _filedir
                ;;
            esac
        ;;
        --remove)
            case $args in 
                1)
                    _installed_alternatives
                ;;
                2)
                    _filedir
                ;;
            esac
        ;;
        --auto)
            _installed_alternatives
        ;;
        --remove-all)
            _installed_alternatives
        ;;
        --display)
            _installed_alternatives
        ;;
        --config)
            _installed_alternatives
        ;;
        *)
            COMPREPLY=($( compgen -W '--verbose --quiet --help --version \
                   --altdir --admindir' -- "$cur" ) $( compgen -W '--install --remove --auto --display \
                   --config' -- "$cur" ))
        ;;
    esac
}
_update_rc_d () 
{ 
    local cur prev sysvdir services options valid_options;
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    [ -d /etc/rc.d/init.d ] && sysvdir=/etc/rc.d/init.d || sysvdir=/etc/init.d;
    services=($(echo $sysvdir/!(README*|*.sh|*.dpkg*|*.rpm@(orig|new|save))));
    services=(${services[@]#$sysvdir/});
    options=(-f -n);
    if [[ $COMP_CWORD -eq 1 || "$prev" == -* ]]; then
        valid_options=($(         echo "${COMP_WORDS[@]} ${options[@]}"         | tr " " "\n"         | sed -ne "/$( echo "${options[@]}" | sed "s/ /\\|/g" )/p"         | sort | uniq -u         ));
        COMPREPLY=($( compgen -W '${options[@]} ${services[@]}'         -X '$( echo ${COMP_WORDS[@]} | tr " " "|" )' -- "$cur" ));
    else
        if [[ "$prev" == ?($( echo ${services[@]} | tr " " "|" )) ]]; then
            COMPREPLY=($( compgen -W 'remove defaults start stop' -- "$cur" ));
        else
            if [[ "$prev" == defaults && "$cur" == [0-9] ]]; then
                COMPREPLY=(0 1 2 3 4 5 6 7 8 9);
            else
                if [[ "$prev" == defaults && "$cur" == [sk]?([0-9]) ]]; then
                    COMPREPLY=(0 1 2 3 4 5 6 7 8 9);
                else
                    if [[ "$prev" == defaults && -z "$cur" ]]; then
                        COMPREPLY=(0 1 2 3 4 5 6 7 8 9 s k);
                    else
                        if [[ "$prev" == ?(start|stop) ]]; then
                            if [[ "$cur" == [0-9] || -z "$cur" ]]; then
                                COMPREPLY=(0 1 2 3 4 5 6 7 8 9);
                            else
                                if [[ "$cur" == [0-9][0-9] ]]; then
                                    COMPREPLY=($cur);
                                else
                                    COMPREPLY=();
                                fi;
                            fi;
                        else
                            if [[ "$prev" == ?([0-9][0-9]|[0-6S]) ]]; then
                                if [[ -z "$cur" ]]; then
                                    if [[ $prev == [0-9][0-9] ]]; then
                                        COMPREPLY=(0 1 2 3 4 5 6 S);
                                    else
                                        COMPREPLY=(0 1 2 3 4 5 6 S .);
                                    fi;
                                else
                                    if [[ "$cur" == [0-6S.] ]]; then
                                        COMPREPLY=($cur);
                                    else
                                        COMPREPLY=();
                                    fi;
                                fi;
                            else
                                if [[ "$prev" == "." ]]; then
                                    COMPREPLY=($(compgen -W "start stop" -- "$cur"));
                                else
                                    COMPREPLY=();
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi;
    return 0
}
_usb_ids () 
{ 
    COMPREPLY=(${COMPREPLY[@]:-} $( compgen -W     "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ))
}
_user_at_host () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($( compgen -u -- "$cur" ));
    fi;
    return 0
}
_useradd () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -c | --comment | -h | --help | -e | --expiredate | -f | --inactive | -k | --key | -p | --password | -u | --uid | -Z | --selinux-user)
            return 0
        ;;
        -b | --base-dir | -d | --home | -k | --skel)
            _filedir -d;
            return 0
        ;;
        -g | --gid)
            _gids;
            [ -n "$bash205" ] && COMPREPLY=("${COMPREPLY[@]}" $( compgen -g ));
            COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
            return 0
        ;;
        -G | --groups)
            [ -n "$bash205" ] && COMPREPLY=($( compgen -g -- "$cur" ));
            return 0
        ;;
        -s | --shell)
            _shells;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-b --base-dir -c --comment -d --home\
            -D --defaults -e --expiredate -f --inactive -g --gid \
            -G --groups -h --help -k --skel -K --key -l -M \
            -m --create-home -N --no-user-group -o --non-unique \
            -p --password -r --system -s --shell -u --uid \
            -U --user-group -Z --selinux-user' -- "$cur" ));
        return 0;
    fi
}
_userdel () 
{ 
    local cur;
    COMPREPLY=();
    cur=`_get_cword`;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-f --force -h --help -r --remove'             -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -u -- "$cur" ))
}
_usergroup () 
{ 
    local IFS='
';
    cur=${cur//\\\\ / };
    if [[ $cur = *@(\\:|.)* ]] && [ -n "$bash205" ]; then
        user=${cur%%*([^:.])};
        COMPREPLY=($(compgen -P ${user/\\\\} -g -- ${cur##*[.:]}));
    else
        if [[ $cur = *:* ]] && [ -n "$bash205" ]; then
            COMPREPLY=($( compgen -g -- ${cur##*[.:]} ));
        else
            COMPREPLY=($( compgen -S : -u -- "$cur" ));
        fi;
    fi
}
_usermod () 
{ 
    local cur prev split=false;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    _split_longopt && split=true;
    case "$prev" in 
        -c | --comment | -d | --home | -e | --expiredate | -f | --inactive | -h | --help | -l | --login | -p | --password | -u | --uid | -Z | --selinux-user)
            return 0
        ;;
        -g | --gid)
            _gids;
            [ -n "$bash205" ] && COMPREPLY=("${COMPREPLY[@]}" $( compgen -g ));
            COMPREPLY=($( compgen -W '${COMPREPLY[@]}' -- "$cur" ));
            return 0
        ;;
        -G | --groups)
            [ -n "$bash205" ] && COMPREPLY=($( compgen -g -- "$cur" ));
            return 0
        ;;
        -s | --shell)
            _shells;
            return 0
        ;;
    esac;
    $split && return 0;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-a --append -c --comment -d --home \
            -e --expiredate -f --inactive -g --gid -G --groups \
            -h --help -l --login -L --lock -o --non-unique \
            -p --password -s --shell -u --uid -U --unlock \
            -Z --selinux-user' -- "$cur" ));
        return 0;
    fi;
    COMPREPLY=($( compgen -u -- "$cur" ))
}
_vipw () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -h | --help)
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-g --group -h --help -p --passwd \
            -q --quiet -s --shadow' -- "$cur" ));
        return 0;
    fi
}
_xhost () 
{ 
    local cur=`_get_cword`;
    case "$cur" in 
        +*)
            _known_hosts_real -p+ "${cur:1}"
        ;;
        -*)
            _known_hosts_real -p- "${cur:1}"
        ;;
        *)
            _known_hosts_real "$cur"
        ;;
    esac;
    return 0
}
_xmllint () 
{ 
    local cur prev;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        -o | --output)
            _filedir;
            return 0
        ;;
        --path | --dtdvalidfpi | --maxmem | --encode | --pattern)
            return 0
        ;;
        --dtdvalid)
            _filedir dtd;
            return 0
        ;;
        --relaxng)
            _filedir rng;
            return 0
        ;;
        --schema)
            _filedir xsd;
            return 0
        ;;
        --schematron)
            _filedir sch;
            return 0
        ;;
    esac;
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '$( xmllint --help 2>&1 | \
            sed -ne "s/^[[:space:]]*\(--[^[:space:]:]*\).*/\1/p" ) \
            -o' -- "$cur" ));
        return 0;
    fi;
    _filedir '@(*ml|htm|svg)'
}
_xrandr () 
{ 
    local cur prev output modes;
    COMPREPLY=();
    cur=`_get_cword`;
    prev=${COMP_WORDS[COMP_CWORD-1]};
    case "$prev" in 
        --output)
            local outputs=$(xrandr|grep 'connected'|awk '{print $1}');
            COMPREPLY=($(compgen -W "$outputs" -- "$cur"));
            return 0
        ;;
        --mode)
            for ((i = 1; i < COMP_CWORD; i++ ))
            do
                if [[ "${COMP_WORDS[i]}" == "--output" ]]; then
                    output=${COMP_WORDS[i+1]};
                    break;
                fi;
            done;
            modes=$(xrandr|sed -e "1,/$output/ d"                 -e "/connected/,$ d"|awk '{print $1}');
            COMPREPLY=($( compgen -W "$modes" -- "$cur"));
            return 0
        ;;
    esac;
    case "$cur" in 
        *)
            COMPREPLY=($(compgen -W '-d -display -help -o \
                    --orientation -q --query -s --size\
                    -r --rate -v --version -x -y --screen \
                    --verbose --dryrun --prop --fb \
                    --fbmm --dpi --output --auto --mode \
                    --preferred --pos --reflect --rotate \
                    --left-of --right-of --above --below \
                    --same-as --set --off --crtc --newmode \
                    --rmmode --addmode --delmode' -- "$cur"));
            return 0
        ;;
    esac;
    return 0
}
_xz () 
{ 
    COMPREPLY=();
    local cur=`_get_cword`;
    local prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-z --compress -d --decompress \
            -t --test -l --list -k --keep -f --force -c --stdout \
            -S --suffix --files --files0 -F --format -C --check \
            -0 -1 -2 -3 -4 -5 -6 -7 -8 -9 -M --memory --lzma1 \
            --lzma2 --x86 --powerpc --ia64 --arm --armthumb \
            --sparc --delta -q --quiet -v --verbose -h --help \
            -H --long-help -V --version' -- "$cur" ));
        return 0;
    fi;
    local split=false;
    _split_longopt && split=true;
    local xspec="*.@(xz|lzma)";
    case "$prev" in 
        -@(!(-*)[dlt]*|-decompress|-list|-test))
            xspec="!"$xspec
        ;;
        --files | --files0)
            _filedir;
            return 0
        ;;
        -C | --check)
            COMPREPLY=($( compgen -W 'crc32 crc64 sha256' -- "$cur" ));
            return 0
        ;;
        -F | --format)
            COMPREPLY=($( compgen -W 'auto xz lzma raw' -- "$cur" ));
            return 0
        ;;
        -M | --memory | -S | --suffix | --delta | --lzma1 | --lzma2)
            return 0
        ;;
        -h | --help | -H | --long-help | -V | --version)
            return 0
        ;;
    esac;
    $split && return 0;
    _expand || return 0;
    local IFS='	
';
    COMPREPLY=($( compgen -f -X "$xspec" -- "$cur" ) $( compgen -d -- "$cur" ))
}
_xzdec () 
{ 
    COMPREPLY=();
    local cur=`_get_cword`;
    local prev=${COMP_WORDS[COMP_CWORD-1]};
    if [[ "$cur" == -* ]]; then
        COMPREPLY=($( compgen -W '-M --memory -h --help -V --version'             -- "$cur" ));
        return 0;
    fi;
    local split=false;
    _split_longopt && split=true;
    case "$prev" in 
        -M | --memory)
            return 0
        ;;
        -h | --help | -V | --version)
            return 0
        ;;
    esac;
    $split && return 0;
    _filedir xz
}
command_not_found_handle () 
{ 
    if [ -x /usr/lib/command-not-found ]; then
        /usr/bin/python /usr/lib/command-not-found -- $1;
        return $?;
    else
        if [ -x /usr/share/command-not-found ]; then
            /usr/bin/python /usr/share/command-not-found -- $1;
            return $?;
        else
            return 127;
        fi;
    fi
}
dequote () 
{ 
    eval echo "$1" 2> /dev/null
}
quote () 
{ 
    echo \'${1//\'/\'\\\'\'}\'
}
quote_readline () 
{ 
    if [ -n "$bash4" ]; then
        echo "${1}";
        return;
    fi;
    local t="${1//\\/\\\\}";
    echo \'${t//\'/\'\\\'\'}\'
}
