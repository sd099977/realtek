/* DO NOT EDIT THIS FILE!!!
 * This file was automatically generated by msgbuf compiler!
 *
 * This file contains the msgbuf structure definitions associated
 * to the package nhtctd.proto
 */


/*****************************************************************************
 * include files                                                             *
 ****************************************************************************/

#include "inc/rpc_nhtctd.h"
#include "src/rpc_nhtctd_api.h"
#include "inc/nv_nhtctd.h"
#include "nocs_nhtctd.h"
#include "inc/msgbuf_sys_string.h"
#include "inc/msgbuf_sys_malloc.h"
#include "inc/TRACE_nhtctd.h"
#include "inc/nv_nhtctd.h"
#include <stddef.h>


#define DSC_TEST_RUN_MAGIC_NUMBER  0xCAFEDECA

typedef struct SRpcCtdDscTestRunHandle
{
  volatile uint32_t                    magicNumber;
  TMsgBuf_rpcHandler                   rpcHandler;
  TCtdDscTestRunSession                dscHandle;
  int64_t                              ecmCallBackHandle;
  TCtdDscCallBackPrivateParameters     privateData;
  volatile TCtdUnsignedInt8            lastTableId;

} TRpcCtdDscTestRunHandle;


/****************************************************************************
 * Static function prototypes                                               *
 ****************************************************************************/

static TCtdStatus rpcCtdEcmCallBackFunction (
        TCtdDscTestRunSession                 xDscTestRunSession,
        TCtdDscCallBackPrivateParameters      xPrivateParameters,
        TCtdUnsignedInt8                      xEcmTableId,
  const TCtdUnsignedInt8                    * pxEcmContent,
        TCtdSize                              xEcmContentSize );


/*****************************************************************************
 * RPC methods implementation                                                *
 ****************************************************************************/

/* RPC method: rpc_nhtctd_hc_nht_initializeResourceUsage
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_initializeResourceUsage
(
  TMsgBuf_rpcHandler         xRpcHandler,
  const TNhtctd_EmptyMsg   * pxInputMessage,
  TNhtctd_CtdStatusOutMsg ** pxOutputMessage
)
{
  TCtdStatus ctdStatus;

  ctdStatus = _CRPC(nhtCtdInitialize) ();
  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;

  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_terminateResourceUsage
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_terminateResourceUsage
(
  TMsgBuf_rpcHandler         xRpcHandler,
  const TNhtctd_EmptyMsg   * pxInputMessage,
  TNhtctd_CtdStatusOutMsg ** pxOutputMessage
)
{
  TCtdStatus ctdStatus;

  ctdStatus = _CRPC(nhtCtdTerminate) ();
  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;

  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_getNhtCtdSoftwareVersion
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getNhtCtdSoftwareVersion
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtctd_OptOutput1InMsg  * pxInputMessage,
  TNhtctd_StringOutMsg          ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;
  TCtd20CharsString   swVersionName;

  if (pxInputMessage->has_output)
  {
    ctdStatus = _CRPC(nhtCtdGetSoftwareVersion) (swVersionName);
    (*pxOutputMessage)->info = (char*)MSGBUF_SYS_malloc (sizeof(TCtd20CharsString) + 1);

    if ((*pxOutputMessage)->info == NULL) return RPC_STATUS_MALLOC_ERROR;
    MSGBUF_SYS_memcpy ((*pxOutputMessage)->info, &swVersionName[0], sizeof(TCtd20CharsString));
    (*pxOutputMessage)->info[sizeof(TCtd20CharsString)] = 0;
  }
  else ctdStatus = nhtCtdGetSoftwareVersion (NULL);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_getNhtCtdApiVersion
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getNhtCtdApiVersion
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtctd_OptOutput1InMsg  * pxInputMessage,
  TNhtctd_IntValueOutMsg        ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;
  TCtdUnsignedInt32   version;
  TCtdUnsignedInt32 * pVersion = NULL;

  if (pxInputMessage->has_output)
    pVersion = &version;

  ctdStatus = _CRPC(nhtCtdGetApiVersion) (pVersion);

  if (pVersion && (ctdStatus == CTD_NO_ERROR))
  {
    (*pxOutputMessage)->has_value = 1;
    (*pxOutputMessage)->value = (uint32_t)*pVersion;
  }

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hn_nht_ChipReset
 *
 * This method stands as an asynchronous notification function.
 * Caller of this function immediately returns without waiting
 * the completion of its remote execution.
 *
 * PS: param 'pxOutputMessage' is always assumed to be NULL.
 */
TRpc_status rpc_nhtctd_hn_nht_ChipReset
(
  TMsgBuf_rpcHandler             xRpcHandler,
  const TNhtctd_IntValueInMsg  * pxInputMessage,
  TNhtctd_EmptyMsg            ** pxOutputMessage
)
{
  _CRPC(nhtCtdChipReset) ((TCtdResetType)pxInputMessage->value);
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hn_nht_chipSuspend2Ram
 *
 * This method stands as an asynchronous notification function.
 * Caller of this function immediately returns without waiting
 * the completion of its remote execution.
 *
 * PS: param 'pxOutputMessage' is always assumed to be NULL.
 */
TRpc_status rpc_nhtctd_hn_nht_chipSuspend2Ram
(
  TMsgBuf_rpcHandler        xRpcHandler,
  const TNhtctd_EmptyMsg  * pxInputMessage,
  TNhtctd_EmptyMsg       ** pxOutputMessage
)
{
  _CRPC(nhtCtdChipSuspend2Ram) ();
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nth_enableRamScrambling
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nth_enableRamScrambling
(
  TMsgBuf_rpcHandler         xRpcHandler,
  const TNhtctd_EmptyMsg   * pxInputMessage,
  TNhtctd_CtdStatusOutMsg ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;

  ctdStatus = _CRPC(nhtCtdEnableRamScrambling) ();

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nth_disableRamScrambling
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nth_disableRamScrambling
(
  TMsgBuf_rpcHandler         xRpcHandler,
  const TNhtctd_EmptyMsg   * pxInputMessage,
  TNhtctd_CtdStatusOutMsg ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;

  ctdStatus = _CRPC(nhtCtdDisableRamScrambling) ();

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_isRamScramblingEnabled
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_isRamScramblingEnabled
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtctd_OptOutput1InMsg  * pxInputMessage,
  TNhtctd_BooleanOutMsg         ** pxOutputMessage
)
{
  TCtdStatus    ctdStatus;
  TCtdBoolean   isEnabled = 0;
  TCtdBoolean * pIsEnabled = NULL;

  if (pxInputMessage->has_output)
    pIsEnabled = &isEnabled;

  ctdStatus = _CRPC(nhtCtdIsRamScramblingEnabled) (pIsEnabled);

  (*pxOutputMessage)->boolean   = (TMsgBuf_bool)isEnabled;
  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_getFlashMemorySize
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getFlashMemorySize
(
  TMsgBuf_rpcHandler                 xRpcHandler,
  const TNhtctd_GetFlashSizeInMsg  * pxInputMessage,
  TNhtctd_MemorySizeOutMsg        ** pxOutputMessage
)
{
  TCtdStatus  ctdStatus;
  TCtdSize    memSize;
  TCtdSize   * pMemSize = NULL;

  if (pxInputMessage->hasSizeOutput) pMemSize = &memSize;

  ctdStatus = _CRPC(nhtCtdGetFlashMemorySize) (
    (TCtdFlashType)pxInputMessage->flashId,
    pMemSize);

  if (pMemSize)
  {
    (*pxOutputMessage)->has_memorySize  = 1;
    (*pxOutputMessage)->memorySize      = (int64_t)memSize;
  }

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_flashRead
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_flashRead
(
  TMsgBuf_rpcHandler              xRpcHandler,
  const TNhtctd_FlashReadInMsg  * pxInputMessage,
  TNhtctd_BytesOutMsg          ** pxOutputMessage
)
{
  TCtdStatus         ctdStatus;
  TCtdFlashType      flashType = (TCtdFlashType)pxInputMessage->flashId;
  TCtdSize           address   = (TCtdSize)pxInputMessage->flashAddress;
  TCtdSize           dataSize  = (TCtdSize)pxInputMessage->dataSize;
  TCtdUnsignedInt8 * pData     = NULL;

  if (pxInputMessage->has_output)
  {
    pData = (TCtdUnsignedInt8*)MSGBUF_SYS_malloc(dataSize);
  }

  ctdStatus = _CRPC(nhtCtdFlashRead) (
    flashType,
    address,
    dataSize,
    pData );

  if ((ctdStatus == CTD_NO_ERROR) && pData)
  {
    (*pxOutputMessage)->dataOut.pData = pData;
    (*pxOutputMessage)->dataOut.len   = dataSize;
    pData = NULL;
  }

  if (pData) MSGBUF_SYS_free(pData);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_flashWrite
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_flashWrite
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtctd_FlashWriteInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg       ** pxOutputMessage
)
{
  TCtdStatus         ctdStatus;
  TCtdFlashType      flashType = (TCtdFlashType)pxInputMessage->flashId;
  TCtdSize           address   = (TCtdSize)pxInputMessage->flashAddress;
  TCtdSize           dataSize  = (TCtdSize)pxInputMessage->dataSize;
  TCtdUnsignedInt8 * pData     = (TCtdUnsignedInt8*)pxInputMessage->dataIn.pData;


  ctdStatus = _CRPC(nhtCtdFlashWrite) (
    flashType,
    address,
    dataSize,
    pData );

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_getRamMemorySize
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getRamMemorySize
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtctd_GetRamSizeInMsg  * pxInputMessage,
  TNhtctd_MemorySizeOutMsg      ** pxOutputMessage
)
{
  TCtdStatus  ctdStatus;
  TCtdSize    memSize;
  TCtdSize   * pMemSize = NULL;

  if (pxInputMessage->hasSizeOutput) pMemSize = &memSize;

  ctdStatus = _CRPC(nhtCtdGetRamMemorySize) (
    pMemSize);

  if (pMemSize)
  {
    (*pxOutputMessage)->has_memorySize  = 1;
    (*pxOutputMessage)->memorySize      = (int64_t)memSize;
  }

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_ramRead
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_ramRead
(
  TMsgBuf_rpcHandler            xRpcHandler,
  const TNhtctd_RamReadInMsg  * pxInputMessage,
  TNhtctd_BytesOutMsg        ** pxOutputMessage
)
{
  TCtdStatus         ctdStatus;
  TCtdSize           address   = (TCtdSize)pxInputMessage->ramAddress;
  TCtdSize           dataSize  = (TCtdSize)pxInputMessage->dataSize;
  TCtdUnsignedInt8 * pData     = NULL;

  if (pxInputMessage->has_output)
  {
    pData = (TCtdUnsignedInt8*)MSGBUF_SYS_malloc(dataSize);
  }

  ctdStatus = _CRPC(nhtCtdRamRead) (
    address,
    dataSize,
    pData );

  if ((ctdStatus == CTD_NO_ERROR) && pData)
  {
    (*pxOutputMessage)->dataOut.pData = pData;
    (*pxOutputMessage)->dataOut.len   = dataSize;
    pData = NULL;
  }

  if (pData) MSGBUF_SYS_free(pData);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_ramWrite
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_ramWrite
(
  TMsgBuf_rpcHandler             xRpcHandler,
  const TNhtctd_RamWriteInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg     ** pxOutputMessage
)
{
  TCtdStatus         ctdStatus;
  TCtdSize           address   = (TCtdSize)pxInputMessage->ramAddress;
  TCtdSize           dataSize  = (TCtdSize)pxInputMessage->dataSize;
  TCtdUnsignedInt8 * pData     = (TCtdUnsignedInt8*)pxInputMessage->dataIn.pData;


  ctdStatus = _CRPC(nhtCtdRamWrite) (
    address,
    dataSize,
    pData );

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_getSpecificPvDescriptorNumber
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getSpecificPvDescriptorNumber
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtctd_OptOutput1InMsg  * pxInputMessage,
  TNhtctd_IntValueOutMsg        ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;
  TCtdUnsignedInt32   number;
  TCtdUnsignedInt32 * pNumber = NULL;

  if (pxInputMessage->has_output) pNumber = &number;

  ctdStatus = _CRPC(nhtCtdGetSpecificPvDescriptorNumber) (pNumber);

  if (pNumber)
  {
    (*pxOutputMessage)->has_value = 1;
    (*pxOutputMessage)->value     = (int32_t)number;
  }

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_getSpecificPvDescriptorSet
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getSpecificPvDescriptorSet
(
  TMsgBuf_rpcHandler                       xRpcHandler,
  const TNhtctd_GetPvDescriptorSetInMsg  * pxInputMessage,
  TNhtctd_GetPvDescriptorSetOutMsg      ** pxOutputMessage
)
{
  TCtdStatus                 ctdStatus;
  TCtdUnsignedInt32          number = (TCtdUnsignedInt32)pxInputMessage->pvDescNumber;
  TCtdUnsignedInt32          effNumber = number;
  TCtdUnsignedInt32        * pEffNumber = NULL;
  TCtdSpecificPvDescriptor * pDescriptors = NULL;

  if (pxInputMessage->has_descEffNumberOutput)
    pEffNumber = &effNumber;

  if (pxInputMessage->has_descoutput)
    pDescriptors = (TCtdSpecificPvDescriptor*)MSGBUF_SYS_malloc (number * sizeof (TCtdSpecificPvDescriptor));

  ctdStatus = _CRPC(nhtCtdGetSpecificPvDescriptorSet) (
    effNumber,
    pDescriptors,
    pEffNumber );

  if ((ctdStatus == CTD_NO_ERROR) && pDescriptors)
  {
    TCtdUnsignedInt32 i;

    if (effNumber > number) effNumber = number;

    (*pxOutputMessage)->n_pvDescriptors = (size_t)effNumber;
    (*pxOutputMessage)->pvDescriptors = (TNhtctd_PvDescriptorMessage**)MSGBUF_SYS_malloc (effNumber * sizeof(TNhtctd_PvDescriptorMessage*));

    for (i = 0; i < effNumber; i++)
    {
      (*pxOutputMessage)->pvDescriptors[i] = (TNhtctd_PvDescriptorMessage*)MSGBUF_SYS_malloc (sizeof(TNhtctd_PvDescriptorMessage));
      init_Nhtctd_PvDescriptorMessage ((*pxOutputMessage)->pvDescriptors[i]);

      (*pxOutputMessage)->pvDescriptors[i]->pvId = pDescriptors[i].pvId;

      (*pxOutputMessage)->pvDescriptors[i]->pvIdName = (char*)MSGBUF_SYS_malloc (sizeof(TCtd20CharsString) + 1);
      MSGBUF_SYS_strncpy ((*pxOutputMessage)->pvDescriptors[i]->pvIdName, (char*)&pDescriptors[i].pvIdName[0], sizeof(TCtd20CharsString));
      (*pxOutputMessage)->pvDescriptors[i]->pvIdName[20] = 0;
    }
  }

  if (pDescriptors) MSGBUF_SYS_free (pDescriptors);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtctd_hc_nht_getPvStatus
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getPvStatus
(
  TMsgBuf_rpcHandler                xRpcHandler,
  const TNhtctd_GetPvStatusInMsg  * pxInputMessage,
  TNhtctd_IntValueOutMsg         ** pxOutputMessage
)
{
  TCtdStatus        ctdStatus;
  TCtdPvId          pvId  = (TCtdPvId)pxInputMessage->pvId;
  TCtdPvSetStatus   pvStatus;
  TCtdPvSetStatus * pPvStatus = NULL;

  if (pxInputMessage->has_output)
    pPvStatus = &pvStatus;

  ctdStatus = _CRPC(nhtCtdGetPvStatus) (
    pvId,
    pPvStatus );

  if ((ctdStatus == CTD_NO_ERROR) && pPvStatus)
  {
    (*pxOutputMessage)->has_value = 1;
    (*pxOutputMessage)->value = (int32_t)*pPvStatus;
  }

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_setDebugInterfaceMode
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_setDebugInterfaceMode
(
  TMsgBuf_rpcHandler             xRpcHandler,
  const TNhtctd_IntValueInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg     ** pxOutputMessage
)
{
  TCtdStatus         ctdStatus;
  TCtdDifMode        difMode;

  difMode = (TCtdDifMode)pxInputMessage->value;

  ctdStatus = _CRPC(nhtCtdSetDebugInterfaceMode) (difMode);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_getDebugInterfaceMode
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getDebugInterfaceMode
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtctd_OptOutput1InMsg  * pxInputMessage,
  TNhtctd_IntValueOutMsg        ** pxOutputMessage
)
{
  TCtdStatus    ctdStatus;
  TCtdDifMode   difMode;
  TCtdDifMode * pDifMode = NULL;

  if (pxInputMessage->has_output) pDifMode = &difMode;

  ctdStatus = _CRPC(nhtCtdGetDebugInterfaceMode) (pDifMode);

  if ((ctdStatus == CTD_NO_ERROR) && pDifMode)
  {
    (*pxOutputMessage)->has_value = 1;
    (*pxOutputMessage)->value = (int32_t)difMode;
  }

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_setBootMode
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_setBootMode
(
  TMsgBuf_rpcHandler             xRpcHandler,
  const TNhtctd_IntValueInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg     ** pxOutputMessage
)
{
  TCtdStatus         ctdStatus;
  TCtdFlashType      flashType;

  flashType = (TCtdFlashType)pxInputMessage->value;

  ctdStatus = _CRPC(nhtCtdSetBootMode) (flashType);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_getBootMode
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getBootMode
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtctd_OptOutput1InMsg  * pxInputMessage,
  TNhtctd_IntValueOutMsg        ** pxOutputMessage
)
{
  TCtdStatus      ctdStatus;
  TCtdFlashType   flashType;
  TCtdFlashType * pFlashType;

  if (pxInputMessage->has_output) pFlashType = &flashType;

  ctdStatus = _CRPC(nhtCtdGetBootMode) (pFlashType);

  if ((ctdStatus == CTD_NO_ERROR) && pFlashType)
  {
    (*pxOutputMessage)->has_value = 1;
    (*pxOutputMessage)->value = (int32_t)flashType;
  }

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_getPvBufferSize
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getPvBufferSize
(
  TMsgBuf_rpcHandler                  xRpcHandler,
  const TNhtctd_GetBufferSizeInMsg  * pxInputMessage,
  TNhtctd_IntValueOutMsg           ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;
  TCtdPvId            pvId = (TCtdPvId)pxInputMessage->pvId;
  TCtdUnsignedInt32   bufferSize;
  TCtdUnsignedInt32 * pBufferSize = NULL;

  if (pxInputMessage->has_output)
    pBufferSize = &bufferSize;

  ctdStatus = _CRPC(nhtCtdGetPvBufferSize) (
    pvId,
    pBufferSize );

  if ((ctdStatus == CTD_NO_ERROR) && pBufferSize)
  {
    (*pxOutputMessage)->has_value = 1;
    (*pxOutputMessage)->value = (int32_t)*pBufferSize;
  }

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_setPvValue
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_setPvValue
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtctd_SetPvValueInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg       ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;
  TCtdPvId            pvId = (TCtdPvId)pxInputMessage->pvId;
  TCtdUnsignedInt32   bufferSize = (TCtdUnsignedInt32)pxInputMessage->bufferSize;
  TCtdUnsignedInt8  * pValue = pxInputMessage->value.pData;

  ctdStatus = _CRPC(nhtCtdSetPv) (
    pvId,
    bufferSize,
    pValue );

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_getPvValue
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getPvValue
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtctd_GetPvValueInMsg  * pxInputMessage,
  TNhtctd_BytesOutMsg           ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;
  TCtdPvId            pvId = (TCtdPvId)pxInputMessage->pvId;
  TCtdUnsignedInt32   bufferSize = (TCtdUnsignedInt32)pxInputMessage->bufferSize;
  TCtdUnsignedInt8  * pValue = NULL;

  if (pxInputMessage->has_output_value)
    pValue = (TCtdUnsignedInt8*)MSGBUF_SYS_malloc(bufferSize);

  ctdStatus = _CRPC(nhtCtdGetPv) (
    pvId,
    bufferSize,
    pValue );

  if (ctdStatus == CTD_NO_ERROR)
  {
    if (pValue)
    {
      (*pxOutputMessage)->dataOut.pData = pValue;
      (*pxOutputMessage)->dataOut.len = (size_t)bufferSize;
      pValue = NULL;
    }
  }

  if (pValue) MSGBUF_SYS_free (pValue);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtctd_hc_nht_getOtpBufferSize
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getOtpBufferSize
(
  TMsgBuf_rpcHandler                  xRpcHandler,
  const TNhtctd_GetBufferSizeInMsg  * pxInputMessage,
  TNhtctd_IntValueOutMsg           ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;
  TCtdPvId            pvId = (TCtdPvId)pxInputMessage->pvId;
  TCtdUnsignedInt32   bufferSize;
  TCtdUnsignedInt32 * pBufferSize = NULL;

  if (pxInputMessage->has_output)
    pBufferSize = &bufferSize;

  ctdStatus = _CRPC(nhtCtdGetOtpBufferSize) (
    pvId,
    pBufferSize );

  if ((ctdStatus == CTD_NO_ERROR) && pBufferSize)
  {
    (*pxOutputMessage)->has_value = 1;
    (*pxOutputMessage)->value = (int32_t)*pBufferSize;
  }

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_getOtpValueMask
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getOtpValueMask
(
  TMsgBuf_rpcHandler                    xRpcHandler,
  const TNhtctd_GetOtpValueMaskInMsg  * pxInputMessage,
  TNhtctd_BytesOutMsg                ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;
  TCtdPvId            pvId = (TCtdPvId)pxInputMessage->pvId;
  TCtdUnsignedInt32   pvMaskSize = (TCtdUnsignedInt32)pxInputMessage->pvBufferSize;
  TCtdUnsignedInt8  * pMask = NULL;

  if (pxInputMessage->has_output)
    pMask = (TCtdUnsignedInt8*)MSGBUF_SYS_malloc(pvMaskSize);

  ctdStatus = _CRPC(nhtCtdGetOtpValueMask) (
    pvId,
    pvMaskSize,
    pMask );

  if ((ctdStatus == CTD_NO_ERROR) && pMask)
  {
    (*pxOutputMessage)->dataOut.pData = (void*)pMask;
    (*pxOutputMessage)->dataOut.len = (size_t)pvMaskSize;
    pMask = NULL;
  }

  if (pMask) MSGBUF_SYS_free (pMask);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_setPvValue
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_setOtpValue
(
  TMsgBuf_rpcHandler                xRpcHandler,
  const TNhtctd_SetOtpValueInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg        ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;
  TCtdPvId            pvId = (TCtdPvId)pxInputMessage->pvId;
  TCtdUnsignedInt32   bufferSize = (TCtdUnsignedInt32)pxInputMessage->bufferSize;
  TCtdUnsignedInt8  * pValue = pxInputMessage->value.pData;
  TCtdUnsignedInt8  * pMask = pxInputMessage->mask.pData;

  ctdStatus = _CRPC(nhtCtdSetOtp) (
    pvId,
    bufferSize,
    pValue,
    pMask );

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_getPvValue
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_getOtpValue
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtctd_GetPvValueInMsg  * pxInputMessage,
  TNhtctd_BytesOutMsg           ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;
  TCtdPvId            pvId = (TCtdPvId)pxInputMessage->pvId;
  TCtdUnsignedInt32   bufferSize = (TCtdUnsignedInt32)pxInputMessage->bufferSize;
  TCtdUnsignedInt8  * pValue = NULL;

  if (pxInputMessage->has_output_value)
    pValue = (TCtdUnsignedInt8*)MSGBUF_SYS_malloc(bufferSize);

  ctdStatus = _CRPC(nhtCtdGetOtp) (
    pvId,
    bufferSize,
    pValue );

  if (ctdStatus == CTD_NO_ERROR)
  {
    if (pValue)
    {
      (*pxOutputMessage)->dataOut.pData = pValue;
      (*pxOutputMessage)->dataOut.len = (size_t)bufferSize;
      pValue = NULL;
    }
  }

  if (pValue) MSGBUF_SYS_free (pValue);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_openR2rEncryptSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_openR2rEncryptSession
(
  TMsgBuf_rpcHandler              xRpcHandler,
  const TNhtctd_GetHandleInMsg  * pxInputMessage,
  TNhtctd_HandleOutMsg         ** pxOutputMessage
)
{
  TCtdStatus        ctdStatus;
  TCtdR2RSession    r2rSession;
  TCtdR2RSession  * pR2rSession = NULL;

  if (pxInputMessage->has_output)
    pR2rSession = &r2rSession;

  ctdStatus = _CRPC(nhtCtdOpenR2rEncryptSession) (
    pR2rSession );

  if ((ctdStatus == CTD_NO_ERROR) && pR2rSession)
  {
    (*pxOutputMessage)->has_handle = (TMsgBuf_bool)1;
    (*pxOutputMessage)->handle     = (int64_t)(size_t)*pR2rSession;
  }

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_openR2rDecryptSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_openR2rDecryptSession
(
  TMsgBuf_rpcHandler              xRpcHandler,
  const TNhtctd_GetHandleInMsg  * pxInputMessage,
  TNhtctd_HandleOutMsg         ** pxOutputMessage
)
{
  TCtdStatus        ctdStatus;
  TCtdR2RSession    r2rSession;
  TCtdR2RSession  * pR2rSession = NULL;

  if (pxInputMessage->has_output)
    pR2rSession = &r2rSession;

  ctdStatus = _CRPC(nhtCtdOpenR2rDecryptSession) (
    pR2rSession );

  if ((ctdStatus == CTD_NO_ERROR) && pR2rSession)
  {
    (*pxOutputMessage)->has_handle = (TMsgBuf_bool)1;
    (*pxOutputMessage)->handle     = (int64_t)(size_t)*pR2rSession;
  }

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_closeR2rSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_closeR2rSession
(
  TMsgBuf_rpcHandler           xRpcHandler,
  const TNhtctd_HandleInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg   ** pxOutputMessage
)
{
  TCtdStatus        ctdStatus;
  TCtdR2RSession    r2rSession = NULL;

  if (pxInputMessage->has_handle)
    r2rSession = (TCtdR2RSession)(size_t)pxInputMessage->handle;

  ctdStatus = _CRPC(nhtCtdCloseR2rSession) (
    r2rSession );

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_setR2RProtectedKeys
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_setR2RProtectedKeys
(
  TMsgBuf_rpcHandler                        xRpcHandler,
  const TNhtctd_R2rSetProtectedKeysInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg                ** pxOutputMessage
)
{
  TCtdStatus          ctdStatus;
  TCtdR2RSession      r2rSession        = NULL;
  TCtdUnsignedInt16   keyEmi            = (TCtdUnsignedInt16)pxInputMessage->keyEmi;
  TCtdUnsignedInt8  * pContentKey       = (TCtdUnsignedInt8*)pxInputMessage->contentKey.pData;
  TCtdSize            contentKeySize    = (TCtdSize)pxInputMessage->contentKeySize;
  TCtdSize            protectingKeySize = (TCtdSize)pxInputMessage->protectedKeySize;
  TCtdUnsignedInt8  * pL1ProtectingKey  = (TCtdUnsignedInt8*)pxInputMessage->l1ProtectedKey.pData;
  TCtdUnsignedInt8  * pL2ProtectingKey  = (TCtdUnsignedInt8*)pxInputMessage->l2ProtectedKey.pData;

  if (pxInputMessage->has_sessionHandle)
    r2rSession = (TCtdR2RSession)(size_t)pxInputMessage->sessionHandle;

  ctdStatus = _CRPC(nhtCtdSetR2RProtectedKeys) (
    r2rSession,
    keyEmi,
    contentKeySize,
    pContentKey,
    protectingKeySize,
    pL1ProtectingKey,
    pL2ProtectingKey );

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_r2rSessionCipher
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_r2rSessionCipher
(
  TMsgBuf_rpcHandler                        xRpcHandler,
  const TNhtctd_R2rSessionCipheringInMsg  * pxInputMessage,
  TNhtctd_BytesOutMsg                    ** pxOutputMessage
)
{
  TCtdStatus         ctdStatus;
  TCtdR2RSession     r2rSession  = NULL;
  TCtdUnsignedInt16  emi         = (TCtdUnsignedInt16)pxInputMessage->emi;
  TCtdSize           msgSize     = (TCtdSize)pxInputMessage->dataSize;
  TCtdUnsignedInt8 * pInput      = (TCtdUnsignedInt8*)pxInputMessage->input.pData;
  TCtdUnsignedInt8 * pOutput     = NULL;
  TCtdSize           ivSize      = (TCtdSize)pxInputMessage->ivSize;
  TCtdUnsignedInt8 * pIv         = (TCtdUnsignedInt8*)pxInputMessage->iv.pData;

  if (pxInputMessage->has_sessionHandle)
    r2rSession = (TCtdR2RSession)(size_t)pxInputMessage->sessionHandle;

  if (pxInputMessage->has_dataOutput)
    pOutput = (TCtdUnsignedInt8*)MSGBUF_SYS_malloc(msgSize);

  ctdStatus = _CRPC(nhtCtdR2rSessionCryptoProcess) (
    r2rSession,
    emi,
    pInput,
    pOutput,
    msgSize,
    pIv,
    ivSize );

  if ((ctdStatus == CTD_NO_ERROR) && pOutput)
  {
    (*pxOutputMessage)->dataOut.pData = pOutput;
    (*pxOutputMessage)->dataOut.len   = (size_t)msgSize;
    pOutput = NULL;
  }

  if (pOutput) MSGBUF_SYS_free (pOutput);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_openDscTestRunSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_openDscTestRunSession
(
  TMsgBuf_rpcHandler                   xRpcHandler,
  const TNhtctd_OpenDscSessionInMsg  * pxInputMessage,
  TNhtctd_HandleOutMsg              ** pxOutputMessage
)
{
  TCtdStatus                 ctdStatus;
  TCtdDscTestRunParameters   dscTestRunParameters;
  TCtdDscTestRunParameters * pDscTestRunParameters = NULL;
  TRpcCtdDscTestRunHandle  * pRpcDscHandle = NULL;
  TCtdDscTestRunSession    * pSession = NULL;

  if (pxInputMessage->pParams)
  {
    TNhtctd_DscSessionParamsMsg * pParams = pxInputMessage->pParams;

    MSGBUF_SYS_memset (&dscTestRunParameters, 0, sizeof (TCtdDscTestRunParameters));

    dscTestRunParameters.ivSize = (TCtdSize)pParams->ivSize;
    dscTestRunParameters.pIv = (TCtdUnsignedInt8*)pParams->iv.pData;

    dscTestRunParameters.engineEmi           = (TCtdUnsignedInt16)pParams->emi;
    dscTestRunParameters.audioPid            = (int)pParams->audioPid;
    dscTestRunParameters.videoPid            = (int)pParams->videoPid;
    dscTestRunParameters.pcrPid              = (int)pParams->pcrPid;
    dscTestRunParameters.isInClear           = (int)pParams->isInClear;
    dscTestRunParameters.ecmPid              = (int)pParams->ecmPid;
    dscTestRunParameters.isForEncryption     = (TCtdBoolean)pParams->isForEncryption;
    dscTestRunParameters.pInputFilePathname  = (char*)pParams->pInputFilePathname;
    dscTestRunParameters.pOutputFilePathname = (char*)pParams->pOutputFilePathname;

    if (pParams->has_ecmCallBack)
    {
      pRpcDscHandle = (TRpcCtdDscTestRunHandle*)MSGBUF_SYS_malloc (sizeof(TRpcCtdDscTestRunHandle));

      if (pRpcDscHandle == NULL) return RPC_STATUS_MALLOC_ERROR;

      pRpcDscHandle->magicNumber       = DSC_TEST_RUN_MAGIC_NUMBER;
      pRpcDscHandle->ecmCallBackHandle = (int64_t)pParams->ecmCallBack;
      pRpcDscHandle->lastTableId       = 0;
      pRpcDscHandle->privateData       = NULL;
      pRpcDscHandle->dscHandle         = (TCtdDscTestRunSession)NULL;
      pRpcDscHandle->rpcHandler        = xRpcHandler;
      pRpcDscHandle->privateData       = (TCtdDscCallBackPrivateParameters)pRpcDscHandle;

      dscTestRunParameters.ecmCallBackFct = rpcCtdEcmCallBackFunction;
      dscTestRunParameters.ecmCallBackPrivateData = (TCtdDscCallBackPrivateParameters)pRpcDscHandle;
    }
    else
    {
      dscTestRunParameters.ecmCallBackFct         = (TNhtCtdDscEcmCallBack)NULL;
      dscTestRunParameters.ecmCallBackPrivateData = (TCtdDscCallBackPrivateParameters)NULL;
    }

    pDscTestRunParameters = &dscTestRunParameters;
  }

  if (pxInputMessage->has_output)
  {
    if (pxInputMessage->pParams)
      pRpcDscHandle->ecmCallBackHandle = (int64_t)pxInputMessage->pParams->ecmCallBack;
    else pRpcDscHandle->ecmCallBackHandle = (int64_t)0;

    pRpcDscHandle->privateData       = (TCtdDscCallBackPrivateParameters)pRpcDscHandle;

    pSession = &pRpcDscHandle->dscHandle;
  }

  ctdStatus = _CRPC(nhtCtdOpenDscTestRunSession) (
    pDscTestRunParameters,
    pSession );

  if ((ctdStatus == CTD_NO_ERROR) && pSession)
  {
    (*pxOutputMessage)->has_handle = 1;
    (*pxOutputMessage)->handle = (int64_t)(size_t)pRpcDscHandle;
    pRpcDscHandle = NULL;
  }

  if (pRpcDscHandle) MSGBUF_SYS_free (pRpcDscHandle);
  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_closeDscTestRunSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_closeDscTestRunSession
(
  TMsgBuf_rpcHandler           xRpcHandler,
  const TNhtctd_HandleInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg   ** pxOutputMessage
)
{
  TCtdStatus                ctdStatus;
  TRpcCtdDscTestRunHandle * pRpcDscHandle = NULL;
  TCtdDscTestRunSession     pSession = NULL;

  if (pxInputMessage->has_handle)
  {
    pRpcDscHandle = (TRpcCtdDscTestRunHandle*)(size_t)pxInputMessage->handle;
    pSession = pRpcDscHandle->dscHandle;
  }

  ctdStatus = _CRPC(nhtCtdCloseDscTestRunSession) (pSession);

  if ((ctdStatus == CTD_NO_ERROR) && pRpcDscHandle)
    MSGBUF_SYS_free (pRpcDscHandle);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_startDscTestRun
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_startDscTestRun
(
  TMsgBuf_rpcHandler           xRpcHandler,
  const TNhtctd_HandleInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg   ** pxOutputMessage
)
{
  TNhtCtdTestRunStatus      ctdTestRunStatus;
  TRpcCtdDscTestRunHandle * pRpcDscHandle = NULL;
  TCtdDscTestRunSession   * pSession = NULL;

  if (pxInputMessage->has_handle)
  {
    pRpcDscHandle = (TRpcCtdDscTestRunHandle*)(size_t)pxInputMessage->handle;
    pSession = pRpcDscHandle->dscHandle;
  }

  ctdTestRunStatus = _CRPC(nhtCtdStartDscTestRun) (pSession);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdTestRunStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_waitOnDscTestRunCompletion
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_waitOnDscTestRunCompletion
(
  TMsgBuf_rpcHandler                               xRpcHandler,
  const TNhtctd_WaitOnCsdSessionCompletionInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg                       ** pxOutputMessage
)
{
  TNhtCtdTestRunStatus      ctdTestRunStatus;
  TRpcCtdDscTestRunHandle * pRpcDscHandle = NULL;
  int                       timeout = (int)pxInputMessage->timeout;
  TCtdDscTestRunSession     pSession = NULL;

  if (pxInputMessage->has_sessionHandle)
  {
    pRpcDscHandle = (TRpcCtdDscTestRunHandle*)(size_t)pxInputMessage->sessionHandle;
    pSession = (TCtdDscTestRunSession)(size_t)pRpcDscHandle->dscHandle;
  }

  ctdTestRunStatus = _CRPC(nhtCtdWaitOnDscTestRunCompletion) (pSession, timeout );

  (*pxOutputMessage)->retStatus = (uint32_t)ctdTestRunStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_stopDcrTestRun
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_stopDcrTestRun
(
  TMsgBuf_rpcHandler           xRpcHandler,
  const TNhtctd_HandleInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg   ** pxOutputMessage
)
{
  TNhtCtdTestRunStatus      ctdTestRunStatus;
  TRpcCtdDscTestRunHandle * pRpcDscHandle;
  TCtdDscTestRunSession     pSession = NULL;

  if (pxInputMessage->has_handle)
  {
    pRpcDscHandle = (TRpcCtdDscTestRunHandle*)(size_t)pxInputMessage->handle;
    pSession = (TCtdDscTestRunSession)(size_t)pRpcDscHandle->dscHandle;
  }

  ctdTestRunStatus = _CRPC(nhtCtdStopDscTestRun) (pSession);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdTestRunStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_setDcrProtectedKeys
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_setDcrProtectedKeys
(
  TMsgBuf_rpcHandler                        xRpcHandler,
  const TNhtctd_SetDscProtectedKeysInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg                ** pxOutputMessage
)
{
  TCtdStatus                ctdStatus;
  TRpcCtdDscTestRunHandle * pRpcDscHandle = NULL;

  TCtdUnsignedInt16          keyEmi             = (TCtdUnsignedInt16)pxInputMessage->keyEmi;
  TCtdSize                   protectingKeySize  = (TCtdSize)pxInputMessage->protectedKeySize;
  TCtdUnsignedInt8         * pL1ProtectingKey   = (TCtdUnsignedInt8*)pxInputMessage->l1ProtectedKey.pData;
  TCtdUnsignedInt8         * pL2ProtectingKey   = (TCtdUnsignedInt8*)pxInputMessage->l2ProtectedKey.pData;
  TCtdUnsignedInt8         * pOddContentKey     = (TCtdUnsignedInt8*)pxInputMessage->oddContentKey.pData;
  TCtdSize                   oddContentKeySize  = (TCtdSize)pxInputMessage->oddContentKeySize;
  TCtdUnsignedInt8         * pEvenContentKey    = (TCtdUnsignedInt8*)pxInputMessage->evenContentKey.pData;
  TCtdSize                   evenContentKeySize = (TCtdSize)pxInputMessage->evenContentKeySize;
  TCtdDscTestRunSession      pSession = NULL;

  if (pxInputMessage->has_sessionHandle)
  {
    pRpcDscHandle = (TRpcCtdDscTestRunHandle*)(size_t)pxInputMessage->sessionHandle;
    pSession = (TCtdDscTestRunSession)(size_t)pRpcDscHandle->dscHandle;
  }

  ctdStatus = _CRPC(nhtCtdSetDscProtectedKeys) (
    pSession,
    keyEmi,
    protectingKeySize,
    pL1ProtectingKey,
    pL2ProtectingKey,
    pOddContentKey,
    oddContentKeySize,
    pEvenContentKey,
    evenContentKeySize );

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_openScrTestRunSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_openScrTestRunSession
(
  TMsgBuf_rpcHandler                   xRpcHandler,
  const TNhtctd_OpenScrSessionInMsg  * pxInputMessage,
  TNhtctd_HandleOutMsg              ** pxOutputMessage
)
{
  TCtdStatus                     ctdStatus;
  TNhtCtdScrTestRunParameters    scrTestRunParameters;
  TNhtCtdScrTestRunParameters  * pScrTestRunParameters = NULL;
  TNhtCtdScrTestRunSession       scrTestRunSession;
  TNhtCtdScrTestRunSession     * pScrTestRunSession = NULL;


  if (pxInputMessage->pParams)
  {
    TNhtctd_ScrSessionParamsMsg *  pParams = pxInputMessage->pParams;

    scrTestRunParameters.engineEmi  = (TCtdUnsignedInt16)pParams->emi;
    scrTestRunParameters.audioPid   = (int)pParams->audioPid;
    scrTestRunParameters.videoPid   = (int)pParams->videoPid;
    scrTestRunParameters.pcrPid     = (int)pParams->pcrPid;

    scrTestRunParameters.isForEncryption     = (TCtdBoolean)pParams->isForEncryption;
    scrTestRunParameters.pInputFilePathname  = (char*)pParams->pInputFilePathname;
    scrTestRunParameters.pOutputFilePathname = (char*)pParams->pOutputFilePathname;

    pScrTestRunParameters = &scrTestRunParameters;
  }

  if (pxInputMessage->has_output)
    pScrTestRunSession = &scrTestRunSession;

  ctdStatus = _CRPC(nhtCtdOpenScrTestRunSession) (
    pScrTestRunParameters,
    pScrTestRunSession );

  if ((ctdStatus == CTD_NO_ERROR) && pScrTestRunSession)
  {
    (*pxOutputMessage)->has_handle = 1;
    (*pxOutputMessage)->handle = (int64_t)(size_t)scrTestRunSession;
  }

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_closeScrTestRunSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_closeScrTestRunSession
(
  TMsgBuf_rpcHandler           xRpcHandler,
  const TNhtctd_HandleInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg   ** pxOutputMessage
)
{
  TCtdStatus                ctdStatus;
  TNhtCtdScrTestRunSession  pSession = NULL;

  if (pxInputMessage->has_handle)
    pSession = (TNhtCtdScrTestRunSession)(size_t)pxInputMessage->handle;

  ctdStatus = _CRPC(nhtCtdCloseScrTestRunSession) (pSession);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_startScrTestRun
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_startScrTestRun
(
  TMsgBuf_rpcHandler           xRpcHandler,
  const TNhtctd_HandleInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg   ** pxOutputMessage
)
{
  TCtdStatus                ctdStatus;
  TNhtCtdScrTestRunSession  pSession = NULL;

  if (pxInputMessage->has_handle)
    pSession = (TNhtCtdScrTestRunSession)(size_t)pxInputMessage->handle;

  ctdStatus = _CRPC(nhtCtdStartScrTestRun) (pSession);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_waitOnScrTestRunCompletion
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_waitOnScrTestRunCompletion
(
  TMsgBuf_rpcHandler                               xRpcHandler,
  const TNhtctd_WaitOnCsdSessionCompletionInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg                       ** pxOutputMessage
)
{
  TCtdStatus                ctdStatus;
  TNhtCtdScrTestRunSession  pSession = NULL;

  if (pxInputMessage->has_sessionHandle)
    pSession = (TNhtCtdScrTestRunSession)(size_t)pxInputMessage->sessionHandle;

  ctdStatus = _CRPC(nhtCtdWaitOnScrTestRunCompletion) (
    pSession,
    (int)pxInputMessage->timeout );

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_stopScrTestRun
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_stopScrTestRun
(
  TMsgBuf_rpcHandler           xRpcHandler,
  const TNhtctd_HandleInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg   ** pxOutputMessage
)
{
  TCtdStatus                ctdStatus;
  TNhtCtdScrTestRunSession  session = NULL;

  if (pxInputMessage->has_handle)
    session = (TNhtCtdScrTestRunSession)(size_t)pxInputMessage->handle;

  ctdStatus = _CRPC(nhtCtdStopScrTestRun) (session);

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtctd_hc_nht_setScrProtectedKeys
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtctd_hc_nht_setScrProtectedKeys
(
  TMsgBuf_rpcHandler                        xRpcHandler,
  const TNhtctd_SetScrProtectedKeysInMsg  * pxInputMessage,
  TNhtctd_CtdStatusOutMsg                ** pxOutputMessage
)
{
  TCtdStatus                 ctdStatus;
  TNhtCtdScrTestRunSession   pSession          = NULL;
  TCtdUnsignedInt16          keyEmi            = (TCtdUnsignedInt16)pxInputMessage->keyEmi;
  TCtdSize                   protectingKeySize = (TCtdSize)pxInputMessage->protectedKeySize;
  TCtdUnsignedInt8         * pL1ProtectingKey  = (TCtdUnsignedInt8*)pxInputMessage->l1ProtectedKey.pData;
  TCtdUnsignedInt8         * pL2ProtectingKey  = (TCtdUnsignedInt8*)pxInputMessage->l2ProtectedKey.pData;
  TCtdUnsignedInt8         * pScrContentKey    = (TCtdUnsignedInt8*)pxInputMessage->contentKey.pData;
  TCtdSize                   scrContentKeySize = (TCtdSize)pxInputMessage->contentKeySize;
  TCtdUnsignedInt8         * pIv               = (TCtdUnsignedInt8*)pxInputMessage->iv.pData;
  TCtdSize                   ivSize            = (TCtdSize)pxInputMessage->ivSize;

  if (pxInputMessage->has_sessionHandle)
    pSession   = (TNhtCtdScrTestRunSession)(size_t)pxInputMessage->sessionHandle;

  ctdStatus = _CRPC(nhtCtdSetScrProtectedKeys) (
    pSession,
    keyEmi,
    protectingKeySize,
    pL1ProtectingKey,
    pL2ProtectingKey,
    pScrContentKey,
    scrContentKeySize,
    pIv,
    ivSize );

  (*pxOutputMessage)->retStatus = (uint32_t)ctdStatus;
  return RPC_STATUS_NO_ERROR;
}



/*****************************************************************************
 * RPC method calls API wrapper                                              *
 ****************************************************************************/


/* RPC method: rpc_nhtcsd_tn_ecmCallBack
 *
 * This method stands as an asynchronous notification function.
 * Caller of this function immediately returns without waiting
 * the completion of its remote execution.
 *
 * PS: param 'pxOutputMessage' is always assumed to be NULL.
 */
static TCtdStatus rpcCtdEcmCallBackFunction
(
        TCtdDscTestRunSession                 xDscTestRunSession,
        TCtdDscCallBackPrivateParameters      xPrivateParameters,
        TCtdUnsignedInt8                      xEcmTableId,
  const TCtdUnsignedInt8                    * pxEcmContent,
        TCtdSize                              xEcmContentSize
)
{
  TRpcCtdDscTestRunHandle  * pRpcDscHandle;
  TRpc_status                rpcStatus;
  TNhtctd_EcmCallBackInMsg   rpcEcmCallBackInMsg;
  TNhtctd_EmptyMsg         * pRpcEmptyMsg;

  pRpcDscHandle = ( TRpcCtdDscTestRunHandle*)xPrivateParameters;

  /* Only concider new tableId (in case if this wasn't filtered in the CM's
   * implementation. */
  if ((xEcmTableId == pRpcDscHandle->lastTableId) && (pRpcDscHandle->lastTableId != 0))
  {
    return CTD_NO_ERROR;
  }

  pRpcDscHandle->lastTableId = xEcmTableId;

  /* Export callback notification to the host */
  init_Nhtctd_EcmCallBackInMsg (&rpcEcmCallBackInMsg);

  rpcEcmCallBackInMsg.tableId = (uint32_t)xEcmTableId;
  if (pRpcDscHandle->ecmCallBackHandle)
  {
    rpcEcmCallBackInMsg.ecmCallBackHandle = pRpcDscHandle->ecmCallBackHandle;
    rpcEcmCallBackInMsg.has_ecmCallBackHandle = 1;
  }

  if (pRpcDscHandle)
  {
    rpcEcmCallBackInMsg.testRunHandle     = (int64_t)(size_t)pRpcDscHandle;
    rpcEcmCallBackInMsg.has_testRunHandle = 1;
  }

  rpcEcmCallBackInMsg.len_ecm = (uint64_t)xEcmContentSize;
  if (pxEcmContent)
  {
    rpcEcmCallBackInMsg.ecm.pData = (void*)pxEcmContent;
    rpcEcmCallBackInMsg.ecm.len   = (uint64_t)xEcmContentSize;
  }

  rpcStatus =  rpc_nhtctd_tn_ecmCallBack (
    pRpcDscHandle->rpcHandler,
    &rpcEcmCallBackInMsg,
    &pRpcEmptyMsg );

  if (rpcStatus == RPC_STATUS_NO_ERROR) return CTD_NO_ERROR;
  else return CTD_ERROR;
}
