/* DO NOT EDIT THIS FILE!!!
 * This file was automatically generated by msgbuf compiler!
 *
 * This file contains the msgbuf structure definitions associated
 * to the package nhtcert.proto
 */


/*****************************************************************************
 * include files                                                             *
 ****************************************************************************/

#include "inc/rpc_nhtcert.h"
#include "src/rpc_nhtcert_api.h"
#include "inc/nv_nhtcert.h"
#include "inc/hndmng.h"
#include "inc/msgbuf_sys_string.h"
#include "inc/msgbuf_sys_malloc.h"
#include "inc/rpc_ftrace.h"
#include "inc/TRACE_nhtcert.h"


/* */
static TCertFunctionTable * pgCertFunctionTable = NULL;


static int _hndmng_releaseResourceHandle
(
  void * pxHandle
)
{
  TCertResourceHandle  resourceHandle = NULL;

  resourceHandle= (TCertResourceHandle)pxHandle;

  if (pgCertFunctionTable)
  {
    pgCertFunctionTable->certUnlock (resourceHandle);
  }

  return 0;
}


/*****************************************************************************
 * RPC methods implementation                                                *
 ****************************************************************************/


/* RPC method: rpc_nhtcert_hc_nht_getFunctionTable
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtcert_hc_nht_getFunctionTable
(
  TMsgBuf_rpcHandler                xRpcHandler,
  const TNhtcert_EmptyMsg         * pxInputMessage,
  TNhtcert_CertTableHandleOutMsg ** pxOutputMessage
)
{
  TCertFunctionTable * pCertFunctionTable = _CRPC(certGetFunctionTable) ();

  pgCertFunctionTable = pCertFunctionTable;

  if (pxOutputMessage && pgCertFunctionTable)
  {
    (*pxOutputMessage)->has_handle  = 1;
    (*pxOutputMessage)->handle      = (int64_t)(size_t) pgCertFunctionTable;
    (*pxOutputMessage)->apiVersion = pgCertFunctionTable->certApiVersion;
  }

  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtcert_hc_nht_lock
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtcert_hc_nht_lock
(
  TMsgBuf_rpcHandler              xRpcHandler,
  const TNhtcert_CertLockInMsg  * pxInputMessage,
  TNhtcert_HandleOutMsg        ** pxOutputMessage
)
{
  TCertStatus          certStatus;
  TCertResourceHandle  resourceHandle = NULL;

  if (pgCertFunctionTable == NULL) certStatus = CERT_ERROR;
  else
  {
    certStatus = pgCertFunctionTable->certLock (&resourceHandle);

    if (pxOutputMessage)
    {
      if (resourceHandle && (certStatus == CERT_NO_ERROR))
      {
        (*pxOutputMessage)->has_handle = 1;
        (*pxOutputMessage)->handle = (int64_t)(size_t)resourceHandle;

        hndmng_register (resourceHandle, &_hndmng_releaseResourceHandle);
      }
    }
  }

  if (pxOutputMessage) (*pxOutputMessage)->retStatus = (TNhtcert_CertStatus)certStatus;

  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtcert_hc_nht_unlock
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtcert_hc_nht_unlock
(
  TMsgBuf_rpcHandler                xRpcHandler,
  const TNhtcert_CertUnlockInMsg  * pxInputMessage,
  TNhtcert_CertStatusOutMsg      ** pxOutputMessage
)
{
  TCertResourceHandle    resourceHandle = NULL;
  TCertStatus            certStatus;

  if (pgCertFunctionTable == NULL) certStatus = CERT_ERROR;
  else
  {
    if (pxInputMessage->has_resHandle)
      resourceHandle = (TCertResourceHandle)(size_t)pxInputMessage->resHandle;

    certStatus = pgCertFunctionTable->certUnlock (resourceHandle);

    if ((certStatus == CERT_NO_ERROR) && resourceHandle)
      hndmng_unregister (resourceHandle);
  }

  if (pxOutputMessage) (*pxOutputMessage)->retStatus = (TNhtcert_CertStatus)certStatus;

  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtcert_hc_nht_getApiVersion
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtcert_hc_nht_getDriverVersion
(
  TMsgBuf_rpcHandler                       xRpcHandler,
  const TNhtcert_CertGetSingleInfoInMsg  * pxInputMessage,
  TNhtcert_CertGetVersionOutMsg         ** pxOutputMessage
)
{
  TCertStatus certStatus;

  if (pgCertFunctionTable == NULL) certStatus = CERT_ERROR;
  else
  {
    certStatus = CERT_NO_ERROR;
    if (pxOutputMessage) (*pxOutputMessage)->version =
      CERT_TOOL_VERSION_INT (CERTAPI_VERSION_MAJOR, CERTAPI_VERSION_MEDIUM, CERTAPI_VERSION_MINOR);
  }

  if (pxOutputMessage) (*pxOutputMessage)->retStatus = (TNhtcert_CertStatus)certStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtcert_hc_nht_getServiceName
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtcert_hc_nht_getServiceName
(
  TMsgBuf_rpcHandler                       xRpcHandler,
  const TNhtcert_CertGetSingleInfoInMsg  * pxInputMessage,
  TNhtcert_CertGetStringOutMsg          ** pxOutputMessage
)
{
  TCertStatus certStatus;

  if (pgCertFunctionTable == NULL) certStatus = CERT_ERROR;
  else
  {
    certStatus = CERT_NO_ERROR;
    if (pxOutputMessage)
    {
      (*pxOutputMessage)->name.pData = (char*)MSGBUF_SYS_malloc (20 + 1);
      ((char*)(*pxOutputMessage)->name.pData)[20] = 0;
      MSGBUF_SYS_strncpy ((char*)(*pxOutputMessage)->name.pData, "CERT", 20);
      (*pxOutputMessage)->name.len = 20;
    }
  }

  if (pxOutputMessage) (*pxOutputMessage)->retStatus = (TNhtcert_CertStatus)certStatus;
  return RPC_STATUS_NO_ERROR;
}

/* RPC method: rpc_nhtcert_hc_nht_exchange
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtcert_hc_nht_exchange
(
  TMsgBuf_rpcHandler                  xRpcHandler,
  const TNhtcert_CertExchangeInMsg  * pxInputMessage,
  TNhtcert_CertExchangeOutMsg      ** pxOutputMessage
)
{
  TCertResourceHandle    resourceHandle = NULL;
  TCertCommand         * pCertCommands = NULL;
  size_t                 certCmdNumber = 0;
  size_t               * pProcessedCmds = NULL;
  size_t                 processedCmds = 0;
  TCertStatus            certStatus;
  size_t                 i;


  TNhtcert_CertCommandInMsg   * pNhtCertCommandInMsg = NULL;
  TNhtcert_CertCommandOutMsg ** pNhtCertCommandOutMsg = NULL;

  if (pgCertFunctionTable == NULL) certStatus = CERT_ERROR;
  else
  {
    if (pxInputMessage->has_resHandle)
      resourceHandle = (TCertResourceHandle)(size_t)pxInputMessage->resHandle;

    certCmdNumber = (size_t)pxInputMessage->n_certCommands;

    if (pxInputMessage->hasProcessedCmdSize)
      pProcessedCmds = &processedCmds;

    if (pxInputMessage->certCommands && (certCmdNumber > 0))
    {
      pCertCommands = (TCertCommand*)MSGBUF_SYS_malloc (certCmdNumber * sizeof (TCertCommand));

      /* TODO: memory allocation error check here */

      for (i=0; i < certCmdNumber; i++)
      {
        pNhtCertCommandInMsg = pxInputMessage->certCommands[i];

        MSGBUF_SYS_memcpy (pCertCommands[i].inputData, pNhtCertCommandInMsg->inputData.pData, pNhtCertCommandInMsg->inputData.len);
        MSGBUF_SYS_memset (pCertCommands[i].inputData, 0, 32);
        MSGBUF_SYS_memset (pCertCommands[i].status, 0, 4);
        MSGBUF_SYS_memcpy (pCertCommands[i].opcodes, pNhtCertCommandInMsg->opcodes.pData, pNhtCertCommandInMsg->opcodes.len);
        pCertCommands[i].timeout = (TCertTimeoutType)pNhtCertCommandInMsg->timeoutType;
        MSGBUF_SYS_memcpy (pCertCommands[i].inputData,pNhtCertCommandInMsg->inputData.pData, pNhtCertCommandInMsg->inputData.len);
      }
    }

    certStatus = pgCertFunctionTable->certExchange (
      resourceHandle,
      certCmdNumber,
      pCertCommands,
      pProcessedCmds );

    if (pxOutputMessage)
    {
      (*pxOutputMessage)->processedCmds = (uint32_t)processedCmds;
      if (processedCmds > certCmdNumber) processedCmds = certCmdNumber;
      (*pxOutputMessage)->n_certCommands = (size_t)processedCmds;

      if (processedCmds > 0)
      {
        pNhtCertCommandOutMsg = (TNhtcert_CertCommandOutMsg **)MSGBUF_SYS_malloc(processedCmds * sizeof (TNhtcert_CertCommandOutMsg *));

        /* TODO: memory allocation error check here */
        for (i=0; i < processedCmds; i++) pNhtCertCommandOutMsg[i] = NULL;

        for (i=0; i < processedCmds; i++)
        {
          pNhtCertCommandOutMsg[i] = pAlloc_Nhtcert_CertCommandOutMsg();

          /* TODO: memory allocation error check here */
          pNhtCertCommandOutMsg[i]->outputData.pData = (void*)MSGBUF_SYS_malloc (32);
          pNhtCertCommandOutMsg[i]->outputData.len = 32;
          MSGBUF_SYS_memcpy (pNhtCertCommandOutMsg[i]->outputData.pData, pCertCommands[i].outputData, 32);

          pNhtCertCommandOutMsg[i]->status.pData = (void*)MSGBUF_SYS_malloc (4);
          pNhtCertCommandOutMsg[i]->status.len = 4;
          MSGBUF_SYS_memcpy (pNhtCertCommandOutMsg[i]->status.pData, pCertCommands[i].status, 4);
        }

        (*pxOutputMessage)->certCommands = pNhtCertCommandOutMsg;
      }
    }
  }

  if (pxOutputMessage) (*pxOutputMessage)->retStatus = (TNhtcert_CertStatus)certStatus;

  return RPC_STATUS_NO_ERROR;
}


/*****************************************************************************
 * RPC method calls API wrapper                                              *
 ****************************************************************************/
