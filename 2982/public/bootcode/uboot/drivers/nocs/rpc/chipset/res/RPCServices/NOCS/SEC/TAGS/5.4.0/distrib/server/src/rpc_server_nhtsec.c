/* DO NOT EDIT THIS FILE!!!
 * This file was automatically generated by msgbuf compiler!
 *
 * This file contains the msgbuf structure definitions associated
 * to the package nhtsec.proto
 */


/*****************************************************************************
 * include files                                                             *
 ****************************************************************************/

#include "inc/nv_nhtsec.h"
#include "inc/rpc_nhtsec.h"
#include "src/rpc_nhtsec_api.h"
#include <stddef.h>
#include "inc/msgbuf_sys_malloc.h"
#include "inc/msgbuf_sys_string.h"
#include "inc/hndmng.h"
#include "inc/os/msgbuf_sys_mutex.h"
#include "inc/avlset.h"
#include "inc/TRACE_nhtsec.h"
#include "inc/TRACE_p_nhtsec.h"


#define SEC_TRANSPORT_HANDLE_MAGIC_NUMBER   (0x12345679)


/* */
typedef struct SRpcTransportHandle
{
  TAVLSet_iter           iter;
  volatile uint32_t      magicNumber;
  TMsgBuf_rpcHandler     rpcHandler;
  TTransportSessionId    transportSessionId;
  int64_t                ecmCallBackHandle;
  volatile TUnsignedInt8 lastTableId;

} TRpcTransportHandle;



/****************************************************************************
 * Static function prototypes                                               *
 ****************************************************************************/

static TSecStatus rpcEcmCallBackFunction (
  TTransportSessionId                xTransportSessionId,
  TNhtsecCallBackPrivateParameters   xPrivateParameters,
  TUnsignedInt8                      xEcmTableId,
  const TUnsignedInt8              * pxEcmContent,
  TSize                              xEcmContentSize );


/* */
static TSecFunctionTable    * pgFunctionTable       = NULL;
static TMsgbuf_thread_mutex   pgTransportIdSetMutex = NULL;
static TAVLSet                gTransportIdSet;



/* */
static int  _transportSessionId_compare
(
  TAVLSet_iter * pxIter1,
  TAVLSet_iter * pxIter2
)
{
  TRpcTransportHandle * pIter1 = (TRpcTransportHandle*)pxIter1;
  TRpcTransportHandle * pIter2 = (TRpcTransportHandle*)pxIter2;

  return (pIter1->transportSessionId - pIter2->transportSessionId);
}



/* */
static int _hndmng_sysBufferClose
(
  void * pxHandle
)
{
  hndmng_unregister (pxHandle);
  return 0;
}


/* */
static void * _buildSysInBytes
(
  TNhtsec_SysInBytesMsg * pxSysInBytes_msg
)
{
  void * pSysBytes = NULL;

  /* At least, a sysByte sub-message shall be provided */
  if (pxSysInBytes_msg)
  {
    /* If data are provided in input */
    if (pxSysInBytes_msg->sysBytes.pData != NULL)
    {
      /* If these data shall be stored in a server-allocated buffer */
      if (pxSysInBytes_msg->has_handle)
      {
        /* Copy these data into the server allocated buffer and return this buffer */
        pSysBytes = (void*)(size_t)pxSysInBytes_msg->handle;
        MSGBUF_SYS_memcpy (pSysBytes, pxSysInBytes_msg->sysBytes.pData, (int)pxSysInBytes_msg->sysBytes.len);
      }
      /* Otherwize, just return the reference to the RPC allocated byte array */
      else pSysBytes = (void*)pxSysInBytes_msg->sysBytes.pData;
    }
  }

  return pSysBytes;
}


/* */
static void * _getSysOutBytes
(
  TNhtsec_SysOutBytesMsg * pxSysOutBytes_msg,
  int                      xSize
)
{
  void * pOutput = NULL;

  /* At least, a sysByte sub-message shall be provided */
  if (pxSysOutBytes_msg)
  {
    /* If an output buffer address is provided */
    if (pxSysOutBytes_msg->has_output)
    {
      /* If the output buffer shall be referenced in server allocated buffer, */
      /* ajust the reference */
      if (pxSysOutBytes_msg->has_handle)
      {
        pOutput = (void*)(size_t)pxSysOutBytes_msg->handle;
      }
      else
      {
        /* Otherwize, allocate a buffer recipient for this output buffer */
        pOutput = (void*)MSGBUF_SYS_malloc (xSize);
      }
    }
  }

  return pOutput;
}


/* */
static void _setSysOutBytes
(
  TNhtsec_SysOutBytesMsg * pxSysOutBytes_msg,
  void                   * pxData,
  int                      xSize,
  TMsgBuf_bytes          * pxOutput
)
{
  void * pTmp = NULL;

  if (pxData)
  {
    if (pxSysOutBytes_msg && pxOutput)
    {
      /* If the output was referenced into a server allocated buffer */
      if (pxSysOutBytes_msg->has_handle)
      {
        /* Create a RPC allocated buffer for exportation */
        pTmp = (void*)MSGBUF_SYS_malloc (xSize);
        MSGBUF_SYS_memcpy (pTmp, pxData, xSize);
      }
      else pTmp = pxData;
    }
    else MSGBUF_SYS_free (pxData);
  }

  if (pTmp)
  {
    pxOutput->len = (size_t)xSize;
    pxOutput->pData = (void*)pTmp;
  }
}


/* */
static void _buildEcParams
(
  const TNhtsec_EcParamsMsg * pxParams_msg,
  TSecEcParams              * pxEcParams
)
{
  if (pxParams_msg)
  {
    pxEcParams->keySize = (size_t)pxParams_msg->keySize;

    pxEcParams->q  = (TUnsignedInt8*)_buildSysInBytes (pxParams_msg->q);
    pxEcParams->a  = (TUnsignedInt8*)_buildSysInBytes (pxParams_msg->a);
    pxEcParams->b  = (TUnsignedInt8*)_buildSysInBytes (pxParams_msg->b);
    pxEcParams->GX = (TUnsignedInt8*)_buildSysInBytes (pxParams_msg->gx);
    pxEcParams->GY = (TUnsignedInt8*)_buildSysInBytes (pxParams_msg->gy);
    pxEcParams->n  = (TUnsignedInt8*)_buildSysInBytes (pxParams_msg->n);
    pxEcParams->h  = (TUnsignedInt8*)_buildSysInBytes (pxParams_msg->h);
  }
}


/*****************************************************************************
 * RPC methods implementation                                                *
 ****************************************************************************/

/* RPC method: rpc_nhtsec_hc_nht_initialize
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_initialize
(
  TMsgBuf_rpcHandler        xRpcHandler,
  const TNhtsec_EmptyMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg   ** pxOutputMessage
)
{
  TSecStatus secStatus;

  if (pgTransportIdSetMutex == NULL)
  {
    AVLSet_init ( &gTransportIdSet, &_transportSessionId_compare, 0);
    pgTransportIdSetMutex = MSGBUF_SYS_createThreadMutex();
  }

  secStatus = _CRPC(nhtSecInitialize) ();

  (*pxOutputMessage)->retStatus = (uint32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_terminate
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_terminate
(
  TMsgBuf_rpcHandler        xRpcHandler,
  const TNhtsec_EmptyMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg   ** pxOutputMessage
)
{
  TSecStatus   secStatus;

  secStatus = _CRPC(nhtSecTerminate) ();

  (*pxOutputMessage)->retStatus = (uint32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_getFunctionTable
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_getFunctionTable
(
  TMsgBuf_rpcHandler        xRpcHandler,
  const TNhtsec_EmptyMsg  * pxInputMessage,
  TNhtsec_SecTableOutMsg ** pxOutputMessage
)
{
  pgFunctionTable = _CRPC(secGetFunctionTable) ();

  if (pgFunctionTable)
  {
    (*pxOutputMessage)->has_handle = 1;
    (*pxOutputMessage)->handle     = (int64_t)(size_t)pgFunctionTable;
    (*pxOutputMessage)->apiVersion = (uint32_t)pgFunctionTable->secApiVersion;

    if (pgFunctionTable->secGetNuid)                   (*pxOutputMessage)->has_secGetNuid                   = 1;
    if (pgFunctionTable->secGetChipsetRevision)        (*pxOutputMessage)->has_secGetChipsetRevision        = 1;
    if (pgFunctionTable->secEncryptData)               (*pxOutputMessage)->has_secEncryptData               = 1;
    if (pgFunctionTable->secDecryptData)               (*pxOutputMessage)->has_secDecryptData               = 1;
    if (pgFunctionTable->secGenerateRandomBytes)       (*pxOutputMessage)->has_secGenerateRandomBytes       = 1;
    if (pgFunctionTable->secRsaGenerateKey)            (*pxOutputMessage)->has_secRsaGenerateKey            = 1;
    if (pgFunctionTable->secRsaPublicEncrypt)          (*pxOutputMessage)->has_secRsaPublicEncrypt          = 1;
    if (pgFunctionTable->secRsaPrivateEncrypt)         (*pxOutputMessage)->has_secRsaPrivateEncrypt         = 1;
    if (pgFunctionTable->secRsaPublicDecrypt)          (*pxOutputMessage)->has_secRsaPublicDecrypt          = 1;
    if (pgFunctionTable->secRsaPrivateDecrypt)         (*pxOutputMessage)->has_secRsaPrivateDecrypt         = 1;
    if (pgFunctionTable->secDhGenerateKey)             (*pxOutputMessage)->has_secDhGenerateKey             = 1;
    if (pgFunctionTable->secDhComputeKey)              (*pxOutputMessage)->has_secDhComputeKey              = 1;
    if (pgFunctionTable->secSha1Init)                  (*pxOutputMessage)->has_secSha1Init                  = 1;
    if (pgFunctionTable->secSha1Update)                (*pxOutputMessage)->has_secSha1Update                = 1;
    if (pgFunctionTable->secSha1Final)                 (*pxOutputMessage)->has_secSha1Final                 = 1;
    if (pgFunctionTable->secSha256Init)                (*pxOutputMessage)->has_secSha256Init                = 1;
    if (pgFunctionTable->secSha256Update)              (*pxOutputMessage)->has_secSha256Update              = 1;
    if (pgFunctionTable->secSha256Final)               (*pxOutputMessage)->has_secSha256Final               = 1;
    if (pgFunctionTable->secHmacSha256Init)            (*pxOutputMessage)->has_secHmacSha256Init            = 1;
    if (pgFunctionTable->secHmacSha256Update)          (*pxOutputMessage)->has_secHmacSha256Update          = 1;
    if (pgFunctionTable->secHmacSha256Final)           (*pxOutputMessage)->has_secHmacSha256Final           = 1;
    if (pgFunctionTable->secEcdsaGenerateKey)          (*pxOutputMessage)->has_secEcdsaGenerateKey          = 1;
    if (pgFunctionTable->secEcdsaSign)                 (*pxOutputMessage)->has_secEcdsaSign                 = 1;
    if (pgFunctionTable->secEcdsaVerify)               (*pxOutputMessage)->has_secEcdsaVerify               = 1;
    if (pgFunctionTable->secEcdhGenerateKey)           (*pxOutputMessage)->has_secEcdhGenerateKey           = 1;
    if (pgFunctionTable->secEcdhComputeKey)            (*pxOutputMessage)->has_secEcdhComputeKey            = 1;
    if (pgFunctionTable->secOpenRam2RamEncryptSession) (*pxOutputMessage)->has_secOpenRam2RamEncryptSession = 1;
    if (pgFunctionTable->secOpenRam2RamDecryptSession) (*pxOutputMessage)->has_secOpenRam2RamDecryptSession = 1;
    if (pgFunctionTable->secCloseSession)              (*pxOutputMessage)->has_secCloseSession              = 1;
    if (pgFunctionTable->secSetClearTextKey)           (*pxOutputMessage)->has_secSetClearTextKey           = 1;
    if (pgFunctionTable->secSet2LevelProtectedKey)     (*pxOutputMessage)->has_secSet2LevelProtectedKey     = 1;
    if (pgFunctionTable->secUseCertKey)                (*pxOutputMessage)->has_secUseCertKey                = 1;
    if (pgFunctionTable->secSessionEncrypt)            (*pxOutputMessage)->has_secSessionEncrypt            = 1;
    if (pgFunctionTable->secSessionDecrypt)            (*pxOutputMessage)->has_secSessionDecrypt            = 1;
    if (pgFunctionTable->secGetNuid64)                 (*pxOutputMessage)->has_secGetNuid64                 = 1;
    if (pgFunctionTable->secGetChipsetExtension)       (*pxOutputMessage)->has_secGetChipsetExtension       = 1;
    if (pgFunctionTable->secSha384Init)                (*pxOutputMessage)->has_secSha384Init                = 1;
    if (pgFunctionTable->secSha384Update)              (*pxOutputMessage)->has_secSha384Update              = 1;
    if (pgFunctionTable->secSha384Final)               (*pxOutputMessage)->has_secSha384Final               = 1;
    if (pgFunctionTable->secRsaComputeCrtParams)       (*pxOutputMessage)->has_secRsaComputeCrtParams       = 1;
    if (pgFunctionTable->secEncryptFlashProtKey)       (*pxOutputMessage)->has_secEncryptFlashProtKey       = 1;
    if (pgFunctionTable->secUseFlashProtKey)           (*pxOutputMessage)->has_secUseFlashProtKey           = 1;

    if (pgFunctionTable->secOpenStreamEncryptSession)  (*pxOutputMessage)->has_secOpenStreamEncryptSession  = 1;
    if (pgFunctionTable->secOpenStreamDecryptSession)  (*pxOutputMessage)->has_secOpenStreamDecryptSession  = 1;
    if (pgFunctionTable->secSet0LevelProtectedKey)     (*pxOutputMessage)->has_secSet0LevelProtectedKey     = 1;
    if (pgFunctionTable->secSet1LevelProtectedKey)     (*pxOutputMessage)->has_secSet1LevelProtectedKey     = 1;
    if (pgFunctionTable->secSetMetadata)               (*pxOutputMessage)->has_secSetMetadata               = 1;
    if (pgFunctionTable->secAllocateBuffer)            (*pxOutputMessage)->has_secAllocateBuffer            = 1;
    if (pgFunctionTable->secFreeBuffer)                (*pxOutputMessage)->has_secFreeBuffer                = 1;
    if (pgFunctionTable->secUseLegacyKey)              (*pxOutputMessage)->has_secUseLegacyKey              = 1;
  }

  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_getGetNuid
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_getNuid
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg           ** pxOutputMessage
)
{
  TSecStatus   secStatus;
  TSecNuid     secNuid;
  TSecNuid   * pSecNuid = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_output) pSecNuid = &secNuid;

    secStatus = pgFunctionTable->secGetNuid (pSecNuid);

    if ((secStatus == SEC_NO_ERROR) && pSecNuid)
    {
      TUnsignedInt8 * pNuidArray = (TUnsignedInt8*)MSGBUF_SYS_malloc (sizeof(TSecNuid));
      MSGBUF_SYS_memcpy (pNuidArray, secNuid, sizeof(TSecNuid));

      (*pxOutputMessage)->byteArray.len   = (size_t)sizeof(TSecNuid);
      (*pxOutputMessage)->byteArray.pData = (void*)pNuidArray;
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_getLegacyNuid
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_getLegacyNuid
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg           ** pxOutputMessage
)
{
  TSecStatus   secStatus;
  TSecNuid     secNuid;
  TSecNuid   * pSecNuid = NULL;

  if (pxInputMessage->has_output) pSecNuid = &secNuid;

  secStatus = _CRPC(secGetNuid) (pSecNuid);

  if ((secStatus == SEC_NO_ERROR) && pSecNuid)
  {
    TUnsignedInt8 * pNuidArray = (TUnsignedInt8*)MSGBUF_SYS_malloc (sizeof(TSecNuid));
    MSGBUF_SYS_memcpy (pNuidArray, secNuid, sizeof(TSecNuid));

    (*pxOutputMessage)->byteArray.len   = (size_t)sizeof(TSecNuid);
    (*pxOutputMessage)->byteArray.pData = (void*)pNuidArray;
  }

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_getGetNuid64
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_getNuid64
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg           ** pxOutputMessage
)
{
  TSecStatus   secStatus;
  TSecNuid64   secNuid64;
  TSecNuid64 * pSecNuid64 = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_output) pSecNuid64 = &secNuid64;

    secStatus = pgFunctionTable->secGetNuid64 (pSecNuid64);

    if ((secStatus == SEC_NO_ERROR) && pSecNuid64)
    {
      TUnsignedInt8 * pNuidArray = (TUnsignedInt8*)MSGBUF_SYS_malloc (sizeof(TSecNuid64));
      MSGBUF_SYS_memcpy (pNuidArray, secNuid64, sizeof(TSecNuid64));

      (*pxOutputMessage)->byteArray.len   = (size_t)sizeof(TSecNuid64);
      (*pxOutputMessage)->byteArray.pData = (void*)pNuidArray;
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_getChipsetRevision
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_getChipsetRevision
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_StringOutMsg          ** pxOutputMessage
)
{
  TSecStatus    secStatus;
  TChar       * chipsetRevision  = NULL;
  TChar      ** pChipsetRevision = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_output) pChipsetRevision = &chipsetRevision;

    secStatus = pgFunctionTable->secGetChipsetRevision ((const TChar **)pChipsetRevision);

    if ((secStatus == SEC_NO_ERROR) && pChipsetRevision && chipsetRevision)
    {
      TChar * pRevString = (TChar*)MSGBUF_SYS_malloc (MSGBUF_SYS_strlen (chipsetRevision) + 1);
      MSGBUF_SYS_strcpy (pRevString, chipsetRevision);

      (*pxOutputMessage)->info = (char*)pRevString;
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_getChipsetExtension
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_getChipsetExtension
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_StringOutMsg          ** pxOutputMessage
)
{
  TSecStatus    secStatus;
  TChar      *  chipsetExtension  = NULL;
  TChar      ** pChipsetExtension = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_output) pChipsetExtension = &chipsetExtension;

    secStatus = pgFunctionTable->secGetChipsetExtension ((const TChar **)pChipsetExtension);

    if ((secStatus == SEC_NO_ERROR) && pChipsetExtension && chipsetExtension)
    {
      TChar * pRevString = (TChar*)MSGBUF_SYS_malloc (MSGBUF_SYS_strlen (chipsetExtension) + 1);
      MSGBUF_SYS_strcpy (pRevString, chipsetExtension);

      (*pxOutputMessage)->info = (char*)pRevString;
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_getLegacyChipsetRevision
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_getLegacyChipsetRevision
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_StringOutMsg          ** pxOutputMessage
)
{
  TSecStatus    secStatus;
  TChar      *  chipsetRevision  = NULL;
  TChar      ** pChipsetRevision = NULL;

  if (pxInputMessage->has_output) pChipsetRevision = &chipsetRevision;

  secStatus = _CRPC(secGetChipsetRevision) ((const TChar **)pChipsetRevision);

  if ((secStatus == SEC_NO_ERROR) && pChipsetRevision && chipsetRevision)
  {
    TChar * pRevString = (TChar*)MSGBUF_SYS_malloc (MSGBUF_SYS_strlen (chipsetRevision) + 1);
    MSGBUF_SYS_strcpy (pRevString, chipsetRevision);

    (*pxOutputMessage)->info = (char*)pRevString;
  }

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_getSecSoftwareVersion
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_getSecSoftwareVersion
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_ValueOutMsg           ** pxOutputMessage
)
{
  TSecStatus       secStatus;
  TUnsignedInt32   version;
  TUnsignedInt32 * pVersion = NULL;

  if (pxInputMessage->has_output) pVersion = &version;

  secStatus = _CRPC(secGetSoftwareVersion) (pVersion);

  if ((secStatus == SEC_NO_ERROR) && pVersion)
  {
    (*pxOutputMessage)->has_value = 1;
    (*pxOutputMessage)->value     = (uint32_t)version;
  }

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_getNhtSecSoftwareVersion
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_getNhtSecSoftwareVersion
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_ValueOutMsg           ** pxOutputMessage
)
{
  TSecStatus       secStatus;
  TUnsignedInt32   version;
  TUnsignedInt32 * pVersion = NULL;

  if (pxInputMessage->has_output) pVersion = &version;

  secStatus = _CRPC(nhtSecGetSoftwareVersion) (pVersion);

  if ((secStatus == SEC_NO_ERROR) && pVersion)
  {
    (*pxOutputMessage)->has_value = 1;
    (*pxOutputMessage)->value     = (uint32_t)version;
  }

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_getNhtSecApiVersion
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_getNhtSecApiVersion
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_ValueOutMsg           ** pxOutputMessage
)
{
  TSecStatus       secStatus;
  TUnsignedInt32   version;
  TUnsignedInt32 * pVersion = NULL;

  if (pxInputMessage->has_output) pVersion = &version;

  secStatus = _CRPC(nhtSecGetNhtSecApiVersion) (pVersion);

  if ((secStatus == SEC_NO_ERROR) && pVersion)
  {
    (*pxOutputMessage)->has_value = 1;
    (*pxOutputMessage)->value     = (uint32_t)version;
  }

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_encryptData
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_encryptData
(
  TMsgBuf_rpcHandler                  xRpcHandler,
  const TNhtsec_CryptoProcessInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg              ** pxOutputMessage
)
{
  TSecStatus      secStatus;
  TUnsignedInt8 * pInput       = NULL;
  TUnsignedInt8 * pOutput      = NULL;
  TMsgBuf_bytes * pMsgbufBytes = NULL;
  int             dataSize;

  if (pgFunctionTable)
  {
    dataSize = (int)pxInputMessage->dataInSize;
    pInput   = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dataIn);
    pOutput  = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, dataSize);

    secStatus = pgFunctionTable->secEncryptData (
      pOutput,
      pInput,
      (TSize)dataSize );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->dataOut, pOutput, dataSize, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_legacyEncryptData
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_legacyEncryptData
(
  TMsgBuf_rpcHandler                  xRpcHandler,
  const TNhtsec_CryptoProcessInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg              ** pxOutputMessage
)
{
  TSecStatus      secStatus;
  TUnsignedInt8 * pInput       = NULL;
  TUnsignedInt8 * pOutput      = NULL;
  TMsgBuf_bytes * pMsgbufBytes = NULL;
  int             dataSize;

  dataSize = (int)pxInputMessage->dataInSize;
  pInput   = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dataIn);
  pOutput  = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, dataSize);

  secStatus = _CRPC(secEncryptData) (
    pOutput,
    pInput,
    (TSize)dataSize );

  if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
  _setSysOutBytes (pxInputMessage->dataOut, pOutput, dataSize, pMsgbufBytes);

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_decryptData
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_decryptData
(
  TMsgBuf_rpcHandler                  xRpcHandler,
  const TNhtsec_CryptoProcessInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg              ** pxOutputMessage
)
{
  TSecStatus      secStatus;
  TUnsignedInt8 * pInput       = NULL;
  TUnsignedInt8 * pOutput      = NULL;
  TMsgBuf_bytes * pMsgbufBytes = NULL;
  int             dataSize;

  if (pgFunctionTable)
  {
    dataSize = (int)pxInputMessage->dataInSize;
    pInput   = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dataIn);
    pOutput  = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, dataSize);

    secStatus = pgFunctionTable->secDecryptData (
      pOutput,
      pInput,
      (TSize)dataSize );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->dataOut, pOutput, dataSize, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_legacyDecryptData
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_legacyDecryptData
(
  TMsgBuf_rpcHandler                  xRpcHandler,
  const TNhtsec_CryptoProcessInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg              ** pxOutputMessage
)
{
  TSecStatus      secStatus;
  TUnsignedInt8 * pInput       = NULL;
  TUnsignedInt8 * pOutput      = NULL;
  TMsgBuf_bytes * pMsgbufBytes = NULL;
  int             dataSize;

  dataSize = (int)pxInputMessage->dataInSize;
  pInput   = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dataIn);
  pOutput  = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, dataSize);

  secStatus = _CRPC(secDecryptData) (
    pOutput,
    pInput,
    (TSize)dataSize );

  if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
  _setSysOutBytes (pxInputMessage->dataOut, pOutput, dataSize, pMsgbufBytes);

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_doMonteCarloTest
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_doMonteCarloTest
(
  TMsgBuf_rpcHandler                     xRpcHandler,
  const TNhtsec_R2rMonteCarloRunInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg                 ** pxOutputMessage
)
{
  TSecStatus                         secStatus;
  TNhtSec_r2r_test_algoParams        params;
  TNhtSec_r2r_test_algoParams      * pParams       = NULL;
  TNhtsec_R2rMonteCarloParamsInMsg * pParams_inMsg;
  TUnsignedInt8                    * pOutput       = NULL;
  size_t                             dataSize      = 16;
  TMsgBuf_bytes                    * pMsgbufBytes  = NULL;

  nhtsec_r2r_testAlgo_initParams (&params);

  pParams_inMsg = pxInputMessage->params;
  if (pParams_inMsg)
  {
    pParams = &params;

    if (pParams_inMsg->has_sessionHandle)
      params.cipherSession =  (TSecCipherSession)(size_t)pParams_inMsg->sessionHandle;

    params.ivEmulate        = (TBoolean)pParams_inMsg->hasIvEmulation;
    params.isLegacy         = (TBoolean)pParams_inMsg->isLegacy;
    params.emi              = (TUnsignedInt16)pParams_inMsg->emi;
    params.isForEncryption  = (TBoolean)pParams_inMsg->isForEncryption;
    params.isMonteCarlo     = (TBoolean)pParams_inMsg->isMonteCarlo;
    params.runNumber        = (TUnsignedInt32)pParams_inMsg->runNumber;
    params.dataSize         = (TSize)pParams_inMsg->dataInSize;
    params.ivSize           = (TSize)pParams_inMsg->ivSize;
    params.pIv              = (TUnsignedInt8*)_buildSysInBytes (pParams_inMsg->iv);
    params.keyIdSize        = (TSize)pParams_inMsg->keyIdSize;
    params.pKeyId           = (TUnsignedInt8*)_buildSysInBytes (pParams_inMsg->keyId);
    params.pInputData       = (TUnsignedInt8*)_buildSysInBytes (pParams_inMsg->dataIn);

    dataSize = (size_t)params.dataSize;
  }

  pOutput = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, dataSize);

  secStatus = _CRPC(nhtsec_r2r_monteCarlo_test_run) (
    pParams,
    pOutput );

  if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
  _setSysOutBytes (pxInputMessage->dataOut, pOutput, dataSize, pMsgbufBytes);

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_rsaGenerateKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_rsaGenerateKey
(
  TMsgBuf_rpcHandler              xRpcHandler,
  const TNhtsec_RsaGenKeyInMsg  * pxInputMessage,
  TNhtsec_RsaGenKeyOutMsg      ** pxOutputMessage
)
{
  TSecStatus       secStatus;
  size_t           keySize;
  TUnsignedInt32   e;
  TUnsignedInt8  * pN    = NULL;
  TUnsignedInt8  * pP    = NULL;
  TUnsignedInt8  * pQ    = NULL;
  TUnsignedInt8  * pDP   = NULL;
  TUnsignedInt8  * pDQ   = NULL;
  TUnsignedInt8  * pQinv = NULL;

  if (pgFunctionTable)
  {
    keySize = (size_t)pxInputMessage->keySize;
    e = (TUnsignedInt32)pxInputMessage->e;

    pN    = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->n,    (int)keySize);
    pP    = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->p,    (int)keySize/2);
    pQ    = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->q,    (int)keySize/2);
    pDP   = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dp,   (int)keySize/2);
    pDQ   = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dq,   (int)keySize/2);
    pQinv = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->qinv, (int)keySize/2);

    secStatus = pgFunctionTable->secRsaGenerateKey (
      keySize,
      e,
      pN,
      pP,
      pQ,
      pDP,
      pDQ,
      pQinv );

    if (secStatus == SEC_NO_ERROR)
    {
      _setSysOutBytes (pxInputMessage->n,    pN, (int)keySize,      &(*pxOutputMessage)->n);
      _setSysOutBytes (pxInputMessage->p,    pP, (int)keySize/2,    &(*pxOutputMessage)->p);
      _setSysOutBytes (pxInputMessage->q,    pQ, (int)keySize/2,    &(*pxOutputMessage)->q);
      _setSysOutBytes (pxInputMessage->dp,   pDP, (int)keySize/2,   &(*pxOutputMessage)->dp);
      _setSysOutBytes (pxInputMessage->dq,   pDQ, (int)keySize/2,   &(*pxOutputMessage)->dq);
      _setSysOutBytes (pxInputMessage->qinv, pQinv, (int)keySize/2, &(*pxOutputMessage)->qinv);
    }
    else
    {
      _setSysOutBytes (pxInputMessage->n,    pN,    (int)keySize, NULL);
      _setSysOutBytes (pxInputMessage->p,    pP,    (int)keySize/2, NULL);
      _setSysOutBytes (pxInputMessage->q,    pQ,    (int)keySize/2, NULL);
      _setSysOutBytes (pxInputMessage->dp,   pDP,   (int)keySize/2, NULL);
      _setSysOutBytes (pxInputMessage->dq,   pDQ,   (int)keySize/2, NULL);
      _setSysOutBytes (pxInputMessage->qinv, pQinv, (int)keySize/2, NULL);
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_rsaPublicEncrypt
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_rsaPublicEncrypt
(
  TMsgBuf_rpcHandler                     xRpcHandler,
  const TNhtsec_RsaPublicEncryptInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg                 ** pxOutputMessage
)
{
  TSecStatus       secStatus;
  size_t           keySize;
  TUnsignedInt32   e;
  TUnsignedInt8  * pInput       = NULL;
  TUnsignedInt8  * pOutput      = NULL;
  TUnsignedInt8  * pN           = NULL;
  TSecRsaPadding   padding;
  TMsgBuf_bytes  * pMsgbufBytes = NULL;
  int              dataInSize;

  if (pgFunctionTable)
  {
    dataInSize = (int)pxInputMessage->dataInSize;
    e          = (TUnsignedInt32)pxInputMessage->e;
    keySize    = (size_t)pxInputMessage->keySize;
    padding    = (TSecRsaPadding)pxInputMessage->padding;
    pInput     = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dataIn);
    pN         = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->n);
    pOutput    = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, keySize);

    secStatus = pgFunctionTable->secRsaPublicEncrypt (
      pInput,
      (TSize)dataInSize,
      pOutput,
      e,
      pN,
      keySize,
      padding );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->dataOut, pOutput, keySize, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_rsaPrivateEncrypt
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_rsaPrivateEncrypt
(
  TMsgBuf_rpcHandler                      xRpcHandler,
  const TNhtsec_RsaPrivateEncryptInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg                  ** pxOutputMessage
)
{
  TSecStatus       secStatus;
  size_t           keySize;
  TUnsignedInt32   e;
  TUnsignedInt8  * pInput       = NULL;
  TUnsignedInt8  * pOutput      = NULL;
  TUnsignedInt8  * pN           = NULL;
  TUnsignedInt8  * pP           = NULL;
  TUnsignedInt8  * pQ           = NULL;
  TUnsignedInt8  * pDP          = NULL;
  TUnsignedInt8  * pDQ          = NULL;
  TUnsignedInt8  * pQinv        = NULL;
  TSecRsaPadding   padding;
  TMsgBuf_bytes  * pMsgbufBytes = NULL;
  int              dataInSize;

  if (pgFunctionTable)
  {
    dataInSize = (int)pxInputMessage->dataInSize;
    e          = (TUnsignedInt32)pxInputMessage->e;
    keySize    = (size_t)pxInputMessage->keySize;
    padding    = (TSecRsaPadding)pxInputMessage->padding;
    pInput     = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dataIn);
    pN         = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->n);
    pP         = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->p);
    pQ         = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->q);
    pDP        = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dp);
    pDQ        = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dq);
    pQinv      = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->qinv);
    pOutput    = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, keySize);

    secStatus = pgFunctionTable->secRsaPrivateEncrypt (
      pInput,
      (TSize)dataInSize,
      pOutput,
      e,
      pN,
      pP,
      pQ,
      pDP,
      pDQ,
      pQinv,
      keySize,
      padding );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->dataOut, pOutput, keySize, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_rsaPublicDecrypt
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_rsaPublicDecrypt
(
  TMsgBuf_rpcHandler                     xRpcHandler,
  const TNhtsec_RsaPublicDecryptInMsg  * pxInputMessage,
  TNhtsec_RsaDecryptOutMsg            ** pxOutputMessage
)
{
  TSecStatus       secStatus;
  size_t           keySize;
  TUnsignedInt32   e;
  TUnsignedInt8  * pInput       = NULL;
  TUnsignedInt8  * pOutput      = NULL;
  size_t           outputSize   = (size_t)pxInputMessage->keySize;
  size_t         * pOutputSize  = NULL;
  TUnsignedInt8  * pN           = NULL;
  TSecRsaPadding   padding;
  TMsgBuf_bytes  * pMsgbufBytes = NULL;

  if (pgFunctionTable)
  {
    e          = (TUnsignedInt32)pxInputMessage->e;
    keySize    = (size_t)pxInputMessage->keySize;
    outputSize = keySize;
    padding    = (TSecRsaPadding)pxInputMessage->padding;
    pInput     = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dataIn);
    pN         = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->n);

    if (pxInputMessage->has_outputSize) pOutputSize = &outputSize;

    pOutput = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, keySize);

    secStatus = pgFunctionTable->secRsaPublicDecrypt (
      pInput,
      pOutput,
      pOutputSize,
      e,
      pN,
      keySize,
      padding );

    if (secStatus == SEC_NO_ERROR)
    {
      pMsgbufBytes = &(*pxOutputMessage)->byteArray;
      if (pOutputSize)
      {
        (*pxOutputMessage)->has_outputSize = 1;
        (*pxOutputMessage)->outputSize     = (uint32_t)outputSize;
      }
    }
    _setSysOutBytes (pxInputMessage->dataOut, pOutput, outputSize, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_rsaPrivateDecrypt
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_rsaPrivateDecrypt
(
  TMsgBuf_rpcHandler                      xRpcHandler,
  const TNhtsec_RsaPrivateDecryptInMsg  * pxInputMessage,
  TNhtsec_RsaDecryptOutMsg             ** pxOutputMessage
)
{
  TSecStatus       secStatus;
  size_t           keySize;
  TUnsignedInt32   e;
  TUnsignedInt8  * pInput        = NULL;
  TUnsignedInt8  * pOutput       = NULL;
  TUnsignedInt8  * pN            = NULL;
  TUnsignedInt8  * pP            = NULL;
  TUnsignedInt8  * pQ            = NULL;
  TUnsignedInt8  * pDP           = NULL;
  TUnsignedInt8  * pDQ           = NULL;
  TUnsignedInt8  * pQinv         = NULL;
  TSecRsaPadding   padding;
  size_t           outputSize    = (size_t)pxInputMessage->keySize;
  size_t         * pOutputSize   = NULL;
  TMsgBuf_bytes  * pMsgbufBytes  = NULL;

  if (pgFunctionTable)
  {
    e          = (TUnsignedInt32)pxInputMessage->e;
    keySize    = (size_t)pxInputMessage->keySize;
    outputSize = keySize;
    padding    = (TSecRsaPadding)pxInputMessage->padding;
    pInput     = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dataIn);
    pN         = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->n);
    pP         = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->p);
    pQ         = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->q);
    pDP        = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dp);
    pDQ        = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dq);
    pQinv      = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->qinv);

    if (pxInputMessage->has_outputSize) pOutputSize = &outputSize;

    pOutput = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, keySize);

    secStatus = pgFunctionTable->secRsaPrivateDecrypt (
      pInput,
      pOutput,
      pOutputSize,
      e,
      pN,
      pP,
      pQ,
      pDP,
      pDQ,
      pQinv,
      keySize,
      padding );

    if (secStatus == SEC_NO_ERROR)
    {
      pMsgbufBytes = &(*pxOutputMessage)->byteArray;
      if (pOutputSize)
      {
        (*pxOutputMessage)->has_outputSize = 1;
        (*pxOutputMessage)->outputSize     = (uint32_t)outputSize;
      }
    }
    _setSysOutBytes (pxInputMessage->dataOut, pOutput, outputSize, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_rsaComputeCrtParams
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_rsaComputeCrtParams
(
  TMsgBuf_rpcHandler                        xRpcHandler,
  const TNhtsec_RsaComputeCrtParamsInMsg  * pxInputMessage,
  TNhtsec_RsaComputeCrtParamsOutMsg      ** pxOutputMessage
)
{
  TSecStatus       secStatus;
  size_t           keySize;
  TUnsignedInt32   e;
  TUnsignedInt8  * pP    = NULL;
  TUnsignedInt8  * pQ    = NULL;
  TUnsignedInt8  * pDP   = NULL;
  TUnsignedInt8  * pDQ   = NULL;
  TUnsignedInt8  * pQinv = NULL;

  if (pgFunctionTable)
  {
    keySize = (size_t)pxInputMessage->keySize;
    e       = (TUnsignedInt32)pxInputMessage->e;

    pP    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->p);
    pQ    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->q);
    pDP   = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->dp, (int)keySize/2);
    pDQ   = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->dq, (int)keySize/2);
    pQinv = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->qinv, (int)keySize/2);

    secStatus = pgFunctionTable->secRsaComputeCrtParams (
      keySize,
      e,
      pP,
      pQ,
      pDP,
      pDQ,
      pQinv );

    if (secStatus == SEC_NO_ERROR)
    {
      _setSysOutBytes (pxInputMessage->dp,   pDP,   (int)keySize/2, &(*pxOutputMessage)->dp);
      _setSysOutBytes (pxInputMessage->dq,   pDQ,   (int)keySize/2, &(*pxOutputMessage)->dq);
      _setSysOutBytes (pxInputMessage->qinv, pQinv, (int)keySize/2, &(*pxOutputMessage)->qinv);
    }
    else
    {
      _setSysOutBytes (pxInputMessage->dp,   pDP,   (int)keySize/2, NULL);
      _setSysOutBytes (pxInputMessage->dq,   pDQ,   (int)keySize/2, NULL);
      _setSysOutBytes (pxInputMessage->qinv, pQinv, (int)keySize/2, NULL);
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_dhGenerateKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_dhGenerateKey
(
  TMsgBuf_rpcHandler                  xRpcHandler,
  const TNhtsec_DhGenerateKeyInMsg  * pxInputMessage,
  TNhtsec_DhGenerateKeyOutMsg      ** pxOutputMessage
)
{
  TSecStatus      secStatus;
  size_t          keySize;
  TUnsignedInt8 * pG                = NULL;
  TUnsignedInt8 * pP                = NULL;
  TUnsignedInt8 * pInputPrivateKey  = NULL;
  TUnsignedInt8 * pOutputPrivateKey = NULL;
  TUnsignedInt8 * pOutputPubKey     = NULL;

  if (pgFunctionTable)
  {
    keySize = (size_t)pxInputMessage->keySize;

    pG                = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->g);
    pP                = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->p);
    pInputPrivateKey  = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->inputPrivateKey);
    pOutputPrivateKey = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->outputPrivateKey, keySize);
    pOutputPubKey     = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->outputPubKey,     keySize);

    secStatus = pgFunctionTable->secDhGenerateKey (
      pG,
      pP,
      pInputPrivateKey,
      pOutputPrivateKey,
      pOutputPubKey,
      keySize );

    if (secStatus == SEC_NO_ERROR)
    {
      _setSysOutBytes (pxInputMessage->outputPrivateKey, pOutputPrivateKey, keySize, &(*pxOutputMessage)->privateKey);
      _setSysOutBytes (pxInputMessage->outputPubKey,     pOutputPubKey,     keySize, &(*pxOutputMessage)->pubKey);
    }
    else
    {
      _setSysOutBytes (pxInputMessage->outputPrivateKey, pOutputPrivateKey, keySize, NULL);
      _setSysOutBytes (pxInputMessage->outputPubKey,     pOutputPubKey,     keySize, NULL);
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_dhComputeKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_dhComputeKey
(
  TMsgBuf_rpcHandler                 xRpcHandler,
  const TNhtsec_DhComputeKeyInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg             ** pxOutputMessage
)
{
  TSecStatus      secStatus;
  size_t          keySize;
  TUnsignedInt8 * pP               = NULL;
  TUnsignedInt8 * pPrivKey         = NULL;
  TUnsignedInt8 * pOtherPubKey     = NULL;
  TUnsignedInt8 * pSharedSecretKey = NULL;
  TMsgBuf_bytes * pMsgbufBytes     = NULL;

  if (pgFunctionTable)
  {
    keySize          = (size_t)pxInputMessage->keySize;
    pP               = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->p);
    pPrivKey         = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->privateKey);
    pOtherPubKey     = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->otherPubKey);
    pSharedSecretKey = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->output, keySize);

    secStatus = pgFunctionTable->secDhComputeKey (
      pP,
      pPrivKey,
      pOtherPubKey,
      pSharedSecretKey,
      keySize );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->output, pSharedSecretKey, keySize, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_sha1Init
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_sha1Init
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_HandleOutMsg          ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecHashContext   context    = NULL;
  TSecHashContext * pContext   = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_output) pContext = &context;

    secStatus = pgFunctionTable->secSha1Init (pContext);

    if (secStatus == SEC_NO_ERROR)
    {
      if (pContext)
      {
        (*pxOutputMessage)->has_handle = 1;
        (*pxOutputMessage)->handle     = (int64_t)(size_t)context;
      }
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_sha1Update
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_sha1Update
(
  TMsgBuf_rpcHandler              xRpcHandler,
  const TNhtsec_ShaUpdateInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg         ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecHashContext   context    = NULL;
  size_t            chunkSize;
  TUnsignedInt8   * pChunk     = NULL;

  if (pgFunctionTable)
  {
    chunkSize = (size_t)pxInputMessage->chunkSize;
    pChunk    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->chunk);

    if (pxInputMessage->has_handle) context = (TSecHashContext)(size_t)pxInputMessage->handle;

    secStatus = pgFunctionTable->secSha1Update (
      context,
      pChunk,
      chunkSize );
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_sha1Final
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_sha1Final
(
  TMsgBuf_rpcHandler             xRpcHandler,
  const TNhtsec_ShaFinalInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg         ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecHashContext   context        = NULL;
  TUnsignedInt8   * pMessageDigest = NULL;
  TMsgBuf_bytes   * pMsgbufBytes   = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) context = (TSecHashContext)(size_t)pxInputMessage->handle;

    pMessageDigest = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->digest, 20);

    secStatus = pgFunctionTable->secSha1Final (
      context,
      pMessageDigest );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->digest, pMessageDigest, 20, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_sha256Init
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_sha256Init
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_HandleOutMsg          ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecHashContext   context    = NULL;
  TSecHashContext * pContext   = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_output) pContext = &context;

    secStatus = pgFunctionTable->secSha256Init (pContext);

    if (secStatus == SEC_NO_ERROR)
    {
      if (pContext)
      {
        (*pxOutputMessage)->has_handle = 1;
        (*pxOutputMessage)->handle     = (int64_t)(size_t)context;
      }
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_sha256Update
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_sha256Update
(
  TMsgBuf_rpcHandler              xRpcHandler,
  const TNhtsec_ShaUpdateInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg         ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecHashContext   context    = NULL;
  size_t            chunkSize;
  TUnsignedInt8   * pChunk     = NULL;

  if (pgFunctionTable)
  {
    chunkSize = (size_t)pxInputMessage->chunkSize;
    pChunk    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->chunk);

    if (pxInputMessage->has_handle) context = (TSecHashContext)(size_t)pxInputMessage->handle;

    secStatus = pgFunctionTable->secSha256Update (
      context,
      pChunk,
      chunkSize );
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_sha256Final
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_sha256Final
(
  TMsgBuf_rpcHandler             xRpcHandler,
  const TNhtsec_ShaFinalInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg         ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecHashContext   context        = NULL;
  TUnsignedInt8   * pMessageDigest = NULL;
  TMsgBuf_bytes   * pMsgbufBytes   = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) context = (TSecHashContext)(size_t)pxInputMessage->handle;

    pMessageDigest = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->digest, 32);

    secStatus = pgFunctionTable->secSha256Final (
      context,
      pMessageDigest );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->digest, pMessageDigest, 32, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_sha384Init
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_sha384Init
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_HandleOutMsg          ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecHashContext   context    = NULL;
  TSecHashContext * pContext   = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_output) pContext = &context;

    secStatus = pgFunctionTable->secSha384Init (pContext);

    if (secStatus == SEC_NO_ERROR)
    {
      if (pContext)
      {
        (*pxOutputMessage)->has_handle = 1;
        (*pxOutputMessage)->handle     = (int64_t)(size_t)context;
      }
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_sha384Update
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_sha384Update
(
  TMsgBuf_rpcHandler              xRpcHandler,
  const TNhtsec_ShaUpdateInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg         ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecHashContext   context    = NULL;
  size_t            chunkSize;
  TUnsignedInt8   * pChunk     = NULL;

  if (pgFunctionTable)
  {
    chunkSize = (size_t)pxInputMessage->chunkSize;
    pChunk    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->chunk);

    if (pxInputMessage->has_handle) context = (TSecHashContext)(size_t)pxInputMessage->handle;

    secStatus = pgFunctionTable->secSha384Update (
      context,
      pChunk,
      chunkSize );
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_sha384Final
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_sha384Final
(
  TMsgBuf_rpcHandler             xRpcHandler,
  const TNhtsec_ShaFinalInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg         ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecHashContext   context        = NULL;
  TUnsignedInt8   * pMessageDigest = NULL;
  TMsgBuf_bytes   * pMsgbufBytes   = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) context = (TSecHashContext)(size_t)pxInputMessage->handle;

    pMessageDigest = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->digest, 48);

    secStatus = pgFunctionTable->secSha384Final (
      context,
      pMessageDigest );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->digest, pMessageDigest, 48, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_hmacSha256Init
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_hmacSha256Init
(
  TMsgBuf_rpcHandler                xRpcHandler,
  const TNhtsec_HmacShaInitInMsg  * pxInputMessage,
  TNhtsec_HandleOutMsg           ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecHashContext   context    = NULL;
  TSecHashContext * pContext   = NULL;
  size_t            keySize;
  TUnsignedInt8   * pKey       = NULL;

  if (pgFunctionTable)
  {
    keySize = (size_t)pxInputMessage->keySize;
    pKey    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->key);

    if (pxInputMessage->has_output) pContext = &context;

    secStatus = pgFunctionTable->secHmacSha256Init (
      pKey,
      keySize,
      pContext );

    if (secStatus == SEC_NO_ERROR)
    {
      if (pContext)
      {
        (*pxOutputMessage)->has_handle = 1;
        (*pxOutputMessage)->handle     = (int64_t)(size_t)context;
      }
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_hmacSha256Update
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_hmacSha256Update
(
  TMsgBuf_rpcHandler              xRpcHandler,
  const TNhtsec_ShaUpdateInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg         ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecHashContext   context    = NULL;
  size_t            chunkSize;
  TUnsignedInt8   * pChunk     = NULL;

  if (pgFunctionTable)
  {
    chunkSize = (size_t)pxInputMessage->chunkSize;
    pChunk    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->chunk);

    if (pxInputMessage->has_handle) context = (TSecHashContext)(size_t)pxInputMessage->handle;

    secStatus = pgFunctionTable->secHmacSha256Update (
      context,
      pChunk,
      chunkSize );
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_hmacSha256Final
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_hmacSha256Final
(
  TMsgBuf_rpcHandler             xRpcHandler,
  const TNhtsec_ShaFinalInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg         ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecHashContext   context        = NULL;
  TUnsignedInt8   * pMessageDigest = NULL;
  TMsgBuf_bytes   * pMsgbufBytes   = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) context = (TSecHashContext)(size_t)pxInputMessage->handle;

    pMessageDigest = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->digest, 32);

    secStatus = pgFunctionTable->secHmacSha256Final (
      context,
      pMessageDigest );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->digest, pMessageDigest, 32, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_generateRandomBytes
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_generateRandomBytes
(
  TMsgBuf_rpcHandler                        xRpcHandler,
  const TNhtsec_GenerateRandomBytesInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg                    ** pxOutputMessage
)
{
  TSecStatus      secStatus;
  size_t          number;
  TUnsignedInt8 * pOutput       = NULL;
  TMsgBuf_bytes * pMsgbufBytes  = NULL;

  if (pgFunctionTable)
  {
    number = (size_t)pxInputMessage->n;
    pOutput = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, number);

    secStatus = pgFunctionTable->secGenerateRandomBytes (
      number,
      pOutput );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->dataOut, pOutput, number, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_cdsaGenerateKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_ecdsaGenerateKey
(
  TMsgBuf_rpcHandler                     xRpcHandler,
  const TNhtsec_EcdsaGenerateKeyInMsg  * pxInputMessage,
  TNhtsec_EcdsaGenerateKeyOutMsg      ** pxOutputMessage
)
{
  TSecStatus            secStatus;
  TNhtsec_EcParamsMsg * pParams        = NULL;
  TSecEcParams          secParams;
  TSecEcParams        * pSecParams     = NULL;
  TUnsignedInt8       * pInputPrivKey  = NULL;
  TUnsignedInt8       * pOutputPrivKey = NULL;
  TUnsignedInt8       * pPubKeyX       = NULL;
  TUnsignedInt8       * pPubKeyY       = NULL;

  if (pgFunctionTable)
  {
    pParams = pxInputMessage->param;

    if (pParams) pSecParams = &secParams;
    _buildEcParams (pParams, &secParams);

    pInputPrivKey  = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->inputPrivKey);
    pOutputPrivKey = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->outputPrivKey, secParams.keySize);
    pPubKeyX       = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->pubKeyX,       secParams.keySize);
    pPubKeyY       = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->pubKeyY,       secParams.keySize);

    secStatus = pgFunctionTable->secEcdsaGenerateKey (
      *pSecParams,
      pInputPrivKey,
      pOutputPrivKey,
      pPubKeyX,
      pPubKeyY );

    if ((secStatus == SEC_NO_ERROR) && pParams)
    {
      _setSysOutBytes (pxInputMessage->outputPrivKey,  pOutputPrivKey, secParams.keySize, &(*pxOutputMessage)->privKey);
      _setSysOutBytes (pxInputMessage->pubKeyX,        pPubKeyX,       secParams.keySize, &(*pxOutputMessage)->pubKeyX);
      _setSysOutBytes (pxInputMessage->pubKeyY,        pPubKeyY,       secParams.keySize, &(*pxOutputMessage)->pubKeyY);
    }
    else
    {
      _setSysOutBytes (pxInputMessage->outputPrivKey,  pOutputPrivKey, secParams.keySize, NULL);
      _setSysOutBytes (pxInputMessage->pubKeyX,        pPubKeyX,       secParams.keySize, NULL);
      _setSysOutBytes (pxInputMessage->pubKeyY,        pPubKeyY,       secParams.keySize, NULL);
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_ecdsaSign
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_ecdsaSign
(
  TMsgBuf_rpcHandler              xRpcHandler,
  const TNhtsec_EcdsaSignInMsg  * pxInputMessage,
  TNhtsec_EcdsaSignOutMsg      ** pxOutputMessage
)
{
  TSecStatus            secStatus;
  TNhtsec_EcParamsMsg * pParams       = NULL;
  TSecEcParams          secParams;
  TSecEcParams        * pSecParams    = NULL;
  TSecHashType          hashType;
  TUnsignedInt8       * pInputPrivKey = NULL;
  size_t                messageSize;
  TUnsignedInt8       * pInput        = NULL;
  TUnsignedInt8       * pSigR         = NULL;
  TUnsignedInt8       * pSigS         = NULL;

  if (pgFunctionTable)
  {
    pParams = pxInputMessage->param;

    if (pParams) pSecParams = &secParams;
    _buildEcParams (pParams, &secParams);

    hashType      = (TSecHashType)pxInputMessage->hashType;
    messageSize   = (size_t)pxInputMessage->messageSize;
    pInputPrivKey = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->inputPrivKey);
    pInput        = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->message);
    pSigR         = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->sigR, secParams.keySize);
    pSigS         = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->sigS, secParams.keySize);

    secStatus = pgFunctionTable->secEcdsaSign (
      *pSecParams,
      hashType,
      pInputPrivKey,
      pInput,
      messageSize,
      pSigR,
      pSigS );

    if ((secStatus == SEC_NO_ERROR) && pParams)
    {
      _setSysOutBytes (pxInputMessage->sigR,  pSigR, secParams.keySize, &(*pxOutputMessage)->sigR);
      _setSysOutBytes (pxInputMessage->sigS,  pSigS, secParams.keySize, &(*pxOutputMessage)->sigS);
    }
    else
    {
      _setSysOutBytes (pxInputMessage->sigR,  pSigR, secParams.keySize, NULL);
      _setSysOutBytes (pxInputMessage->sigS,  pSigS, secParams.keySize, NULL);
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_ecdsaVerify
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_ecdsaVerify
(
  TMsgBuf_rpcHandler                xRpcHandler,
  const TNhtsec_EcdsaVerifyInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg           ** pxOutputMessage
)
{
  TSecStatus            secStatus;
  TNhtsec_EcParamsMsg * pParams      = NULL;
  TSecEcParams          secParams;
  TSecEcParams        * pSecParams   = NULL;
  TSecHashType          hashType;
  TUnsignedInt8       * pPubKeyX     = NULL;
  TUnsignedInt8       * pPubKeyY     = NULL;
  size_t                messageSize;
  TUnsignedInt8       * pInput       = NULL;
  TUnsignedInt8       * pSigR        = NULL;
  TUnsignedInt8       * pSigS        = NULL;

  if (pgFunctionTable)
  {
    pParams = pxInputMessage->param;

    if (pParams) pSecParams = &secParams;
    _buildEcParams (pParams, &secParams);

    messageSize = (size_t)pxInputMessage->messageSize;
    hashType    = (TSecHashType)pxInputMessage->hashType;
    pPubKeyX    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->pubKeyX);
    pPubKeyY    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->pubKeyY);
    pInput      = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->message);
    pSigR       = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->sigR);
    pSigS       = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->sigS);

    secStatus = pgFunctionTable->secEcdsaVerify (
      *pSecParams,
      hashType,
      pPubKeyX,
      pPubKeyY,
      pInput,
      messageSize,
      pSigR,
      pSigS );
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_ecdhGenerateKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_ecdhGenerateKey
(
  TMsgBuf_rpcHandler                 xRpcHandler,
  const TNhtsec_EcdhGenerateInMsg  * pxInputMessage,
  TNhtsec_EcdhGenerateOutMsg      ** pxOutputMessage
)
{
  TSecStatus            secStatus;
  TNhtsec_EcParamsMsg * pParams        = NULL;
  TSecEcParams          secParams;
  TSecEcParams        * pSecParams     = NULL;
  TUnsignedInt8       * pInputPrivKey  = NULL;
  TUnsignedInt8       * pOutputPrivKey = NULL;
  TUnsignedInt8       * pPubKeyX       = NULL;
  TUnsignedInt8       * pPubKeyY       = NULL;

  if (pgFunctionTable)
  {
    pParams = pxInputMessage->param;

    if (pParams) pSecParams = &secParams;
    _buildEcParams (pParams, &secParams);

    pInputPrivKey  = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->inputPrivKey);
    pOutputPrivKey = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->outputPrivKey, secParams.keySize);
    pPubKeyX       = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->pubKeyX,       secParams.keySize);
    pPubKeyY       = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->pubKeyY,       secParams.keySize);

    secStatus = pgFunctionTable->secEcdhGenerateKey (
      *pSecParams,
      pInputPrivKey,
      pOutputPrivKey,
      pPubKeyX,
      pPubKeyY );

    if ((secStatus == SEC_NO_ERROR) && pParams)
    {
      _setSysOutBytes (pxInputMessage->outputPrivKey,  pOutputPrivKey, secParams.keySize, &(*pxOutputMessage)->outputPrivKey);
      _setSysOutBytes (pxInputMessage->pubKeyX,        pPubKeyX,       secParams.keySize, &(*pxOutputMessage)->pubKeyX);
      _setSysOutBytes (pxInputMessage->pubKeyY,        pPubKeyY,       secParams.keySize, &(*pxOutputMessage)->pubKeyY);
    }
    else
    {
      _setSysOutBytes (pxInputMessage->outputPrivKey,  pOutputPrivKey, secParams.keySize, NULL);
      _setSysOutBytes (pxInputMessage->pubKeyX,        pPubKeyX,       secParams.keySize, NULL);
      _setSysOutBytes (pxInputMessage->pubKeyY,        pPubKeyY,       secParams.keySize, NULL);
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_ecdhComputeKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_ecdhComputeKey
(
  TMsgBuf_rpcHandler                   xRpcHandler,
  const TNhtsec_EcdhComputeKeyInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg               ** pxOutputMessage
)
{
  TSecStatus            secStatus;
  TNhtsec_EcParamsMsg * pParams       = NULL;
  TSecEcParams          secParams;
  TSecEcParams        * pSecParams    = NULL;
  TUnsignedInt8       * pInputPrivKey = NULL;
  TUnsignedInt8       * pOtherPubKeyX = NULL;
  TUnsignedInt8       * pOtherPubKeyY = NULL;
  TUnsignedInt8       * pSharedSecret = NULL;
  TMsgBuf_bytes       * pMsgbufBytes  = NULL;

  if (pgFunctionTable)
  {
    pParams = pxInputMessage->param;

    if (pParams) pSecParams = &secParams;
    _buildEcParams (pParams, &secParams);

    pInputPrivKey = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->inputPrivKey);
    pOtherPubKeyX = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->otherPubKeyX);
    pOtherPubKeyY = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->otherPubKeyY);
    pSharedSecret = (TUnsignedInt8*)_getSysOutBytes  (pxInputMessage->sharedSecretKey, secParams.keySize);

    secStatus = pgFunctionTable->secEcdhComputeKey (
      *pSecParams,
      pInputPrivKey,
      pOtherPubKeyX,
      pOtherPubKeyY,
      pSharedSecret );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->sharedSecretKey, pSharedSecret, secParams.keySize, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_openRam2RamEncryptSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_openRam2RamEncryptSession
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_HandleOutMsg          ** pxOutputMessage
)
{
  TSecStatus          secStatus;
  TSecCipherSession   session    = NULL;
  TSecCipherSession * pSession   = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_output) pSession = &session;

    secStatus = pgFunctionTable->secOpenRam2RamEncryptSession (pSession);

    if (secStatus == SEC_NO_ERROR)
    {
      if (pSession)
      {
        (*pxOutputMessage)->has_handle = 1;
        (*pxOutputMessage)->handle     = (int64_t)(size_t)session;
      }
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_openRam2RamDecryptSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_openRam2RamDecryptSession
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_OptOutput1InMsg  * pxInputMessage,
  TNhtsec_HandleOutMsg          ** pxOutputMessage
)
{
  TSecStatus          secStatus;
  TSecCipherSession   session    = NULL;
  TSecCipherSession * pSession   = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_output) pSession = &session;

    secStatus = pgFunctionTable->secOpenRam2RamDecryptSession (pSession);

    if (secStatus == SEC_NO_ERROR)
    {
      if (pSession)
      {
        (*pxOutputMessage)->has_handle = 1;
        (*pxOutputMessage)->handle     = (int64_t)(size_t)session;
      }
    }
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_closeSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_closeSession
(
  TMsgBuf_rpcHandler           xRpcHandler,
  const TNhtsec_HandleInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg      ** pxOutputMessage
)
{
  TSecStatus          secStatus;
  TSecCipherSession   session    = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) session = (TSecCipherSession)(size_t)pxInputMessage->handle;

    secStatus = pgFunctionTable->secCloseSession (session);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_setClearTextKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_setClearTextKey
(
  TMsgBuf_rpcHandler                    xRpcHandler,
  const TNhtsec_SetClearTextKeyInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg               ** pxOutputMessage
)
{
  TSecStatus          secStatus;
  TSecCipherSession   session           = NULL;
  TUnsignedInt16      emi;
  size_t              clearTextKeySize;
  TUnsignedInt8     * pClearTextKey     = NULL;
  size_t              keyIdSize;
  TUnsignedInt8     * pKeyId            = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) session = (TSecCipherSession)(size_t)pxInputMessage->handle;

    emi              = (TUnsignedInt16)pxInputMessage->emi;
    keyIdSize        = (size_t)pxInputMessage->keyIdSize;
    clearTextKeySize = (size_t)pxInputMessage->clearTextKeySize;
    pKeyId           = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->keyId);
    pClearTextKey    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->clearTextKey);

    secStatus = pgFunctionTable->secSetClearTextKey (
      session,
      emi,
      keyIdSize,
      pKeyId,
      clearTextKeySize,
      pClearTextKey );
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_set2LevelProtectedKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_set2LevelProtectedKey
(
  TMsgBuf_rpcHandler                          xRpcHandler,
  const TNhtsec_Set2LevelProtectedKeyInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg                     ** pxOutputMessage
)
{
  TSecStatus          secStatus;
  TSecCipherSession   session                    = NULL;
  TUnsignedInt16      emi;
  size_t              cipheredContentKeySize;
  TUnsignedInt8     * pCipheredContentKey        = NULL;
  size_t              cipheredProtectingKeySize;
  TUnsignedInt8     * pL1CipheredProtectingKey   = NULL;
  TUnsignedInt8     * pL2CipheredProtectingKey   = NULL;
  size_t              keyIdSize;
  TUnsignedInt8     * pKeyId                     = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) session = (TSecCipherSession)(size_t)pxInputMessage->handle;

    emi                       = (TUnsignedInt16)pxInputMessage->emi;
    keyIdSize                 = (size_t)pxInputMessage->keyIdSize;
    cipheredContentKeySize    = (size_t)pxInputMessage->cipheredContentKeySize;
    cipheredProtectingKeySize = (size_t)pxInputMessage->cipheredProtectingKeySize;
    pKeyId                    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->keyId);
    pCipheredContentKey       = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->cipheredContentKey);
    pL1CipheredProtectingKey  = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->l1CipheredProtectingKey);
    pL2CipheredProtectingKey  = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->l2CipheredProtectingKey);

    secStatus = pgFunctionTable->secSet2LevelProtectedKey (
      session,
      emi,
      keyIdSize,
      pKeyId,
      cipheredContentKeySize,
      pCipheredContentKey,
      cipheredProtectingKeySize,
      pL1CipheredProtectingKey,
      pL2CipheredProtectingKey );
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_useCertKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_useCertKey
(
  TMsgBuf_rpcHandler               xRpcHandler,
  const TNhtsec_UseCertKeyInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg          ** pxOutputMessage
)
{
  TSecStatus          secStatus;
  TSecCipherSession   session    = NULL;
  TUnsignedInt16      emi;
  size_t              keyIdSize;
  TUnsignedInt8     * pKeyId     = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) session = (TSecCipherSession)(size_t)pxInputMessage->handle;
    emi       = (TUnsignedInt16)pxInputMessage->emi;
    keyIdSize = (size_t)pxInputMessage->keyIdSize;
    pKeyId    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->keyId);

    secStatus = pgFunctionTable->secUseCertKey (
      session,
      emi,
      keyIdSize,
      pKeyId );
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_useFlashProtKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_useFlashProtKey
(
  TMsgBuf_rpcHandler                    xRpcHandler,
  const TNhtsec_UseFlashProtKeyInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg               ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecCipherSession session    = NULL;
  TUnsignedInt16    emi;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) session = (TSecCipherSession)(size_t)pxInputMessage->handle;
    emi = (TUnsignedInt16)pxInputMessage->emi;

    secStatus = pgFunctionTable->secUseFlashProtKey (
      session,
      emi );
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_sessionEncrypt
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_sessionEncrypt
(
  TMsgBuf_rpcHandler                         xRpcHandler,
  const TNhtsec_SessionCryptoProcessInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg                     ** pxOutputMessage
)
{
  TSecStatus          secStatus;
  TSecCipherSession   session         = NULL;
  size_t              dataInSize;
  size_t              initVectorSize;
  TUnsignedInt8     * pInput          = NULL;
  TUnsignedInt8     * pInitVector     = NULL;
  TUnsignedInt8     * pOutput         = NULL;
  TMsgBuf_bytes     * pMsgbufBytes    = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) session = (TSecCipherSession)(size_t)pxInputMessage->handle;

    dataInSize     = (size_t)pxInputMessage->dataInSize;
    initVectorSize = (size_t)pxInputMessage->ivSize;
    pInput         = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dataIn);
    pInitVector    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->iv);
    pOutput        = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, dataInSize);

    secStatus = pgFunctionTable->secSessionEncrypt (
      session,
      pInput,
      pOutput,
      dataInSize,
      pInitVector,
      initVectorSize );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->dataOut, pOutput, dataInSize, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_sessionDecrypt
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_sessionDecrypt
(
  TMsgBuf_rpcHandler                         xRpcHandler,
  const TNhtsec_SessionCryptoProcessInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg                     ** pxOutputMessage
)
{
  TSecStatus          secStatus;
  TSecCipherSession   session         = NULL;
  size_t              dataInSize;
  size_t              initVectorSize;
  TUnsignedInt8     * pInput          = NULL;
  TUnsignedInt8     * pInitVector     = NULL;
  TUnsignedInt8     * pOutput         = NULL;
  TMsgBuf_bytes     * pMsgbufBytes    = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) session = (TSecCipherSession)(size_t)pxInputMessage->handle;

    dataInSize     = (size_t)pxInputMessage->dataInSize;
    initVectorSize = (size_t)pxInputMessage->ivSize;
    pInput         = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dataIn);
    pInitVector    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->iv);
    pOutput        = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, dataInSize);

    secStatus = pgFunctionTable->secSessionDecrypt (
      session,
      pInput,
      pOutput,
      dataInSize,
      pInitVector,
      initVectorSize );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->dataOut, pOutput, dataInSize, pMsgbufBytes);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_encryptFlashProtKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_encryptFlashProtKey
(
  TMsgBuf_rpcHandler                  xRpcHandler,
  const TNhtsec_CryptoProcessInMsg  * pxInputMessage,
  TNhtsec_BytesOutMsg              ** pxOutputMessage
)
{
  TSecStatus      secStatus    = SEC_ERROR;
  TUnsignedInt8 * pInput       = NULL;
  TUnsignedInt8 * pOutput      = NULL;
  TMsgBuf_bytes * pMsgbufBytes = NULL;
  size_t          dataInSize;

  if (pgFunctionTable)
  {
    dataInSize = (size_t)pxInputMessage->dataInSize;

    pInput  = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->dataIn);
    pOutput = (TUnsignedInt8*)_getSysOutBytes (pxInputMessage->dataOut, dataInSize);

    secStatus = pgFunctionTable->secEncryptFlashProtKey (
      pInput,
      pOutput,
      dataInSize );

    if (secStatus == SEC_NO_ERROR) pMsgbufBytes = &(*pxOutputMessage)->byteArray;
    _setSysOutBytes (pxInputMessage->dataOut, pOutput, dataInSize, pMsgbufBytes);
  }

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_openStreamEncryptSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_openStreamEncryptSession
(
  TMsgBuf_rpcHandler                      xRpcHandler,
  const TNhtsec_StreamSessionOpenInMsg  * pxInputMessage,
  TNhtsec_HandleOutMsg                 ** pxOutputMessage
)
{
  TSecStatus            secStatus      = SEC_ERROR;
  TTransportSessionId   transportId;
  TSecCipherSession     cipherSession  = NULL;
  TSecCipherSession   * pCipherSession = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_output) pCipherSession = &cipherSession;
    transportId = (TTransportSessionId)pxInputMessage->transportSessionId;

    secStatus = pgFunctionTable->secOpenStreamEncryptSession (
      pCipherSession,
      transportId );

    if ((secStatus == SEC_NO_ERROR) && pCipherSession)
    {
      (*pxOutputMessage)->has_handle = 1;
      (*pxOutputMessage)->handle     = (int64_t)(size_t)cipherSession;
    }
  }

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_openStreamDecryptSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_openStreamDecryptSession
(
  TMsgBuf_rpcHandler                      xRpcHandler,
  const TNhtsec_StreamSessionOpenInMsg  * pxInputMessage,
  TNhtsec_HandleOutMsg                 ** pxOutputMessage
)
{
  TSecStatus            secStatus      = SEC_ERROR;
  TTransportSessionId   transportId;
  TSecCipherSession     cipherSession  = NULL;
  TSecCipherSession   * pCipherSession = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_output) pCipherSession = &cipherSession;
    transportId = (TTransportSessionId)pxInputMessage->transportSessionId;

    secStatus = pgFunctionTable->secOpenStreamDecryptSession (
      pCipherSession,
      transportId );

    if ((secStatus == SEC_NO_ERROR) && pCipherSession)
    {
      (*pxOutputMessage)->has_handle = 1;
      (*pxOutputMessage)->handle     = (int64_t)(size_t)cipherSession;
    }
  }

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_set0LevelProtectedKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_set0LevelProtectedKey
(
  TMsgBuf_rpcHandler                          xRpcHandler,
  const TNhtsec_Set0LevelProtectedKeyInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg                     ** pxOutputMessage
)
{
  TSecStatus          secStatus;
  TSecCipherSession   session                 = NULL;
  TUnsignedInt16      emi;
  size_t              cipheredContentKeySize;
  TUnsignedInt8     * pCipheredContentKey     = NULL;
  size_t              keyIdSize;
  TUnsignedInt8     * pKeyId                  = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) session = (TSecCipherSession)(size_t)pxInputMessage->handle;

    emi                    = (TUnsignedInt16)pxInputMessage->emi;
    keyIdSize              = (size_t)pxInputMessage->keyIdSize;
    cipheredContentKeySize = (size_t)pxInputMessage->cipheredContentKeySize;
    pKeyId                 = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->keyId);
    pCipheredContentKey    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->cipheredContentKey);

    secStatus = pgFunctionTable->secSet0LevelProtectedKey (
      session,
      emi,
      keyIdSize,
      pKeyId,
      cipheredContentKeySize,
      pCipheredContentKey );
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_set1LevelProtectedKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_set1LevelProtectedKey
(
  TMsgBuf_rpcHandler                          xRpcHandler,
  const TNhtsec_Set1LevelProtectedKeyInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg                     ** pxOutputMessage
)
{
  TSecStatus          secStatus;
  TSecCipherSession   session                    = NULL;
  TUnsignedInt16      emi;
  size_t              cipheredContentKeySize;
  TUnsignedInt8     * pCipheredContentKey        = NULL;
  size_t              cipheredProtectingKeySize;
  TUnsignedInt8     * pL1CipheredProtectingKey   = NULL;
  size_t              keyIdSize;
  TUnsignedInt8     * pKeyId                     = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) session = (TSecCipherSession)(size_t)pxInputMessage->handle;

    emi                       = (TUnsignedInt16)pxInputMessage->emi;
    keyIdSize                 = (size_t)pxInputMessage->keyIdSize;
    cipheredContentKeySize    = (size_t)pxInputMessage->cipheredContentKeySize;
    cipheredProtectingKeySize = (size_t)pxInputMessage->cipheredProtectingKeySize;
    pKeyId                    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->keyId);
    pCipheredContentKey       = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->cipheredContentKey);
    pL1CipheredProtectingKey  = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->l1CipheredProtectingKey);

    secStatus = pgFunctionTable->secSet1LevelProtectedKey (
      session,
      emi,
      keyIdSize,
      pKeyId,
      cipheredContentKeySize,
      pCipheredContentKey,
      cipheredProtectingKeySize,
      pL1CipheredProtectingKey );
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_setMetadata
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_setMetadata
(
  TMsgBuf_rpcHandler                xRpcHandler,
  const TNhtsec_SetMetadataInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg           ** pxOutputMessage
)
{
  TSecStatus          secStatus;
  TSecCipherSession   session       = NULL;
  size_t              metadataSize;
  TUnsignedInt8     * pMetadata     = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) session = (TSecCipherSession)(size_t)pxInputMessage->handle;

    metadataSize = (size_t)pxInputMessage->metadataSize;
    pMetadata    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->metadata);

    secStatus = pgFunctionTable->secSetMetadata (
      session,
      metadataSize,
      pMetadata );
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_allocateBuffer
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_allocateBuffer
(
  TMsgBuf_rpcHandler         xRpcHandler,
  const TNhtsec_SizeInMsg  * pxInputMessage,
  TNhtsec_HandleOutMsg    ** pxOutputMessage
)
{
  TSecStatus      secStatus   = SEC_ERROR;
  TUnsignedInt8 * pSysBuffer;

  if (pgFunctionTable)
  {
    pSysBuffer =  pgFunctionTable->secAllocateBuffer ((size_t)pxInputMessage->value);

    if (pSysBuffer)
    {
      secStatus = SEC_NO_ERROR;
      hndmng_register (pSysBuffer, &_hndmng_sysBufferClose);
      (*pxOutputMessage)->has_handle = 1;
      (*pxOutputMessage)->handle     = (int64_t)(size_t)pSysBuffer;
    }
  }

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_freeBuffer
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_freeBuffer
(
  TMsgBuf_rpcHandler           xRpcHandler,
  const TNhtsec_HandleInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg      ** pxOutputMessage
)
{
  TSecStatus secStatus = SEC_ERROR;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle)
    {
      secStatus = pgFunctionTable->secFreeBuffer ((TUnsignedInt8*)(size_t)pxInputMessage->handle);
      hndmng_unregister ((void*)(size_t)pxInputMessage->handle);
    }
    else secStatus = pgFunctionTable->secFreeBuffer (NULL);
  }

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_useLegacyKey
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_useLegacyKey
(
  TMsgBuf_rpcHandler           xRpcHandler,
  const TNhtsec_HandleInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg      ** pxOutputMessage
)
{
  TSecStatus        secStatus;
  TSecCipherSession session    = NULL;

  if (pgFunctionTable)
  {
    if (pxInputMessage->has_handle) session = (TSecCipherSession)(size_t)pxInputMessage->handle;

    secStatus = pgFunctionTable->secUseLegacyKey (session);
  }
  else secStatus = SEC_ERROR;

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_setInitValue
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_setInitValue
(
  TMsgBuf_rpcHandler          xRpcHandler,
  const TNhtsec_SetIvInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg     ** pxOutputMessage
)
{
  TSecStatus          secStatus;
  TSecCipherSession   session    = NULL;
  TUnsignedInt8     * pIv        = NULL;
  TUnsignedInt8     * pKeyId     = NULL;
  size_t              keyIdSize;
  size_t              ivSize;

  if (pxInputMessage->has_handle) session = (TSecCipherSession)(size_t)pxInputMessage->handle;
  ivSize = (size_t)pxInputMessage->ivSize;
  keyIdSize = (size_t)pxInputMessage->keyIdSize;

  pIv    = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->iv);
  pKeyId = (TUnsignedInt8*)_buildSysInBytes (pxInputMessage->keyId);

  secStatus = _CRPC(nhtSecSetTransportSessionInitialValue) (session, keyIdSize, pKeyId, ivSize, pIv);

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_openDscTransportSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_openDscTransportSession
(
  TMsgBuf_rpcHandler                            xRpcHandler,
  const TNhtsec_OpenDscTransportSessionInMsg  * pxInputMessage,
  TNhtsec_TransportIdOutMsg                  ** pxOutputMessage
)
{
  TSecStatus                    secStatus;
  char                        * pInputFileName        = NULL;
  char                        * pOutputFileName       = NULL;
  TNhtSecDemuxServiceInfo       demuxServiceInfo;
  TNhtSecDemuxServiceInfo     * pDemuxServiceInfo     = NULL;
  TNhtSecDemuxEcmInfo           demuxEcmInfo;
  TNhtSecDemuxEcmInfo         * pDemuxEcmInfo         = NULL;
  int                           isInClear;
  TTransportSessionId           transportSessionId;
  TTransportSessionId         * pTransportSessionId   = NULL;
  TNhtsec_DemuxServiceInfoMsg * pDemuxServiceInfo_msg = NULL;
  TNhtsec_DemuxEcmInfoMsg     * pDemuxEcmInfo_msg     = NULL;
  TRpcTransportHandle         * pTransportCbHandle    = NULL;

  pInputFileName       = (char*)pxInputMessage->inputFilePathname;
  pOutputFileName      = (char*)pxInputMessage->outputFilePathname;
  isInClear            = (int)pxInputMessage->isInClear;

  pTransportCbHandle   = (TRpcTransportHandle*)MSGBUF_SYS_malloc(sizeof (TRpcTransportHandle));
  AVLSet_iterInit ((TAVLSet_iter*)pTransportCbHandle);
  pTransportCbHandle->transportSessionId = 0;
  pTransportCbHandle->magicNumber        = SEC_TRANSPORT_HANDLE_MAGIC_NUMBER;
  pTransportCbHandle->rpcHandler         = xRpcHandler;
  pTransportCbHandle->lastTableId        = 0x00;
  pTransportCbHandle->ecmCallBackHandle  = 0;

  if (pxInputMessage->has_output) pTransportSessionId = &transportSessionId;

  pDemuxServiceInfo_msg = pxInputMessage->demuxServiceInfo;
  if (pDemuxServiceInfo_msg)
  {
    pDemuxServiceInfo           = &demuxServiceInfo;
    pDemuxServiceInfo->audioPid = (int)pDemuxServiceInfo_msg->audioPid;
    pDemuxServiceInfo->videoPid = (int)pDemuxServiceInfo_msg->videoPid;
    pDemuxServiceInfo->pcrPid   = (int)pDemuxServiceInfo_msg->pcrPid;
  }

  pDemuxEcmInfo_msg = pxInputMessage->demuxEcmInfo;
  if (pDemuxEcmInfo_msg)
  {
    pDemuxEcmInfo = &demuxEcmInfo;

    pDemuxEcmInfo->ecmPid           = (int)pDemuxEcmInfo_msg->ecmPid;
    pDemuxEcmInfo->ecmCbfct         = &rpcEcmCallBackFunction;
    pDemuxEcmInfo->ecmCbPrivateData = (TNhtsecCallBackPrivateParameters)pTransportCbHandle;
    pTransportCbHandle->ecmCallBackHandle = pDemuxEcmInfo_msg->ecmCallBackHandle;

    pTransportCbHandle->ecmCallBackHandle  = pDemuxEcmInfo_msg->ecmCallBackHandle;
  }
  else
  {
    pTransportCbHandle->ecmCallBackHandle  = (int64_t)0;
    pDemuxEcmInfo->ecmCbPrivateData        = NULL;
    pDemuxEcmInfo->ecmCbfct                = NULL;
  }

  if (pgTransportIdSetMutex == NULL)
  {
    AVLSet_init ( &gTransportIdSet, &_transportSessionId_compare, 0);
    pgTransportIdSetMutex = MSGBUF_SYS_createThreadMutex();
  }

  secStatus = _CRPC(nhtSecOpenDscTransportSession) (
    pInputFileName,
    (const TNhtSecDemuxServiceInfo*)pDemuxServiceInfo,
    isInClear,
    (const TNhtSecDemuxEcmInfo*)pDemuxEcmInfo,
    pOutputFileName,
    pTransportSessionId );

  if ((secStatus == SEC_NO_ERROR) && pTransportSessionId)
  {
    (*pxOutputMessage)->has_handle = 1;
    (*pxOutputMessage)->handle     = (uint32_t)*pTransportSessionId;

    if (pTransportCbHandle && pTransportSessionId)
    {
      TAVLSet_iter * pIter;

      pTransportCbHandle->transportSessionId = (uint32_t)*pTransportSessionId;

      MSGBUF_SYS_acquireThreadMutex (pgTransportIdSetMutex);
      pIter = AVLSet_insert (&gTransportIdSet, (TAVLSet_iter*)pTransportCbHandle);
      MSGBUF_SYS_releaseThreadMutex (pgTransportIdSetMutex);

      if (pIter != AVLSet_end(&gTransportIdSet)) pTransportCbHandle = NULL;
    }
  }

  if (pTransportCbHandle) MSGBUF_SYS_free (pTransportCbHandle);

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_openScrTransportSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_openScrTransportSession
(
  TMsgBuf_rpcHandler                            xRpcHandler,
  const TNhtsec_OpenScrTransportSessionInMsg  * pxInputMessage,
  TNhtsec_TransportIdOutMsg                  ** pxOutputMessage
)
{
  TSecStatus                    secStatus;
  char                        * pInputFileName        = NULL;
  char                        * pOutputFileName       = NULL;
  TNhtSecDemuxServiceInfo       demuxServiceInfo;
  TNhtSecDemuxServiceInfo     * pDemuxServiceInfo     = NULL;
  int                           isForEncryption;
  TTransportSessionId           transportSessionId;
  TTransportSessionId         * pTransportSessionId   = NULL;
  TNhtsec_DemuxServiceInfoMsg * pDemuxServiceInfo_msg = NULL;
  TRpcTransportHandle         * pTransportCbHandle    = NULL;

  pInputFileName  = (char*)pxInputMessage->inputFilePathname;
  pOutputFileName = (char*)pxInputMessage->outputFilePathname;
  isForEncryption = (int)pxInputMessage->isForEncryption;

  pTransportCbHandle   = (TRpcTransportHandle*)MSGBUF_SYS_malloc(sizeof (TRpcTransportHandle));
  AVLSet_iterInit ((TAVLSet_iter*)pTransportCbHandle);
  pTransportCbHandle->transportSessionId = 0;
  pTransportCbHandle->magicNumber        = SEC_TRANSPORT_HANDLE_MAGIC_NUMBER;
  pTransportCbHandle->rpcHandler         = xRpcHandler;
  pTransportCbHandle->lastTableId        = 0x00;
  pTransportCbHandle->ecmCallBackHandle  = (int64_t)0;

  if (pxInputMessage->has_output) pTransportSessionId = &transportSessionId;

  pDemuxServiceInfo_msg = pxInputMessage->demuxServiceInfo;
  if (pDemuxServiceInfo_msg)
  {
    pDemuxServiceInfo           = &demuxServiceInfo;
    pDemuxServiceInfo->audioPid = (int)pDemuxServiceInfo_msg->audioPid;
    pDemuxServiceInfo->videoPid = (int)pDemuxServiceInfo_msg->videoPid;
    pDemuxServiceInfo->pcrPid   = (int)pDemuxServiceInfo_msg->pcrPid;
  }

  if (pgTransportIdSetMutex == NULL)
  {
    AVLSet_init ( &gTransportIdSet, &_transportSessionId_compare, 0);
    pgTransportIdSetMutex = MSGBUF_SYS_createThreadMutex();
  }

  secStatus = _CRPC(nhtSecOpenScrTransportSession) (
    pInputFileName,
    (const TNhtSecDemuxServiceInfo*)pDemuxServiceInfo,
    isForEncryption,
    pOutputFileName,
    pTransportSessionId );

  if ((secStatus == SEC_NO_ERROR) && pTransportSessionId)
  {
    (*pxOutputMessage)->has_handle = 1;
    (*pxOutputMessage)->handle     = (uint32_t)*pTransportSessionId;

    if (pTransportCbHandle && pTransportSessionId)
    {
      TAVLSet_iter * pIter;

      pTransportCbHandle->transportSessionId = (uint32_t)*pTransportSessionId;

      MSGBUF_SYS_acquireThreadMutex (pgTransportIdSetMutex);
      pIter = AVLSet_insert (&gTransportIdSet, (TAVLSet_iter*)pTransportCbHandle);
      MSGBUF_SYS_releaseThreadMutex (pgTransportIdSetMutex);

      if (pIter != AVLSet_end(&gTransportIdSet)) pTransportCbHandle = NULL;
    }
  }

  if (pTransportCbHandle) MSGBUF_SYS_free (pTransportCbHandle);

  (*pxOutputMessage)->retStatus = (int32_t)secStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_startTransportSessionStreaming
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_startTransportSessionStreaming
(
  TMsgBuf_rpcHandler                xRpcHandler,
  const TNhtsec_TransportIdInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg           ** pxOutputMessage
)
{
  TTransportSessionId              transportSessionId;
  TNhtSecTransportStreamingStatus  secTransportStreamStatus;

  transportSessionId = (TTransportSessionId)pxInputMessage->handle;

  secTransportStreamStatus = _CRPC(nhtSecStartTransportSessionStreaming) (transportSessionId);
  (*pxOutputMessage)->retStatus = (int32_t)secTransportStreamStatus;

  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_waitOnTransportSessionStreamingCompletion
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_waitOnTransportSessionStreamingCompletion
(
  TMsgBuf_rpcHandler                     xRpcHandler,
  const TNhtsec_WaitOnCompletionInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg                ** pxOutputMessage
)
{
  TTransportSessionId              transportSessionId;
  TNhtSecTransportStreamingStatus  secTransportStreamStatus;
  int                              timeout;

  transportSessionId = (TTransportSessionId)pxInputMessage->handle;
  timeout            = (int)pxInputMessage->timeout;

  secTransportStreamStatus = _CRPC(nhtSecWaitOnTransportSessionStreamingCompletion) (
    transportSessionId,
    timeout );

  (*pxOutputMessage)->retStatus = (int32_t)secTransportStreamStatus;
  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_stopTransportSessionStreaming
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_stopTransportSessionStreaming
(
  TMsgBuf_rpcHandler                xRpcHandler,
  const TNhtsec_TransportIdInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg           ** pxOutputMessage
)
{
  TTransportSessionId             transportSessionId;
  TNhtSecTransportStreamingStatus secTransportStreamStatus;

  transportSessionId = (TTransportSessionId)pxInputMessage->handle;

  secTransportStreamStatus = _CRPC(nhtSecStopTransportSessionStreaming) (transportSessionId);
  (*pxOutputMessage)->retStatus = (int32_t)secTransportStreamStatus;

  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_nhtsec_hc_nht_closeTransportSession
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_nhtsec_hc_nht_closeTransportSession
(
  TMsgBuf_rpcHandler                xRpcHandler,
  const TNhtsec_TransportIdInMsg  * pxInputMessage,
  TNhtsec_StatusOutMsg           ** pxOutputMessage
)
{
  TTransportSessionId transportSessionId;
  TSecStatus          secStatus;

  transportSessionId = (TTransportSessionId)pxInputMessage->handle;

  if (pgTransportIdSetMutex == NULL)
  {
    AVLSet_init ( &gTransportIdSet, &_transportSessionId_compare, 0);
    pgTransportIdSetMutex = MSGBUF_SYS_createThreadMutex();
  }

  secStatus = _CRPC(nhtSecCloseTransportSession) (transportSessionId);
  (*pxOutputMessage)->retStatus = (int32_t)secStatus;

  if (secStatus == SEC_NO_ERROR)
  {
    TRpcTransportHandle   transportHandle;
    TAVLSet_iter        * pIter;

    transportHandle.transportSessionId = transportSessionId;

    MSGBUF_SYS_acquireThreadMutex (pgTransportIdSetMutex);
    pIter = AVLSet_find (&gTransportIdSet, (TAVLSet_iter*)&transportHandle);
    if (pIter != AVLSet_end(&gTransportIdSet))
    {
      AVLSet_remove (&gTransportIdSet, pIter);
      MSGBUF_SYS_free (pIter);
    }

    MSGBUF_SYS_releaseThreadMutex (pgTransportIdSetMutex);
  }

  return RPC_STATUS_NO_ERROR;
}


/*****************************************************************************
 * RPC method calls API wrapper                                              *
 ****************************************************************************/


/* RPC method: rpc_nhtcsd_tn_ecmCallBack
 *
 * This method stands as an asynchronous notification function.
 * Caller of this function immediately returns without waiting
 * the completion of its remote execution.
 *
 * PS: param 'pxOutputMessage' is always assumed to be NULL.
 */
static TSecStatus rpcEcmCallBackFunction
(
  TTransportSessionId                xTransportSessionId,
  TNhtsecCallBackPrivateParameters   xPrivateParameters,
  TUnsignedInt8                      xEcmTableId,
  const TUnsignedInt8              * pxEcmContent,
  TSize                              xEcmContentSize
)
{
  TRpcTransportHandle    * pHandle;
  TRpc_status              rpcStatus;
  TNhtsec_EcmCallBackMsg   rpcEcmCallBackInMsg;
  TRpcTransportHandle      transportHandle;
  TAVLSet_iter           * pIter;

  pHandle = (TRpcTransportHandle*)xPrivateParameters;

  transportHandle.transportSessionId = xTransportSessionId;

  MSGBUF_SYS_acquireThreadMutex (pgTransportIdSetMutex);
  pIter = AVLSet_find (&gTransportIdSet, (TAVLSet_iter*)&transportHandle);
  MSGBUF_SYS_releaseThreadMutex (pgTransportIdSetMutex);

  if (pIter != AVLSet_end(&gTransportIdSet))
  {
    if ((void*)pIter != (void*)pHandle)
    {
      return SEC_NO_ERROR;
    }
  }
  else return SEC_ERROR;

  if (pHandle->magicNumber != SEC_TRANSPORT_HANDLE_MAGIC_NUMBER)
  {
    return SEC_NO_ERROR;
  }

  /* Only concider new tableId (in case if this wasn't filtered in the CM's
   * implementation. */
  if ((xEcmTableId == pHandle->lastTableId) && (pHandle->lastTableId != 0))
  {
    return SEC_NO_ERROR;
  }

  pHandle->lastTableId = xEcmTableId;

  /* nht_printout_buffer ("ECM", (void*)pxEcmContent, (int)xEcmContentSize); */

  /* Export callback notification to the host */
  init_Nhtsec_EcmCallBackMsg (&rpcEcmCallBackInMsg);

  rpcEcmCallBackInMsg.transportSessionId = (uint32_t)pHandle->transportSessionId;
  rpcEcmCallBackInMsg.tableId = (uint32_t)xEcmTableId;

  if (pHandle->ecmCallBackHandle)
  {
    rpcEcmCallBackInMsg.ecmCallBackHandle     = pHandle->ecmCallBackHandle;
    rpcEcmCallBackInMsg.has_ecmCallBackHandle = 1;
  }

  rpcEcmCallBackInMsg.ecmSize = (uint64_t)xEcmContentSize;
  if (pxEcmContent)
  {
    rpcEcmCallBackInMsg.ecm.pData = (void*)pxEcmContent;
    rpcEcmCallBackInMsg.ecm.len   = (uint64_t)xEcmContentSize;
  }

  rpcStatus =  rpc_nhtsec_tn_ecmCallBack (
    pHandle->rpcHandler,
    &rpcEcmCallBackInMsg,
    NULL );

  if (rpcStatus == RPC_STATUS_NO_ERROR) return SEC_NO_ERROR;
  else return SEC_ERROR;
}
