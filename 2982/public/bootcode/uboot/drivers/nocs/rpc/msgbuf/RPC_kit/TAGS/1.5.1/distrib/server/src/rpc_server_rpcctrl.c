/* DO NOT EDIT THIS FILE!!!
 * This file was automatically generated by msgbuf compiler!
 *
 * This file contains the msgbuf structure definitions associated
 * to the package rpcctrl_2eproto
 */


/*****************************************************************************
 * include files                                                             *
 ****************************************************************************/

#include "inc/rpc_rpcctrl.h"
#include "src/rpc_rpcctrl_api.h"
#include "inc/msgbuf_rpc_service.h"
#include "inc/msgbuf_sys_malloc.h"
#include "inc/xsd-c.h"
#include "inc/msgbuf_sys_string.h"
#include "inc/hndmng.h"
#include "inc/rpc_ftrace.h"


/*****************************************************************************
 * RPC methods implementation                                                *
 ****************************************************************************/

/* RPC method: rpc_rpcctrl_hc_getServiceDescSet
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_rpcctrl_hc_getServiceDescSet
(
  TMsgBuf_rpcHandler                  xRpcHandler,
  const TRpcctrl_EmptyMsg           * pxInputMessage,
  TRpcctrl_RpcServiceDescSetOutMsg ** pxOutputMessage
)
{
 TRpcServiceHnd        * pRpcServiceHandleSet = NULL;
 int                     serverServiceNumber;
 int                     i;

  serverServiceNumber = msgbuf_rpc_getServiceHandleSet (
    xRpcHandler,
    &pRpcServiceHandleSet );
  if (serverServiceNumber < 0) return RPC_STATUS_FUNCTION_NOT_FEATURED;

  (*pxOutputMessage)->serviceDesc = (TRpcctrl_RpcServiceDescriptor **)MSGBUF_SYS_malloc(sizeof(TRpcctrl_RpcServiceDescriptor*) * serverServiceNumber);
  (*pxOutputMessage)->n_serviceDesc = (size_t)serverServiceNumber;

  for (i=0; i < serverServiceNumber; i++)
  {
    TMsgBuf_serviceDescriptor const * pServiceDesc;

    pServiceDesc = (TMsgBuf_serviceDescriptor const *)pRpcServiceHandleSet[i].rpcService;

    (*pxOutputMessage)->serviceDesc[i] = pAlloc_Rpcctrl_RpcServiceDescriptor ();
    (*pxOutputMessage)->serviceDesc[i]->serviceIdx = (uint32_t)i;

    (*pxOutputMessage)->serviceDesc[i]->packageName = MSGBUF_SYS_malloc(MSGBUF_SYS_strlen(pServiceDesc->pPackage) + 1);
    MSGBUF_SYS_strcpy ((*pxOutputMessage)->serviceDesc[i]->packageName, pServiceDesc->pPackage);

    (*pxOutputMessage)->serviceDesc[i]->serviceName = MSGBUF_SYS_malloc(MSGBUF_SYS_strlen(pServiceDesc->pServiceName) + 1);
    MSGBUF_SYS_strcpy ((*pxOutputMessage)->serviceDesc[i]->serviceName, pServiceDesc->pServiceName);
  }

  return RPC_STATUS_NO_ERROR;
}


/* RPC method: rpc_rpcctrl_hc_resync
 *
 * This method stands as a synchronous function call.
 * Caller of this function only returns after completion of
 * its remote execution.
 */
TRpc_status rpc_rpcctrl_hc_resync
(
  TMsgBuf_rpcHandler         xRpcHandler,
  const TRpcctrl_EmptyMsg  * pxInputMessage,
  TRpcctrl_EmptyMsg       ** pxOutputMessage
)
{
	RPC_FTRACE_RESTORE_DEFAULT();
  hndmng_terminate ();
  return RPC_STATUS_NO_ERROR;
}


/*****************************************************************************
 * RPC method calls API wrapper                                              *
 ****************************************************************************/

